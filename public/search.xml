<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>&lt;论文&gt;一篇关于自动生成源代码评论的报告</title>
    <url>/2020/04/30/A%20Survey%20of%20Automatic%20Generation%20of%20SourceCode%20Comments_%20Algorithms%20and%20Techniques%E7%BB%BC%E8%BF%B0%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>A Survey of Automatic Generation of SourceCode Comments_ Algorithms and Techniques综述论文阅读笔记</p>
<a id="more"></a>
<h1 id="一篇关于自动生成源代码评论的报告"><a href="#一篇关于自动生成源代码评论的报告" class="headerlink" title="一篇关于自动生成源代码评论的报告"></a>一篇关于自动生成源代码评论的报告</h1><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>代码评论主要用于提高源码的可读性与可理解性。<br>第一步，大致的分析了代码评论的挑战与调查框架；第二，介绍了典型的算法分类，设计原理、以及各个算法的优缺点。本论文提供了代码评论的质量评估概述，最后总结一些关于代码评论生成和评论质量检测未来的方向。</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>代码评论主要是针对程序的功能与意义大致描述。不仅仅通过代码评论提高代码可理解性，有研究提出通过定义一个长的描述性的方法类名等，提示代码的用处。</p>
<p>之前用于代码注释的方法是机器学习或者基于信息检索技术，评论的框架大致分为三个方面：数据准备；源代码表达；文本生成<br><img src="https://img-blog.csdnimg.cn/20191229162512154.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQzMzk2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>代码注释与注释的质量检测是相辅相成的，质量检测标注的指定是代码注释领域的一大挑战。<br>代码注释是软件工程与人工智能的交叉研究领域，发了好多顶会。本论文解决的问题：<strong>1.使研究人员能够访问具有代表性的算法目录，以进行自动注释生成，并使新研究人员对自动代码注释的最新算法有很好的了解； 2.总结现有研究的主要挑战和局限性</strong><br>第二部分提供了自动生成评论的动机，并讨论了技术挑战。 第三节讨论了注释生成技术的核心思想，并对各种技术进行了总结。 在第四节中，我们讨论了注释的质量评估问题，并以不同研究中使用的数据集为重点，并总结了代码注释的质量评估标准。 第五节将讨论自动代码注释生成的未来方向。在第六节中，我们总结了本文</p>
<h2 id="自动生成代码注释的概述"><a href="#自动生成代码注释的概述" class="headerlink" title="自动生成代码注释的概述"></a>自动生成代码注释的概述</h2><p>A、问题陈述<br>代码注释生成主要就是将程序性语言转化为自然语言的描述，不仅描述了代码的功能也体现出编程者背后的思想。简单讲就是通过代码分析，揭示出设计意图，代码逻辑、程序功能、相关参数的含义。<br>B、代码自动生成与研究框架的挑战<br>目前的研究算法工作流程大致都和图一中的一致。<br>自动代码评论的过程通常分为三个方向：第一，将数据收集用于构建评论生成体系的数据集。这些被用于训练、验证、测试模型，提取代码与相对应的评论，或者提取评论生成系统中所需要的特殊规则。通常通过对开源社区或者网站爬取、下载等方式获得数据集。第二、通过确定的算法评论生成。<strong>第三节</strong>具体讲解。第三、评论质量检测。有俩种流行的方法：人工检测与自动化检测。这将会在<strong>第四节</strong>讲解。</p>
<p>依据检测结果会有不同的进一步措施：评测结果令人满意，评论过程就会停止；否则，程序会回到第一步：准备更多的更合适的数据 或者调整源码处理算法，继续下面的过程。重复上述过程。</p>
<p>1.）目前的挑战</p>
<p>a：挑战一：代码自动注释算法<br>总结为三类算法;1.基于信息检索算法2.基于深度神经网络算法3.其他代码自动生成算法（详细见第三节）<br><code>源码模型：ASTs、 分析树、上下文token、CFGs、数据流等等</code><br>上述模型被分为三种目录：1.基于token的代码模型，从源码中提取关键词或者关于主题的词语,词袋模型（BoT）或者（Bow）.基于信息检索的算法主要通过模型去表示源码。2.基于句法规则的模型，主要是抽象语法树，基于深度神经网络3.其他模型。<br>缺少可以综合表示源码各种信息的复合模型。目前的困难就是寻找一个这种综合性 的模型。<br><code>文本生成：在代码评论的项目中，必须在构建自然语言注释之前先提取出代码语言的相关信息，这是一个难点</code><br>现存的文本生成算法可以分为三种：1.基于事先设定好的规则生成2.基于解码编码生成（encoder-decoder模型）3.基于文本检索，从语料库种查询现存的相似注解</p>
<p>b、挑战二：注释质量检测<br>存在两个问题：<strong>验证测试算法需要统一的数据集</strong>；<strong>评估标准的选择</strong></p>
<p><code>统一的数据集：需要将测试的数据集做一个统一，但是，由于每个特定的注释生成算法都具有语言依赖性，因此要统一数据集进行测试就具有挑战性。</code></p>
<p><code>评估标准的选择：设计和制定适当的注释质量评估指标非常重要，这将促进自动代码注释生成的研究</code></p>
<p>2.）research framework<br>目前，关于代码注释的研究文献主要集中在注释与代码可读性之间的关系，注释与代码可理解性之间的关系，代码注释的自动编程算法和质量评估等方面。<br>通常我们从两个方面总结目前的代码注释与相关研究<strong>：自动程序注释技术</strong>；<strong>代码注释的质量评估</strong>。我们会在本片论文种讨论分析注释的质量检测问题。另一种与代码注释相关的工作是在于引导开发者在何处进行正确的代码注释？？？这也能是一个方向？？，旨在提高代码的可读性。<br><img src="https://img-blog.csdnimg.cn/2019123015232778.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQzMzk2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><strong>本文重点研究评论生成算法和评论质量评估算法。 这两条工作线相互依存，它们的关系如图2所示。</strong></p>
<p>3.）代码注释技术领域的发展趋势<br>2010-2014大多数采用信息检索的方法；<br>近五年大多采用深度神经网络技术。<br>为了研究从最近十年发表的59篇论文中选出32篇代表性的论文阅读文献。<br><img src="https://img-blog.csdnimg.cn/2019123015234468.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQzMzk2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>图3</strong>显示了多年来根据论文中使用的算法类型分配的论文,本图印证了上面关于技术趋势的总结（信息检索和深度神经网络）。图3表明最近的研究主要集中在基于深度神经网络的评论技术上</p>
<h2 id="代码注释的算法"><a href="#代码注释的算法" class="headerlink" title="代码注释的算法"></a>代码注释的算法</h2><p>本节主要展示代码注释的相关算法的分类：<br>A、算法分类<br>三类：如图<br><img src="https://img-blog.csdnimg.cn/20191230152852957.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQzMzk2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>B、基于信息检索的评论生成算法<br>给一个无注释的源码以及一个拥有注释的源码数据集，基于信息检索的算法可以计算出无注释源码与数据集的相关性，并精确的预测出无注释源码的相应注释。<br>基于信息检索技术的注释算法通常利用基于向量空间模型（VSM），潜在语义索引（LSI）和潜在狄利克雷分配（LDA）的技术或其他相关技术，例如代码克隆检测（代码查重）。信息检索（IR）技术在软件工程领域的早期应用之一是关于代码和注释之间的可追溯性。</p>
<p>2003年，Marcusand Maletic [45]利用潜在语义索引（LSI）技术，对源代码和外部文档进行分析，以从程序和文档中提取语义信息，并进一步恢复了文档和源代码之间的链接。 尽管研究本身并不涉及自动注释生成的问题，但该方法可以应用于代码注释。在现有文献中，相似性比较不是直接以源代码文本的形式进行的。<br>大多数注释系统将源代码转换为<strong>解析树（parse tree）或抽象语法树（AST）</strong>的形式，然后将目标代码与数据集中的其他源代码进行比较，根据比较结果返回响应的matched代码。采用启发式规则对匹配码的对应注释进行过滤。最后获得最匹配的对应代码注释作为输入无注释源码的注释。总的来说，这些算法通常通过搜索或设计规则来生成评论文本。</p>
<p>1）基于VSM/LSI 的代码注释生成算法</p>
<pre><code>VSM（基于向量空间模型）/LSI （潜在语义索引）</code></pre><p>当我们使用VSM和/或LSI为源代码生成注释时，源代码文本或查询文本通常表示为向量，矩阵或元组。向量中的每个元素表示文档中单词的权重。在VSM中，有很多计算项权重的方法，而项频逆文档频率（tf-idf）是使用最广泛的加权方法。LSI利用奇异值分解（SVD），识别术语和概念之间的术语相关性，并提取文本的概念性主题。<strong>注释系统根据每个术语的权重值确定该术语是否应出现在源代码注释中</strong>，或计算查询文本向量与源代码文本之间的文本相似度。具有较高相似性的术语表示与代码段或查询主题相关性更高。基于查询的代码注释系统便根据这些高相关性的关键词组成目标源码的注释。<br>这些技术用于挖掘代码文本，并在源代码文本中找出关键字，以将自然语言描述构造为代码注释。这些注释常用于描述功能、特征或者源码的变量，例如类、方法、代码块等等。<br><strong>Haiduc的应用</strong>：采用VSM和LSI 的方法分析源码文本产生源码类或者方法的自然语言总结。首先，他们将源代码文档和程序包转换为文档集，称为语料库。 然后，他们将标识符名称中包含的术语以及来自源代码和文档的注释以矩阵形式表示出来。使用VSM生成源代码的摘要时，将根据选择的权重选择源代码文档中最相关的术语，同时还使用LSI技术计算语料库中每个术语的向量与向量之间的余弦相似度 源代码文档的摘要，然后生成高度相似的术语，这些术语不会出现在要概述的方法或类中，而是出现在语料库中。这样，他们分析了<strong>Java项目中的方法和类源代码</strong>，并为其生成了简短，准确的文本描述。<strong>Haiduce</strong>t等人做出了另一种贡献， <strong>仅利用LSI为开放源代码存储库中的Java类代码生成摘要注释</strong>。<br>Vassalloet等人利用相同的方法。 使用VSM模型来表示Stack Overflow上的问与答（Q＆A）中的源代码文本和开发人员讨论文本为矢量，并计算目标源代码文本和讨论文本之间的<strong>余弦相似度</strong>以查找映射。 推荐使用高度相似的段落文本作为目标源代码的注释。 结果，他们挖掘了众包知识以推荐评论方法。<br>同样，Panichellaet等人[57] 使用启发式和向量空间模型来处理和分析开发人员通信以进行方法描述。 开发人员交流主要是指与类，方法和参数有关的电子邮件和错误报告。 他们提取可追溯到源代码方法的段落文本，<strong>并通过计算文本段落和每种跟踪方法的文本之间的文本相似度（即余弦相似度）来识别相关段落</strong>（<strong><code>这句话没有明白</code></strong>）。 建议使用相似度高的相关段落作为方法说明。<br>这种技术的缺点在于，它仅考虑语料库或源代码文档中出现的术语，而不考虑源代码文档中包含的其他信息，例如程序调用，数据依赖性，源代码中的单词序列 。 因此，这些系统难以进一步提高所生成评论的准确性。（有较高的局限性。目前的应用层面依旧在数据挖掘中，个人猜测）</p>
<p>2）基于代码克隆检测的注释生成算法<br>wong的案例： 提出一种基于编码克隆检测技术的方法，该方法可从大型编程问答网站（Q＆A）挖掘评论。来自Q＆A的关于Stack Overflow的帖子，包含代码片段以及相应的文本描述，被称为代码描述映射（即为代码和相应的文本描述是一一对应的），这种对应关系被提取出来作为数据库，然后找最大对应子字符串。。。。够狠！！这种办法生成的注释的数量和质量在很大程度上取决于为注释系统构建的数据集的规模和质量。</p>
<p>这种方法的缺点是生成的评论数量少得多。 原因是生成的注释的数量很大程度上取决于数据库或GitHub的开源软件项目中包含的信息。 例如，如果从未在任何帖子中讨论过代码段，则评论系统将根本无法推荐任何评论。<br>3）基于LDA的注释生成算法</p>
<p>基于LDA的注释生成算法涉及使用LDA模型构建源代码模型并为目标源代码生成注释。 换句话说，LDA可以提取源代码的特定功能。<br>另外，Movshovitz-Attias和Cohen [52]使用主题模型，LDA和n-gram模型来预测Java源代码的注释。 他们分别从多个训练数据集中，在相同的源代码文档上训练n-gram模型和LDA模型。 然后他们将文档视为具有两种实体类型（代码和文本令牌）的混合成员，并在文档上训练链接LDA模型。使用受过训练的模型，他们计算文档主题的后验概率，并进一步推断注释令牌的概率。 最后，建议将高概率的注释标记作为源代码文件的注释。<br>Rahmanet等人使用LDA [61]。 分析来自Stack Overflow问答站点的讨论，以为开源项目推荐有见地的评论。 他们利用不同于Wonget等人的基于启发式的技术[83]来挖掘众包知识以对开源项目发表评论。 生成的注释主要描述了源代码的不足，质量和范围，以改进源代码，并可以帮助维护工程师执行维护任务</p>
<p>4） 其他的基于信息检索的注释生成算法</p>
<p><code>暂略</code></p>
<p><strong>C、基于深度神经网络的注释生成算法</strong>（<strong>重点部分</strong>！！！）</p>
<p>代码注释生成可以被当作是一种翻译工作（程序语言与自然语言之间）</p>
<p>主要由两个方向：基于循环神经网络算法与基于其他神经网络算法。深度神经网络分为三种：卷积神经网络（CNN），循环神经网络（RNN）和递归神经网络（RvNN？？不确定是啥。。）[60]。<br>卷积神经网络适合用于NLP，图像识别和语音处理等方向中。RNN常用于处理和预测顺序数据，在NLP和语音处理中应用较好；RNN和RvNN均可用于本论文场景–代码注释生成。</p>
<ul>
<li>两个重要的结构：<strong>encoder-decoder结构</strong>和<strong>attention机制</strong></li>
</ul>
<p><strong>a、encoder-decoder结构</strong></p>
<p>在编码器-解码器的结构中，编码器起到将源代码编码为固定大小的矢量的作用； 解码器负责对源代码矢量进行解码并预测源代码的注释。各种编码器/解码器结构之间的差异在于输入形式和神经网络的类型。通常，编码器/解码器的内部结构可以选择RNN，CNN 和RNN的变体，例如门控循环单元（GRU）和长期短期记忆模型（LSTM）。</p>
<p><strong>b、attention机制</strong></p>
<p>它负责将较高的权重值动态分配给解码器输入序列中每个单词的更相关的标记。对于长序列情况下性能不佳的问题，这是一个很好的解决方案。由于基于深度神经网络的注释生成算法属于机器学习的类别，因此基于深度神经网络的注释生成系统需要包含代码和注释的高质量数据集来训练神经网络。<strong>数据集可以满足系统的所有数据需求，还提供用于训练以及验证和测试评论算法的数据</strong>，一集多用。。。</p>
<p>1）基于RNN的注释生成算法</p>
<p>RNN的另外两个重要变体是<strong>长期短期记忆模型（LSTM）</strong>和<strong>门控循环单元（GRU）</strong>。<br>LSTM的特点是它具有三门控制器结构并构造了可控制的记忆神经元，可解决传统RNN中的梯度下降和梯度爆炸。<br>与LSTM相比，GRU结构简单，克服了LSTM的缺点：结构复杂，实现复杂，执行效率低。GRU仅使用两个门：一个是更新门，另一个是复位门。<br>根据编码器中使用的RNN数量，将基于RNN的注释生成算法分为两类：<strong>基于单编码器的注释算法</strong>和<strong>基于多编码器的注释算法</strong><br>ａ、基于单编码器的注释算法</p>
<p>编码器由一个RNN组成。这是一个典型的用于代码注释生成的编码解码结构。</p>
<p>*<em>一篇比较先进的论文: RvNN ,parse tree,encoder-decoder(GRU based),attention:Y.Liang and K. Q. Zhu, ‘‘Automatic generation of text descriptive com-ments for code blocks,’’ *</em></p>
<p>b.基于多编码器的注释生成算法</p>
<p>RNN利用GRU或LSTM表示长输入序列之间的长距离特征。 CNN利用卷积注意或卷积层来收集和表示源代码的功能和位置模型</p>
]]></content>
      <tags>
        <tag>论文</tag>
      </tags>
  </entry>
  <entry>
    <title>Bert简单理解——原理与介绍</title>
    <url>/2020/04/28/Bert%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3%E2%80%94%E2%80%94%E5%8E%9F%E7%90%86%E4%B8%8E%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p>关于Bert的相关笔记：</p>
<a id="more"></a>
<h1 id="1-BERT的作用"><a href="#1-BERT的作用" class="headerlink" title="1.BERT的作用"></a>1.BERT的作用</h1><p>学习参考链接：<a href="https://www.infoq.cn/article/HBS5tZGyqzaxtCSvz3pJ" target="_blank" rel="noopener">infoQ</a>  <a href="https://www.infoq.cn/article/UhS0UsctOQ2pbiXL3SAY" target="_blank" rel="noopener">infoQ2</a></p>
<p>因为在NLP任务中我们需要大量的任务专有数据，通常情况下只能将文本分成字段，得到几百或者几十万个人工标注的数据，这远远不够NLP任务中所用的训练数据。</p>
<p>所以开发一系列训练通用得语言模型，使用网上爬虫获取的文本（未注释）作为模型输入，得到大量的专有任务需要的数据集,该过程也成为<strong>预训练</strong>。</p>
<p>Bert就是这样的一个训练通用语言模型的工具。(自己理解意义上的)</p>
<h1 id="2-BERT核心思想"><a href="#2-BERT核心思想" class="headerlink" title="2.BERT核心思想"></a>2.BERT核心思想</h1><p><strong>Masked LM</strong> 新技术：它随机 mask 句子中的单词，然后尝试预测它们。mask 意味着模型将从两个方向观察，它使用句子的全部上下文，包括左边和右边的环境，来预测被 mask 的词(将某个词盖住，并预测该词)。与之前的语言模型不同，它会同时考虑前一个和下一个标记。现有的基于 LSTM 的从左到右和从右到左的组合模型缺少这个“相同时间的部分”。（更准确地说，BERT 是没有方向性的。）</p>
<h1 id="3-BERT的工作原理"><a href="#3-BERT的工作原理" class="headerlink" title="3.BERT的工作原理"></a>3.BERT的工作原理</h1><p>BERT 依附于“Transformer”（一种标注机制，用来学习文本中单词之间的上下文关系）。<br><strong>Transformer简介</strong>：一个基本的 Transformer 包括一个编码器，用来读取文本输入，一个解码器，用来产生关于任务的预测。<br><strong>BERT中仅需要一个编码器的部分</strong><br><strong>BERT 是一个用 Transformers 作为特征抽取器的深度双向预训练语言理解模型</strong><br><strong>word2vec是一个上下文无关的模型，为词汇表中的每个词都找到各自的词向量</strong></p>
<p>Transformer 工作时力求执行一个少的、恒定数量的步骤。在每个步骤中，它应用一个<strong>标注机制</strong>来<strong>理解句子中所有单词之间的关系，而不管它们的位置</strong>。例如，对于句子“ I arrived at the bank after crossing the river”，需要确定“bank”这个词是指一条河的岸边，而不是一个金融机构，Transformer 可以很快根据“river”这个词进行标注，只用一步就实现了目的。</p>
<h2 id="3-1BERT预训练的输入"><a href="#3-1BERT预训练的输入" class="headerlink" title="3.1BERT预训练的输入"></a>3.1BERT预训练的输入</h2><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zdGF0aWMwMDEuaW5mb3EuY24vcmVzb3VyY2UvaW1hZ2UvZjYvZmEvZjZiYjI2MDBkODhiNWM2MDM3MTBhZGI3YTAyZmU5ZmEucG5n?x-oss-process=image/format,png" alt="在这里插入图片描述"></p>
<blockquote>
<p><strong>1.</strong>词嵌入后的 Token Embedding，每次输入总以符号 [CLS] 的 embedding 开始，如果是两个句子，则句之间用 [SEP] 隔开。<br><strong>2.</strong>句子类别的符号。将表示句子 A 或句子 B 的标记添加到每个 token 中。这可以在不同的句子间区分编码器。<br><strong>3.</strong>Position Embedding，同Transformer 中的一致。将positional embedding 添加到每个 token 中，以标示其在句子中的位置</p>
</blockquote>
<p>将上述的<strong>三个向量相加</strong>即为<strong>BERT预训练的输入</strong></p>
<h2 id="3-2-Masked-Language-Model（核心思想）"><a href="#3-2-Masked-Language-Model（核心思想）" class="headerlink" title="3.2 Masked Language Model（核心思想）"></a>3.2 Masked Language Model（核心思想）</h2><p>BERT在训练的时候将遮盖住语料中的15%的词语，用[MASK]代替，通过预测这部分的词语（与true word相比较）学习句子中的语义、句法和语义信息。（这是一个不断迭代的过程，参考word2vec的训练过程）</p>
<blockquote>
<p><strong>其指导思想是“简单”</strong>：使用（ MASK） token 随机 mask 15% 的单词输入，之后运行基于编码器的 BERT 标注，然后基于所提供的上下文中的其他 non-masked 词序列预测被 mask 的单词含义。然而，这种原始的 mask 方法有一个问题——模型只在 [ MASK]token 出现在输入中时才尝试预测，而我们希望模型不管输入中出现了什么 tokens 都能够尝试预测正确的 tokens 。为了解决这个问题，我们选择 mask15% 的 tokens：（如果标记都用[MASK]表示会影响模型，所以在随机mask的时候采用下面的策略。<br><strong>1</strong>.实际上 80% 的 tokens 被替换为 token [MASK].。<br>eg、my dog is hairy → my dog is [MASK]<br><strong>2</strong>.10% 的 token 被替换为随机 token。<br>eg、my dog is hairy → my dog is apple<br><strong>3</strong>.10% 的 token 保持不变。<br>eg、my dog is hairy → my dog is hairy</p>
</blockquote>
<p>训练 BERT 损失函数时，只考虑 mask token 的预测，而忽略非 mask token 的预测。这会导致模型的收敛速度比从左到右或从右到左的模型慢得多</p>
<h2 id="3-3-Next-Sentence-Prediction（一个预训练中的任务）"><a href="#3-3-Next-Sentence-Prediction（一个预训练中的任务）" class="headerlink" title="3.3 Next Sentence Prediction（一个预训练中的任务）"></a>3.3 Next Sentence Prediction（一个预训练中的任务）</h2><p>该任务是指将两个句子作为输入，做一个判断任务，即第二句话是不是第一句话的下一个任务。<br><strong>该任务可以得到句子的向量（句向量）</strong></p>
<p>正如我们前面看到的，BERT 用一个特殊的（SEP）token 来分隔句子。在训练过程中，模型一次输入两个句子:</p>
<p>1.有 50% 的可能性，第二句话在第一句之后。<br>2.有 50% 的可能性，它是一个来自完整语料库的随机句子。</p>
<p>之后 BERT 就要预测第二个句子是否是随机的，并假设这个随机的句子与第一个句子是断开的：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zdGF0aWMwMDEuaW5mb3EuY24vcmVzb3VyY2UvaW1hZ2UvOGEvN2QvOGFmOTgyZmNkN2UzMGJjYWU5MWZmM2JiMzAwODgxN2QucG5n?x-oss-process=image/format,png" alt="在这里插入图片描述"><br>预测第二句与第一句是否是连接的，基本上完整的输入序列经过 Transformer 模型，再用一个简单的分类器层将（CLS）token 的输出转换为 2×1 的向量，并使用 softmax 分配 IsNext-Label。</p>
<p>该模型结合了 Masked LM 神经网络和下一句预测进行训练。这是为了最小化两种策略的组合损失函数——所谓的“合作共赢”。（还未理解）</p>
<h1 id="4-BERT的学习内容"><a href="#4-BERT的学习内容" class="headerlink" title="4. BERT的学习内容"></a>4. BERT的学习内容</h1><p><strong>语义信息</strong>（玄学解释），学习到统计学意义上的信息（个人理解）</p>
<h1 id="5-BERT的优点"><a href="#5-BERT的优点" class="headerlink" title="5.BERT的优点"></a>5.BERT的优点</h1><p>BERT 是一个强大的预训练，因其超大的参数量和较强的特征提取能力，能够从海量的语料中学习到一些语言学和一定程度的语义信息。</p>
<h1 id="6-BERT的应用场景"><a href="#6-BERT的应用场景" class="headerlink" title="6.BERT的应用场景"></a>6.BERT的应用场景</h1><p><strong>BERT</strong> 在<strong>自然语言推理</strong>、<strong>情感分析</strong>、<strong>问题问答</strong>、<strong>意译检测</strong>和<strong>语言可接受性</strong>等一般语言理解的各种任务场景。</p>
<p><strong>eg</strong>、BERT应用在问答场景时：给定一个问题和一个上下文段落，该模型预测该段落中最有可能回答该问题的开始和结束标记。这意味着我们可以使用 BERT 模型通过学习两个额外的向量来训练我们的应用程序，这两个向量分别表示答案的开头和结尾。</p>
]]></content>
  </entry>
  <entry>
    <title>&lt;论文&gt;Exposing Library API Misuses via Mutation Analysis</title>
    <url>/2020/05/28/Exposing%20Library%20API%20Misuses%20via%20Mutation%20Analysis/</url>
    <content><![CDATA[<p>摘要：<br>论文题目：Exposing Library API Misuses via Mutation Analysis<br>论文作者：Ming Wen, Yepang Liu, Rongxin Wu, Xuan Xie, Shing-Chi Cheung and Zhendong Su<br>论文发表：2019 IEEE/ACM 41st International Conference on Software Engineering(ICSE)<br>论文地址：<a href="http://www.cse.ust.hk/~mwenaa/paper/ICSE2019A.pdf" target="_blank" rel="noopener">http://www.cse.ust.hk/~mwenaa/paper/ICSE2019A.pdf</a></p>
<a id="more"></a>
<p>注意：<br><strong>仅作本人参考笔记，机器翻译质量较低。</strong><br>本翻译中的<strong>API滥用</strong>是指<strong>API误用</strong>，比较麻烦就没改。</p>
<h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h1><p>API库的误用会导致软件崩溃以及一些脆弱性问题（鲁棒性较差）。目前存在一些静态分析工具检测误用API问题，通过从正确的API使用样例中挖掘patterns。由于过于简化的假设，即与pattern稍有偏差表示滥用，所以这些系统精度往往较低【6】。</p>
<p>我们对API滥用模式的调查有两个观察结果：<strong>1.API滥用可以表示为相应正确用法的变体；2.可以通过针对测试套件执行突变并分析执行信息来验证突变是否会导致滥用</strong>。基于以上观察，开发了<strong>MUTAPI</strong>，<strong>第一个通过突变分析检测API误用patterns的方法</strong>。为了有效地基于API使用模仿出API误用，我们首先设计八种有效的变异算子，这些变异算子受API滥用的共同特征启发。MUTAPI通过将这些突变运算子应用于一组客户项目来生成突变体，并收集mutant-killing测试以及相关的堆栈跟踪。基于收集得到的信息，从被击杀的mutants中发现误用模式，并根据造成API滥用的可能性对mutants进行排序。我们针对73种流行的Java API在16个客户端项目上应用了MUTAPI。<strong>结果表明，MUTAPI能够以0.78的高精度发现大量的API滥用模式。 它还使MUBENCH基准达到0.49的召回率，优于最新技术。</strong></p>
<p><strong>Index Terms: Mutation Analysis,Library API Misuses</strong></p>
<h1 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h1><p>java项目中第三方库的使用非常常见【1】。Maven仓库中包含8.77milions的第三方库。</p>
<p><strong>问题</strong>：第三方库API的正确使用没有较好的文档规范，或者API更新之后未及时修改。导致API误用普遍存在，最终影响成为软件bug（性能问题，软件崩溃，漏洞问题等等【6-11】）。为了检测API误用，出现一些静态检测工具【12-20】，从软件库中挖掘API使用的pattern。这些pattern被作为API正确使用的样例，而与此类模式的偏差被视为滥用。</p>
<p>由于过于简化的假设，即与pattern稍有偏差表示滥用，所以在实际环境中召回率和准确性较低【6】。一项研究提出解决这两个问题的建议：1.为了提高召回率，现有的检测器需要从更正确的API使用示例中挖掘频繁的模式。但这种情况比较难实现，特别是对于新发型 的API库；2.为了提高精度，探测器需要超越过度简化的假设，即偏离频繁使用模式是一种误用。API的不常见用法不一定是不正确的用法。<strong>更加精确的设计误用检测规则</strong></p>
<p><strong>本篇研究中，我们建议通过突变分析从新的角度解决API滥用模式的发现问题。</strong>突变分析在软件调试和测试中得到了广泛的应用【21】。首先，它通过对具有一组定义明确的变异运算符的程序进行小的修改来创建大量变异，这些变异运算符模仿了各种编程错误。其次，它在突变体上运行给定的测试套件，并收集执行信息以进行各种质量分析[22]-[26]。</p>
<p>我们的解决方法源于两个观察：首先，可以将API的各种误用视为该API正确用法的变体。 因此，可以通过在正确的API用法上应用专门设计的变异运算符来<strong>创建API滥用</strong>。这些突变算子的设计可以通过常见的API滥用模式的特征来指导，这些特征已被现有研究[4]，[6]进行了深入研究。(<strong>自己制作API误用的例子，从这些例子中出发找到API误用的pattern，着手解决</strong>)。例如，一种滥用模式就是缺少异常处理[6]。许多API可能会引发异常，并且这些API的正确用法需要适当的异常处理。 给定此类API的正确用法，我们可以主动违反正确用法（例如，（运算子的工作）通过删除异常处理程序）来创建API误用。可以通过应用某些mutation operators（例如删除方法调用）类似地创建API滥用（例如，缺少方法调用[6]）的模式。 这样，我们可以根据API的正确用法获得大量的突变体。与现有工作[12] – [20]不同，<strong>我们的解决方案不需要从大量正确的API使用中进行模式挖掘。</strong>（<strong>反向操作</strong>）取而代之的是，它积极创建大量模仿API滥用不同模式的突变体。但是，<strong>决定一个这样创建的mutant是否是一个API误用是一个挑战，因为不同的API误用的表现形式是有分歧的</strong>。解决这个挑战的方法是，<strong>通过针对正确用法的测试套件执行突变体并分析执行信息，我们可以验证突变体是否引入了API误用</strong>。此方法受以下启发：对维护良好的项目进行大量测试（42.8％）会在执行期间触发库的使用（第II-C节）。因此，我们推测可以通过运行客户端项目的测试套件来暴露和验证库API的滥用（在第V-A节中确认）。这样，我们的解决方案就不会做出上面的简单假设：与高频率API使用模式不同就是误用。</p>
<p>在本文中，我们提出了MUTAPI，这是一种利用MUTation分析来发现API滥用模式的自动方法。 为了有效地发现API滥用模式，MUTAPI解决了以下三个挑战。</p>
<p>首先，发现API滥用模式需要MUTAPI生成违反现有正确用法的突变体，因此，<strong>如何有效生成模仿API滥用的突变体</strong>是关键。 传统的突变算子，如PIT [27]所定义的算子，不太可能达到这一目标（第V-C节）。 为了解决这一挑战，我们首先研究如何对正确的API用法进行建模，然后系统地打破建模的用法。 受最新研究[4]的启发，MUTAPI根据预先定义的语法将正确的API用法建模为结构化调用序列。 然后，我们<strong>设计了八种类型的新颖变异算子，其目的是以系统的方式主动违反此类修饰用法</strong>（第<strong>III-A</strong>节）。 使用这些突变运算符，MUTAPI通过将其应用于使用目标API的某些客户端项目上来生成大量的突变体。之后MUTAPI将这些突变体针对客户端项目的测试套件运行并收集killing relations（报错原因），其中包括killed mutants和相应的killing tests。 如果突变体的测试输出与原始程序的输出不同，则将其杀死（检测报错）。</p>
<p>其次，<strong>如何验证突变体是否确实引入了API滥用</strong>是另一个挑战。 一种可能的方法是检查突变体是否已被测试套件杀死，但是由于多种原因（例如，与任何API滥用无关的逻辑错误），可以杀死突变体。 如何准确地识别由API滥用引起的那些致命关系是一个关键的挑战。 MUTAPI <strong>通过分析终止测试的失败堆栈跟踪</strong>（表示为终止堆栈跟踪）来解决这一难题。 具体来说，它根据<strong>以下观察结果</strong>，利用终止堆栈跟踪来优先确定终止关系。1. 首先，给出杀死堆栈的跟踪信息，故障的根本原因更接近故障点[28]。 因此，如果终止堆栈跟踪的顶部框架是库函数，则很可能是由API滥用引起的（即，根本原因位于API调用中）。 2.其次，终止目标API的堆栈跟踪应特定于此API。 如果在其他API的突变分析中也观察到杀死堆栈的痕迹，则不太可能由目标API的滥用引起。3. 第三，杀死目标API的堆栈跟踪不应特定于某种用法。 <strong>如果仅在特定项目的突变分析中观察到杀死堆栈的痕迹，则很可能是由该项目特定的错误引起的，而不是普遍滥用目标API</strong>。MutAPI平衡三个观察去区分观察到的Killing relations（错误原因），并假定那些排名靠前的是由滥用目标API引起的。</p>
<p>第三，如何在识别出由于滥用API而导致的一系列杀害关系之后<strong>如何有效地提取API滥用模式</strong>也是一个挑战。 为了应对这一挑战，MUTAPI从大量已确定killing relation的已杀死突变体中提取API滥用。 具体来说，首先根据最近的研究[4]，[6]，<strong>将API滥用建模为一对违规类型和一个API使用要素</strong>。 然后，它<strong>选择那些最常观察到的违规对作为API滥用模式</strong>。</p>
<p>为了评估MUTAPI，我们选择了最近研究[4]，[6]收集的73个流行的Java API，以及从GitHub上的流行存储库收集的16个客户端项目。 评估结果表明，MUTAPI在发现流行API的实际滥用模式方面能够达到0.78的高精度。与最新技术相比，它在基准数据集MUBENCH [6]上具有更高的召回率。</p>
<p>本文贡献如下：</p>
<ul>
<li>独创性：据我们所知，这是第一项将突变分析用于发现API滥用模式的研究，经验证据表明，它在暴露和发现API滥用模式方面是有效的。</li>
<li>实施：我们将方法MUTAPI实施为可检测Java库的API滥用模式的工具，它采用了一组新的变异运算符，已证明在发现不同的API滥用模式方面有效。</li>
<li>评估：我们的评估结果表明，MUTAPI可以发现高精度的流行Java API的实际滥用模式。 与现有方法相比，它还能在基准数据集MUBENCH上检测到更多的滥用实例。</li>
</ul>
<h1 id="2-RELATEDWORK-AND-PRELIMINARIES"><a href="#2-RELATEDWORK-AND-PRELIMINARIES" class="headerlink" title="2. RELATEDWORK AND PRELIMINARIES"></a>2. RELATEDWORK AND PRELIMINARIES</h1><p>在本节中，我们首先介绍有关突变分析和API滥用检测的相关工作。 然后，我们介绍了这项研究的动机及其挑战。</p>
<h2 id="A-Mutation-Analysis"><a href="#A-Mutation-Analysis" class="headerlink" title="A. Mutation Analysis"></a>A. Mutation Analysis</h2><p>给定一个程序P以及一组突变算子O，突变分析的关键思想是生成实质性的突变M，其中每个突变m都是p（正确程序）的变体。 然后生成的突变体将针对p的测试套件T执行。如果存在test t∈T，它针对m和p执行，若结果不同，则该突变体将被杀死（<strong>突变体导致bug</strong>）。变体分析有许多应用（例如[22]，[24] – [26]，[29] – [32]），例如评估测试套件的质量（例如[22]），测试套件的减少（例如 ，[30]），改进故障定位（例如[23]，[26]），安全性分析（例如[24]，[25]），程序修复（例如[31]，[32]）等 。 例如，为了评估测试套件T [22]的质量，通过计算突变得分，M中被杀死的突变体的比例。 突变得分越高，T越有可能检测到真正的错误，因此测试套件的质量也越高。据我们所知，<strong>我们是第一个在发现API滥用模式时应用 突变分析 的方法</strong>。在本研究中，我们使用k表示突变体被test t杀死的关系。通过对所有突变体M进行测试T，我们得到了一组致死关系K。<br><img src="https://img-blog.csdnimg.cn/20200516153208528.png" alt="在这里插入图片描述"></p>
<h2 id="B-Library-API-Misuse-Detection"><a href="#B-Library-API-Misuse-Detection" class="headerlink" title="B. Library API Misuse Detection"></a>B. Library API Misuse Detection</h2><p>库API的使用通常受到诸如呼叫顺序和呼叫条件之类的约束[6]。 不幸的是，API的文档[3]并没有充分说明这些限制。 结果，开发人员还参考非正式参考，例如Stack Overflow，以了解API的用法[33]。 但是，正如最近的一项研究[4]所揭示的那样，即使对于那些较高赞成的答案，Stack Overflow上的代码片段也可能是不可靠的。 违反本应满足的约束条件可能会导致软件错误[6] – [11]（例如，崩溃和安全问题）。因此，它激发了对自动挖掘和检测API滥用的研究的热情[12] – [20]。过于简化的假设，即与pattern（pattern即为从正确的API使用样例中总结的规律）稍有偏差表示滥用。 它们之间的区别主要在于如何编码API用法和模型频率。 例如，<strong>PR-MINER</strong>将API用法编码为在同一方法中调用的一组函数调用，然后利用频繁的项目集挖掘来识别模式，并至少支持15种用法[12]。<strong>JADET</strong>基于方法调用顺序和调用接收者构建有向图[14]。 在图模型中，节点代表方法调用，边代表控制流关系。 <strong>GROUPMINER</strong>创建一个基于图形的对象用法表示形式，以对每种方法的modelAPI用法进行建模。 然后，它利用子图挖掘技术以6的最小支持检测频繁使用的模式[16]。 <strong>DMMC</strong>在由对象触发的一组方法调用中检测丢失的呼叫[7]。 <strong>TIKANGA</strong>构建在JADET之上[20]。 它将呼叫订单的属性扩展到对象用法的通用计算树逻辑公式。 然后，它利用模型检查来识别给定代码库中最小支持20的那些公式。</p>
<h2 id="C-Observation-and-Motivation"><a href="#C-Observation-and-Motivation" class="headerlink" title="C. Observation and Motivation"></a>C. Observation and Motivation</h2><p>在本研究中，我们旨在采用这种哲学来检测API滥用模式，这是程序错误的一种常见类型。该想法受到以下两个观察的启发。</p>
<ul>
<li>various   misuses   of   an   API   can   be   representedas   mutants   of   its   correct   usages.<br><img src="https://img-blog.csdnimg.cn/20200516154804935.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQzMzk2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>a program’s test suite can be leveraged to validate whether a generated mutant of the program indeed misuses an API<br>为了研究利用此观察结果的可行性，我们在GitHub上随机选择了五个受欢迎的项目，并分析了相关测试套件的执行是否会触发受欢迎的API调用。 具体来说，我们选择了一项现有研究收集的100种流行的API [4]。 表I显示了结果。 平均而言，执行42.8％的测试类（即对于不同的项目，范围从32.4％到57.3％）会触发这些API中的至少一个。对于每个测试类，我们进一步研究了这些API的调用次数。 图2显示了结果，表明大量库API由测试执行触发。 此外，这些API中有60.0％会抛出异常，其中超过85.0％是未经检查的异常。<strong>研究结果表明，如果我们通过应用变异算子违反了这些API的正确用法，则很可能会出现代表API滥用的变异 由关联的测试套件以运行时异常的形式检测到</strong>。例如，可以通过抛出NumberFormatException由test NumberUtilsTest.testToFloatStringF（）杀死Mutant＃2。 相应的失败堆栈跟踪如图3b所示。</li>
</ul>
<p>基于以上观察，本研究的动机是在野外对多个开源项目进行突变分析，以发现API滥用模式。<br><img src="https://img-blog.csdnimg.cn/20200516155315386.png" alt="在这里插入图片描述"></p>
<h2 id="D-Challenges"><a href="#D-Challenges" class="headerlink" title="D. Challenges"></a>D. Challenges</h2><p>应用突变分析发现API滥用模式需要解决三个挑战。 首先，如何设计可有效模仿API滥用的诱变运算符仍然未知。 其次，<strong>区分引起API滥用的突变体与不引起突变的突变体很重要</strong>。 如前所述，我们可以利用测试信息来确定突变体是否引入了API滥用。 但是，测试可能由于多种原因而失败。 图1中所示的Mutant＃1示例（不是API滥用）也可以通过具有图3a中所示的堆栈跟踪的test testToFloatStringF（）杀死。<br><img src="https://img-blog.csdnimg.cn/20200516163343315.png" alt="在这里插入图片描述"><br>因此，我们不能简单地通过检查原始程序设计的测试是否消除了变体而引入了API滥用。 从概念上讲，killing relations可以由三种原因引起。第一类驻留在库中（类型1），该类表明测试由于API的错误实现而失败。 另外两种类型的原因驻留在客户端项目中，这表明在应用了变异运算符后，客户端程序是“笨拙的”。 其中，一种“错误”是由于滥用API（类型2）引起的，而另一种原因不是（类型3）错误。有用的API滥用模式只能从类型2“错误”中获取（例如，图1中的Mutant＃2），而从类型3“错误”中获取的模式（例如，图1中的Mutant＃1）将导致错误肯定。 辨别killing relations的根本原因是具有挑战性的。 第三，即使我们能够成功地识别出一系列引入API滥用的突变体，将这些突变体推广到API滥用模式也不是一件容易的事。<br><img src="https://img-blog.csdnimg.cn/20200516163631134.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQzMzk2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h1 id="3-MUTAPI-APPROACH"><a href="#3-MUTAPI-APPROACH" class="headerlink" title="3. MUTAPI APPROACH"></a>3. MUTAPI APPROACH</h1><p>本节介绍了我们的方法，其概述如图4所示。MUTAPI的输入是一组客户端项目（即，包括源代码和相关的测试套件）和一组目标API。 分析过程包括三个主要步骤。 首先，MUTAPI通过在客户端项目中对targetAPI的用法应用一组预定义的突变运算符来生成突变，然后运行测试。其次，它收集终止关系并针对每个目标API优先考虑这些关系。第三，它从相关的被杀死的突变体中选择排名最高的杀死关系并挖掘API滥用模式。 MUTAPIisa的输出列出了目标API的滥用情况。 以下小节介绍了每个步骤的详细信息。 为了简化表述，表II总结了本研究中使用的符号。</p>
<h2 id="A、Conducting-Mutation-Testing"><a href="#A、Conducting-Mutation-Testing" class="headerlink" title="A、Conducting Mutation Testing"></a>A、Conducting Mutation Testing</h2><p>为了应用突变分析来发现API滥用模式，需要一套可以系统地违反正确API使用方法的变异算子。 传统的诱变算子（例如，在PIT [27]中定义的算子）不太可能实现该目标。 例如，一种主要类型的API滥用导致缺少控制语句[4]，[6]，例如，缺少异常处理或检查语句。常规运算符的重点是对条件数学运算符进行变异[27]，不旨在操纵此类控制语句。因此，它们不能有效地模仿这种误用模式。<br><img src="https://img-blog.csdnimg.cn/20200516164219236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQzMzk2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>根据最近的一项研究[4]，MUTAPI将正确的API使用建模为结构化的调用序列，以有效地模仿各种类型的API滥用。 这种结构化的调用序列可以抽象化语法细节（例如变量名），而以紧凑的方式保留API调用的时间顺序，控制结构和检查器[4]。我们采用研究[4]定义的语法来表示结构化的调用序列，如表III所示。 一个结构化的调用序列由几个API调用组成，每个API调用都可以由结构语句（例如，try-catch）或由检查器语句（例如，空指针检查器）保护。 通过考虑参数及其类型来区分重载的API调用。 图5显示了Iterator类的用法。 假设我们的目标API（即atarget）是第5行中的Iterator &lt;&gt;.next（）。为了对目标的使用进行建模，MUTAPI首先确定在其上调用目标的对象（例如迭代器），然后在相同方法中标识该对象调用的其他API。 在本示例中，在模型序列中将包含第4行触发的APIIterator &lt;&gt;.hasNext（）。MUTAPI进行程序切片[35]（向后和向前）以根据其API调用的每个调用提取这些结构和检查器语句 接收器变量v_rev（例如，value是第5行的接收器变量）和参数v_i。结果，第7行的语句也将包含在建模序列中。 请注意，MUTAPI只标识那些直接依赖于API调用中涉及的变量的语句，因为根据现有工作，这种设置能够在为误用检测使用的API使用建模中获得最佳性能[4]。 结果，第9行的ifchecker将不会被切片为结构化序列，因为被检查的变量结果并不直接取决于我们目标API的接收者变量值。因此，图5中API使用的建模结构化序列为“ if（hasNext（））{; r_rev = next（）;}; if（r rev）{};”。 分隔符“；” 这是语法中的分隔符，与Java中使用的分号不同。</p>
<p>基于对a_target正确使用的建模结构化序列，MUTAPI试图通过系统地应用变异算子来模拟各种API滥用打破这种用法。具体来说，我们按照API滥用模式[4]，[6]的共同特征设计了八种类型的突变算子，如表IV所示。对于API调用顺序不正确的情况[4]，MUTAPI会交换两个调用序列的顺序（ 类型1），删除API调用（类型2）并插入新的API调用（类型3）。 对于缺少checkers [6]的情况，MUTAPI将删除一个checker（类型4）。 对于缺少控制结构[4]，[6]的情况，MUTAPI删除结构但保留enclosingAPI调用（类型5）或将结构与封闭的API调用一起删除（类型6）。对于缺少正确条件[4]，[6]的情况，在检查器或无状态语句中，MUTAPI会用其他条件表达式或布尔值（类型7）随机替换条件表达式。MUTAPI还会更改API调用的参数（类型8）。 用其他兼容变量（Type8.1）替换API调用的参数，插入参数（Type8.2）或deletesan参数（Type8.3），以将原始方法调用更改为重载方法的调用。</p>
<p>MUTAPI采用一种进化过程来随机生成突变体，如算法1所述。具体地说，它最多将Nmutation运算符应用于原始程序以生成突变体。 某些运算符（例如，用另一种替换一种条件）需要必要的代码成分。 在这种情况下，MUTAPI从原始程序中搜索以随机选择适当的代码元素。 默认情况下，N设置为1，第VI-A节讨论Nis的影响。<br><img src="https://img-blog.csdnimg.cn/20200516164753820.png" alt="在这里插入图片描述"></p>
<h2 id="B、Prioritizing-Killing-Relations"><a href="#B、Prioritizing-Killing-Relations" class="headerlink" title="B、Prioritizing Killing Relations"></a>B、Prioritizing Killing Relations</h2><p><img src="https://img-blog.csdnimg.cn/20200516164808300.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQzMzk2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200516165157336.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQzMzk2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>在对所有变体M执行测试套件后，MUTAPI会收集大量的终止关系K。 具体来说，<strong>如果客户端程序p的一个API a相关的变体m被p的测试用例t杀死之后，就收集到了一种killing关系k。特别是，k也表示为k &lt;p，a，m，t&gt;</strong>。 如第II-D节所述，<strong>存在多种导致杀伤关系的诱导因素，并确定是否因为由滥用靶标API a_target引起的测试用例错误具有挑战性</strong>。为了解决此问题，MUTAPI利用终止堆栈跟踪来优先考虑由API滥用引起的终止关系。 例如，图3分别显示了图1中所示的两个突变体的两个杀死堆栈轨迹的前10个框架。其中一个是由API误用导致的（例如，缺少异常处理），而且由于java.lang. numberformatexception而失败。另一个是由与API误用无关的一般错误引起的，并且由于java.lang.AssertionError导致的bug。MUTAPI可以将那些由于API滥用而导致的杀戮堆栈跟踪与那些不是通过基于堆栈跟踪进行优先级排序的堆栈跟踪区别开来</p>
<p><strong>优先级排序</strong>基于对从多个客户端项目P中收集到的大量杀害堆栈跟踪的分析. 为了启用此类跨项目分析，MUTAPI预处理这些堆栈跟踪以删除与客户端项目相关的框架（例如，图3b中的第4帧）或JUnit框架（例如，框架 图3a）中的图1所示，<strong>因为这些帧不太可能表征由于滥用库API而引起的堆栈跟踪的模式</strong>。 结果，仅保留那些在图3中以蓝色背景显示的帧以供进一步分析。失败的标记（例如java.lang.AssertionErrororjava.lang.NumberFormatException）对于理解失败原因也很重要。 因此，我们还将此类信息保留在已处理的堆栈跟踪中。 但是，特定于项目的信息（例如，堆栈跟踪＃1中的toFloat（）或堆栈跟踪＃2中的输入字符串：“ a”）已被滤除。 如果两个killing堆栈跟踪的失败签名和已处理的框架相同，则视为相同。</p>
<p><strong>在对每个终止堆栈跟踪进行预处理之后，MUTAPI获得一组唯一的跟踪S。MUTAPI将终止堆栈跟踪相同的终止关系分组</strong>。 对于a_target，MUTAP会根据以下见解，通过优先级确定在S中由目标滥用（表示为目标API滥用引起的杀死堆栈跟踪）引起的那些杀死堆栈跟踪。<br><img src="https://img-blog.csdnimg.cn/20200516170157721.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQzMzk2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><strong>目标API滥用引起的杀死堆栈跟踪不应特定于某种用法。</strong>如果确实是由于滥用$a_{target}$引起的killing堆栈路径，则应在跨不同项目的多种$a_{target}$多次使用的突变分析中观察到它。否则，这样的堆栈跟踪很可能是由特定项目特定用途的API使用的错误引起的，而不是因为$a_{target}$的误用。因此，MUTAPI测量其突变分析已观察到终止堆栈跟踪s的使用比率，以确定s是否由$a_{target}$误用引起，如下所示：<br><img src="https://img-blog.csdnimg.cn/20200516170059680.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200516170117164.png" alt="在这里插入图片描述"><br><strong>目标API滥用引起的终止堆栈跟踪应特定于此API。</strong>如果由于滥用目标API导致了杀死堆栈，则不应在其他API的变异分析中观察到它。 否则，这样的堆栈跟踪不太可能由目标API的滥用引起，因为它对于多个不同的API是通用的。 因此，MUTAPI测量s的倒数频率，它是在$a_{target}$突变分析中观察到的s数与所有目标API  A之比，如下所示：<br><img src="https://img-blog.csdnimg.cn/2020051617044054.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200516170453671.png" alt="在这里插入图片描述"><br><strong>目标API滥用引起的killingstack跟踪的顶部框架应该是目标库的功能。</strong>现有研究表明，在堆栈跟踪中，根本原因所在的功能似乎更接近故障点[28]。 图3a中显示的堆栈跟踪＃2的顶部框架是来自包含目标APIjava.lang.Float.parseFloat的库中的函数。 但是，堆栈跟踪＃1的顶部框架是那些与JUnit框架相关的功能。 在这里，我们检查原始堆栈轨迹而不是处理堆栈轨迹，以调查故障时每帧的位置。 因此，杀死API 2.lang.Float.parseFloat可能导致杀死堆栈跟踪2。受这些观察的启发，对于给定的堆栈跟踪，我们建议使用目标库中那些框架的等级来近似估计由于滥用​​库API而引起的可能性。<br><img src="https://img-blog.csdnimg.cn/20200516170915914.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200516170931365.png" alt="在这里插入图片描述"><br>MUTAPI通过为每个堆栈跟踪计算以下分数，相对于目标API atarget对所有唯一堆栈跟踪S进行优先级排序。<br><img src="https://img-blog.csdnimg.cn/20200516171135715.png" alt="在这里插入图片描述"></p>
<h2 id="C、Discovering-API-Misuse-Patterns"><a href="#C、Discovering-API-Misuse-Patterns" class="headerlink" title="C、Discovering API Misuse Patterns"></a>C、Discovering API Misuse Patterns</h2><p>对于S中的每个唯一的终止堆栈跟踪s，MUTAPI将相对于$a_{target}$分配其分数。MUTAPI重新检索所有终止堆栈跟踪相同的终止关系。 让K_s表示这样的一组杀死关系，其中K_s = {k |k∈K，s_k = s}。MUTAPI从那些与K_s相关的死亡突变体M_s中提取API滥用模式。为了有效地提取API滥用，MUTAPI在最近的工作[6]之后将API滥用建模为违规对，p = &lt;违规类型，API用法元素&gt;。 具体来说，<strong>根据现有研究，共有三种违规类型：缺失，冗余和不正确</strong>[4]，[6]。 API使用元素可以引用方法调用，空检查器，条件，异常处理，迭代，参数等[4]，[6]。 具体而言，MUTAPI利用以下规则通过研究所应用的突变算子从突变体中提取违规对。<strong>MUTAPI从由突变运算符＃3，＃4，＃5，＃6和＃8.3创建的突变体中提取类型缺失的违规对，因为它们删除了代码元素； 从突变运算符＃2和＃8.2创建的突变体中提取类型冗余的违规对，因为它们添加了代码元素； 突变运算符＃1，＃7和＃8.1提取了类型错误和违规对，因为它们将现有的代码元素替换为其他代码元素。</strong>对于API用法元素，MUTAPI通过分析已突变的代码元素来将其提取。 例如，图1所示的第二个突变体是通过应用突变运算符＃5生成的。 因此，违反类型丢失。 发生突变的代码元素为 try-catch statement。 结果，提炼的违规对是<strong>&lt;missing，exception handling&gt;</strong> 。</p>
<p>可以基于这些突变M_s来提取多个违规对。 因此，MUTAPI会根据它们的频率进一步确定它们的优先级。 具体而言，MUTAPI基于M_s标识一组唯一的P_M_s对，它记录在P_M_s中的每个v_p的出现次数（即，记为count（vp））。 然后，MUTAPI根据违规配对在所有对中的出现情况排列优先顺序:<br><img src="https://img-blog.csdnimg.cn/20200516171933368.png" alt="在这里插入图片描述"><br>其中得分用于衡量a_target滥用所导致的，具有相同堆栈跟踪的那些杀死关系Ks的可能性，而ratio（vp）衡量从与K_s相关的被杀突变体中提取的所有违规对中，违规对vp的出现频率。</p>
<h1 id="4-EXPERIMENT-SETUP"><a href="#4-EXPERIMENT-SETUP" class="headerlink" title="4.EXPERIMENT SETUP"></a>4.EXPERIMENT SETUP</h1><p>本节介绍了我们的实验设置和要研究的研究问题。</p>
<h2 id="A、Target-APIs-Selection"><a href="#A、Target-APIs-Selection" class="headerlink" title="A、Target APIs Selection"></a>A、Target APIs Selection</h2><p><strong>为了评估MUTAPI的有效性</strong>，我们选择了最近的一项研究[4]收集的73种流行的Java API。 其中有43个是堆栈溢出中讨论最频繁的API（例如Iterator &lt;&gt;。next（））。 这些API通常在实践中使用，并且开发人员经常因其用法而感到困惑。 其余30个API来自MUBENCH [6]，这是API滥用的基准数据集。 这些API位于不同的领域，其中大多数来自四类：通用库（例如，数学，集合，时间，xml），GUI（例如，Swing），安全性（例如，java.security.Cipher（））和 数据库。</p>
<h2 id="B、Client-Projects-Selection"><a href="#B、Client-Projects-Selection" class="headerlink" title="B、Client Projects Selection"></a>B、Client Projects Selection</h2><p>为了发现API滥用模式，MUTAPI需要一组客户端项目来执行突变分析。 在本研究中，我们从四个不同的类别中选择了16个开源Java项目，如表V所示。<strong>这些项目是从GitHub中随机选择的，它们满足以下两个条件</strong>。 首先，它涵盖的唯一目标API的数量应大于15。由于MUTAPI旨在检测与所选目标API有关的滥用，因此所选客户端项目应包含尽可能多的这些API用法。 很难找到触发所有73个目标API的客户端项目，因为这些API来自不同的领域。因此，我们将合理的阈值设置为15。我们的第二个标准是，客户项目的突变覆盖率（使用PIT [27]测量）应大于0.70。我们设置此阈值以确保测试套件的质量[39]，因为MUTAPI依赖于 相关的测试套件，以验证突变体是否引入了API滥用。 我们将在第六节中进一步讨论测试套件质量对MUTAPI性能的影响。 根据这两个条件，我们从通常来自73个API的四个类别的领域（即GUI，库，安全性和数据库）中随机选择了四个Java项目。客户项目的分类基于Apache官方定义[40]和GitHub主题[41]。 总共选择的16个项目涵盖了选择的73个API中的55个不同的API。 其余18个API并未涵盖，因为它们很少被大型且受欢迎的项目使用（例如，jsoup.Jsoup.connect（））。<br><img src="https://img-blog.csdnimg.cn/20200516172441258.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQzMzk2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="C、Research-Questions"><a href="#C、Research-Questions" class="headerlink" title="C、Research Questions"></a>C、Research Questions</h2><p>我们研究三个研究问题以评估MUTAPI：</p>
<ul>
<li>RQ1：MUTAPI可以发现API滥用模式吗？ 它可以更容易地发现哪些滥用模式？<br>MUTAPI生成API滥用模式的排名列表。在RQ1中，我们调查了MUTAPI检测到的那些排名最高的API滥用模式是否为真阳性。 具体来说，我们使用metricPrecision @ N来评估MUTAPI的性能。Precision@ ​​N会报告MUTAPI所报告的topNAPI滥用模式（N = 1、5、10，…）中真实阳性的百分比。 为了判断检测到的滥用模式是否为真正的阳性，我们遵循现有研究采用的策略[4]。 具体来说，我们根据在线文档（即是否已在线记录滥用情况）和现有文献（例如，现有研究是否已报告滥用方式）进行了人工检查。 然后，通过检查相关的Java文档，调查MUTAPI已检测到滥用模式的API的特性。</li>
<li>RQ2：MUTAPI是否可以检测最新基准数据集MUBENCH上的API滥用实例？<br>根据发现的滥用模式（即违规对），MUTAPI能够检测到滥用实例。 具体来说，MUTAPI应用与第III-A节所述相同的分析，以结构化API调用序列的形式对API的使用进行建模。 然后，它检查建模序列是否违反了已确认的滥用模式。 我们将MU-TAPI应用于MUBENCH [6]，以查看它是否可以检测基准数据集中的API滥用。 具体来说，我们调查了MUTAPI的调用，即MUTAPI可以在MUBENCHwork [6]中的实验R中使用的53个真实实例中检测到的API滥用比率。 我们在实验R中选择了这些滥用行为，因为它们都是从开源项目中发现的真正的滥用行为实例。 为了与现有方法进行比较，我们选择了四个基线（即JADET [14]，GROUPMINER [16]，DMMC [7]和TIKANGA [20]），这些基线已通过现有研究进行了系统评估[6]。</li>
<li>RQ3:与传统的变异算子相比，我们提出的变异算子在检测API滥用模式方面表现如何？<br>在这项工作中，我们提出了针对API滥用检测的八种类型的突变算子，这些突变算子在突变分析中被MUTAPI所采用。 在这个研究问题中，我们使用两个指标将建议的突变算子与PIT [27]中使用的传统算子进行比较：（1）效率（即，突变分析所需的时间）和（2）有效性（即，API的数量） 检测到滥用模式）。<br><img src="https://img-blog.csdnimg.cn/20200516172943966.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQzMzk2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
<h1 id="5-EXPERIMENTAL-RESULTS"><a href="#5-EXPERIMENTAL-RESULTS" class="headerlink" title="5. EXPERIMENTAL RESULTS"></a>5. EXPERIMENTAL RESULTS</h1><h2 id="A、RQ1-Effectiveness-of-MUTAPI"><a href="#A、RQ1-Effectiveness-of-MUTAPI" class="headerlink" title="A、RQ1:Effectiveness of MUTAPI"></a>A、RQ1:Effectiveness of MUTAPI</h2><p>我们将MUTAPI应用于所有客户端项目，以发现所选目标API的滥用模式。 MUTAPI生成了大量的突变体，并收集了与相关的杀灭堆栈痕迹有关的大量杀灭关系。 表VI显示了统计信息。具体而言，MUTAPI生成了3266个突变体，并且每个客户项目收集了13465个终止关系。 在处理终止堆栈跟踪（即删除客户端项目框架）之后，它为每个客户端项目获得了65个唯一的堆栈跟踪。 然后，MUTAPI分析了不同客户项目之间的致命关系，并提炼了大约300种API滥用模式（即违规对）。 我们按照第IV-C节中所述的程序手动检查了前50个模式。 图6显示了Precision @ N的结果。 结果表明，MUTAPI在前十名候选对象中实现了0.90的高精度。 在前50位中，精度略降至0.78。 表VII列出了一些被选为排名最高的违规对，它们是真正的API滥用模式，涵盖了以下几种类型：缺少检查程序，缺少调用，缺少异常，错误条件和冗余调用。 这些结果表明，MUTAPI可以高精度地发现实际的API滥用模式。</p>
<p>在检测到的模式中，APILine.intersection（）的接收器上缺少必需的checkerif（rev == null）排在第一位。 对于此API在代码库中的两种正确用法，其中之一如图7所示，由MUTAPI生成的突变体（即删除检查程序）被关联的测试套件使用NullPointerException杀死。杀死堆栈跟踪是此API唯一的（即，倒数频率很高），其顶部帧是来自目标库的方法调用（即，可能性很高）。此外，在突变分析中对于两种正确用法（即，频率很高）都观察到了杀伤堆栈痕迹。 结果，错过检查器被认为是滥用Line.intersection（）的可能性很高。 现有文献已经证实了这种滥用[6]。 图8显示了另一个示例，该示例显示了APIIterator &lt;&gt;。next（）的正确用法，以及删除包含API callIterator &lt;&gt;。hasNext（）的结构后相关的终止堆栈跟踪。 在对不同客户项目（例如，jfreechart，commons-bcelandcommons-math）的多种正确用法进行突变分析时，观察到了这种杀戮堆栈痕迹。</p>
<p>我们进一步调查了MUTAPI发现其滥用模式的API文档，以了解它们是否具有相似的特征。 我们发现其中的78.9％将抛出未经检查的异常。 图9显示了这些未经检查的异常的分布。 请注意，所有异常的分布总和大于1，因为API可能会抛出多种类型的异常。 以上结果表明，MUTAPI在检测那些会引发未经检查的异常的API的滥用方面更有效，这是因为代表此类滥用的那些突变体更有可能以运行时异常的形式被杀死（即，杀死它们不需要强大的测试Oracle）。 还有其他类型的API，其MUTAPI不太可能检测到误用（请参阅第VI-B节）。</p>
<h2 id="B、RQ2-Performance-of-MUTAPI-on-MUBENCH-Benchmark"><a href="#B、RQ2-Performance-of-MUTAPI-on-MUBENCH-Benchmark" class="headerlink" title="B、RQ2:Performance of MUTAPI on MUBENCH Benchmark"></a>B、RQ2:Performance of MUTAPI on MUBENCH Benchmark</h2><p>图10显示了MUTAPI的召回以及MUBENCH基准的基准。 基线结果直接从先前的研究中提取[6]。 请注意，基线方法有两个实验设置。 一个实用的设置，不包含任何手工制作的API用法（在图10中表示为Recall＃Practical）。 其他设置涉及手工制作的API正确用法（在图10中表示为Recall＃Crafted）。<br><img src="https://img-blog.csdnimg.cn/20200516173551892.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQzMzk2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>现有研究[6]中详细解释了这两种设置，我们在此研究中不做进一步解释。 MUTAPI未在人工设置下进行评估，因为人工API使用示例未配备突变分析所需的测试套件。</p>
<p>如图10所示，MUTAPI能够检测出53种实际API滥用中的26种。 它实现了0.49的最高召回率。 在实际设置中，MUTAPI的性能明显优于所有基线方法。 第二好的方法是DMMC，其召回率为0.21。GROUPMINER无法检测基准测试中的任何API滥用。 限制现有方法检测更多API滥用的主要原因之一是，代码库中的用法示例数量太少（低于现有模式挖掘方法所需的最小支持值）。 例如，GROUPMINER [16]检测到最小支持为6的频繁使用模式，而TIKANGA [14]将最小支持设置为20。这意味着它们在代码库中至少需要6或20个使用示例。 在精心设置的环境中，由于已手动将更多正确的用法示例添加到了代码库中，因此，对现有方法的调用也得到了相应的改善。 尽管如此，在实际设置下获得的MUTAPI的结果仍胜过在这种精心设置的设置下所有基线方法。</p>
<p>我们进一步调查了MUTAPI无法检测到某些模式的API滥用实例的原因，并发现了三种主要类型的原因：没有正确使用API​​，没有突变体覆盖和测试套件不足（请参阅第VI-B节）。 我们计划将来在MUBENCH之外的更多数据集上评估MUTAPI [6]，因为此处结果有效性的一个威胁是突变算子的设计部分受此基准研究的启发。</p>
<h2 id="C、RQ3-Efficiency-and-Effectiveness-of-Mutation-Operators"><a href="#C、RQ3-Efficiency-and-Effectiveness-of-Mutation-Operators" class="headerlink" title="C、RQ3:Efficiency and Effectiveness of Mutation Operators"></a>C、RQ3:Efficiency and Effectiveness of Mutation Operators</h2><p>表VI分别在#Mutants和#PitMutants列中显示了由MU-TAPI和PIT产生的突变体的数量。 请注意，在使用PIT生成变体时，我们仅针对那些涉及选定目标API用法的源文件。<br><img src="https://img-blog.csdnimg.cn/20200516173622429.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQzMzk2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>如表所示，平均而言，PIT产生的突变体是MUTAPI的2.39倍。 突变分析在计算上是昂贵的，因为它需要编译突变体并根据相关测试套件执行它们[58]，[59]。 结果，MUTAPI平均需要9.87分钟才能完成每个项目的分析，而传统突变算子则需要20.93分钟。<br><img src="https://img-blog.csdnimg.cn/20200516173941817.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQzMzk2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>我们将由PIT产生的突变体以及与其相关的杀伤关系喂给MUTAPI。 我们按照RQ1中采用的相同程序，手动检查了排名前50位的结果。 图11显示了PIT检测到的实际API滥用模式（即真实肯定）的数量。 总体而言，PIT仅能检测到5种条件不正确且呼叫遗漏的真阳性。 这是因为传统的变异运算符集中于变异算术运算符和条件运算符[27]，这大多会导致所有客户项目普遍存在断言错误。 因此，很难利用它们来提炼实际的API滥用。 传统的突变运算符还可以突变条件（例如，将条件强制设置为假或假）并删除无效方法调用。 这就解释了为什么PIT发现5种真正的API滥用。</p>
<p>这些结果表明，我们提出的突变算子在发现API滥用模式方面比传统方法更有效，这反映了需要为Discovertof API滥用模式提出特定于域的突变算子。 图11还显示了MUTAPI检测到的不同类型的滥用模式的分布。 它表示缺少检查程序，缺少异常和调用丢失是最常见的检查器。 这与现有研究的结果一致[4]，[6]。</p>
<h1 id="6、DISCUSSIONS"><a href="#6、DISCUSSIONS" class="headerlink" title="6、DISCUSSIONS"></a>6、DISCUSSIONS</h1><h2 id="A、Effects-of-the-Number-of-Applied-Mutation-Operators"><a href="#A、Effects-of-the-Number-of-Applied-Mutation-Operators" class="headerlink" title="A、Effects of the Number of Applied Mutation Operators"></a>A、Effects of the Number of Applied Mutation Operators</h2><p>MUTAPI可以在生成突变体时应用Nmutation运算符（请参见算法1）。 默认情况下，Nis设置为1。 突变操纵子最大数目的影响能否应用于MUTAPI的有效性尚不清楚。 我们将在本小节中研究此类影响。<br><img src="https://img-blog.csdnimg.cn/20200516174130354.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQzMzk2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>图12显示了当Nis设置为1到5时产生的突变体的数量。我们可以看到，随着N的增加，产生的突变体的数量显着增加。 因此，进行突变分析变得更加昂贵。但是，我们观察到，唯一的故障堆栈迹线的数量随Ngrows的增加而略有增加。 例如，当N = 1时，唯一堆栈跟踪的总数为543。 当N = 2时，该数目仅增加5，而对于16个客户项目，其突变总数总共增加20,501。这表明应用单个突变算子足以发现大多数错误空间（即，以失败的堆栈跟踪形式）以暴露 库滥用。</p>
<h2 id="B、Limitations-of-MUTAPI"><a href="#B、Limitations-of-MUTAPI" class="headerlink" title="B、Limitations of MUTAPI"></a>B、Limitations of MUTAPI</h2><p>阻碍MUTAPI发现目标API滥用模式的三个主要原因。</p>
<p><strong>没有正确的用法</strong>。 如果输入客户端项目中没有正确使用目标API，则MUTAPI无法通过突变分析发现相应的滥用。 例如，在我们的实验中，我们发现所有16个客户端项目中都没有APIorg.kohsuke.args4j.api.Parameters.getParameter（）的正确用法。 为了保证我们的结果和发现的通用性，我们没有选择使用该API正确用法的其他项目。因此，MUTAPI并未发现此API的任何滥用模式。 如前所述，现有方法也受到此限制的影响，更糟糕的是，与我们的方法相比，它们需要更多的正确用法。</p>
<p><strong>没有突变体覆盖</strong>。 我们观察到某些API滥用模式需要使用我们的方法无法发现的特定值。 例如，javax.crypto.Cipher（“ DES”）被滥用，因为它不应与DES模式一起使用[60]。 但是，MUTAPI仅在替换参数或条件时从同一源文件中搜索，以便找到适当的代码元素。 结果，如果在同一源文件中没有字符串“ DES”，则MUTAPI无法创建代表此API滥用的变量。 对于其他API，例如String.getBytes（），也观察到类似情况。</p>
<p><strong>测试套件不足</strong>。 MUTAPI的有效性取决于相关测试套件的质量。 即使MU-TAPI生成了代表真实API滥用的突变体，但如果关联的测试套件无法杀死该突变体，它仍然没有机会检测到滥用。 例如，对于MUBENCH中API StatisticalCategoryDataset.getDtDevValue（）的滥用，MUTAPI成功创建了一个模仿滥用的变量。 不幸的是，它不能被相关的测试套件杀死。 结果，不能检测到滥用模式。 对于其他与I / O相关的API，例如InputStream（）或File.open（），缺少的方法callFile.close（）是常见的滥用类型。<br><img src="https://img-blog.csdnimg.cn/20200516174351382.png" alt="在这里插入图片描述"><br>但是，代表这种滥用的突变体几乎不能被测试套件杀死。 原因是这种滥用很可能导致性能问题。 客户项目的测试用例很少配备适当的oracle来识别此类问题。 但是，我们的经验结果（第V-A节）已经确认，可以通过突变分析检测到大量真实的API滥用模式。</p>
<h2 id="C、Threats-to-Validity"><a href="#C、Threats-to-Validity" class="headerlink" title="C、Threats to Validity"></a>C、Threats to Validity</h2><p>本研究的有效性受到以下威胁的影响：首先，我们的研究仅限于73个Java API，因此对其他API的通用性可能会构成威胁。 然而，这些API很流行（即在Stack Overflow [4]中经常讨论），并通过现有研究对其进行系统地评估[6]。 因此，我们认为它们是代表性的Java API。 第二，我们的实验仅涉及16个客户项目，因此结果可能无法推广到其他项目。但是，这些项目是根据IV-B部分所述的标准随机选择的。 它们是流行的且来自不同领域。 还值得一提的是，这些项目仅涵盖了73个所选API中的55个。 为了确保我们实验的普遍性，我们没有故意选择更多项目来覆盖其余18个API。</p>
<h1 id="7、CONCLUSION-AND-FUTURE-WORK"><a href="#7、CONCLUSION-AND-FUTURE-WORK" class="headerlink" title="7、CONCLUSION AND FUTURE WORK"></a>7、CONCLUSION AND FUTURE WORK</h1><p>我们在这项研究中提出了MUTAPI，这是利用突变分析发现API滥用模式的第一种方法。 与现有方法相比，它提供了两个主要好处。首先，它不需要大量正确的API使用示例。 因此，它可以用于检测新发布的API的滥用模式，这些使用模式可能受到限制，而现有方法在这种情况下不太可能起作用。 其次，它超越了简单的假设，即偏离最常见的模式是一种滥用。由于这种假设，现有方法的精度较低。 我们针对73个流行的API在16个客户端项目上应用了MUTAPI。 结果表明，MUTAPI可检测大量的API滥用模式。 它还在MUBENCH基准数据集[6]上实现了0.49的调用率，大大优于现有方法。</p>
<p>将来，我们计划将MUTAPI应用于不那么常用的API（例如，来自新发布的库的API），而不是流行的API，以调查MUTAPI是否可以检测未知的API滥用模式。 我们还计划系统地研究测试套件质量对我们方法有效性的影响。</p>
]]></content>
      <tags>
        <tag>论文</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/04/27/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<a id="more"></a>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
      <categories>
        <category>Testing</category>
      </categories>
      <tags>
        <tag>TestingTag</tag>
      </tags>
  </entry>
  <entry>
    <title>&lt;论文&gt;Progressive Self-Supervised Attention Learning forAspect-Level Sentiment Analysis</title>
    <url>/2020/04/30/Progressive%20Self-Supervised%20Attention%20Learning%20forAspect-Level%20Sentiment%20Analysis%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/</url>
    <content><![CDATA[<p>摘要：Progressive Self-Supervised Attention Learning forAspect-Level Sentiment Analysis翻译及理解</p>
<a id="more"></a>

<h1 id="Progressive-Self-Supervised-Attention-Learning-forAspect-Level-Sentiment-Analysis翻译及理解"><a href="#Progressive-Self-Supervised-Attention-Learning-forAspect-Level-Sentiment-Analysis翻译及理解" class="headerlink" title="Progressive Self-Supervised Attention Learning forAspect-Level Sentiment Analysis翻译及理解"></a>Progressive Self-Supervised Attention Learning forAspect-Level Sentiment Analysis翻译及理解</h1><p>1.本文针对神经网络在学习过程中存在的强模式过学习和弱模式欠学习的问题，提出了渐进自监督注意力机制算法，有效缓解了上述问题。主要基于擦除的思想，使得模型能够渐进的挖掘文本中需要关注的信息，并平衡强模式和弱模式的学习程度。在基于方面层次的情感分析三个公开数据集和两个经典的基础模型上测试表明，所提出的方法取得了不错的性能表现。<br>2.在方面层次的情感分类任务中，经典方法为使用注意力机制来捕获上下文文本中与给定方面最为相关的信息。然而，注意力机制容易过多的关注数据中少部分有强烈情感极性的高频词汇，而忽略那些频率较低的词。</p>
<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>在方面级别的情感分类（ASC）中，普遍的做法是为优势神经模型配备注意机制，以便获得给定方面每个上下文词的重要性。 但是，这种机制倾向于过分关注少数带有情感极性的频繁单词，而忽略了很少出现的单词。 本文提出了一种针对神经ASC模型的渐进式自我监督注意学习方法，该方法会自动从训练语料库中挖掘有用的注意监督信息，以细化注意机制。特别是，我们对所有训练实例进行<strong>迭代的情感预测</strong>。 <strong>将具有最大注意力权重的上下文单词提取为对每个实例的正确/不正确预测具有积极/误导性影响的上下文单词</strong>，然后将该单词本身屏蔽起来以进行后续迭代。 最后，用<strong>正则化项</strong>削弱了常规训练目标，这使ASC模型可以继续将注意力集中在提取的活动上下文词上，同时减少那些误导对象的权重。对多个数据集的实验结果表明，我们提出的方法产生了更好的注意力机制，从而导致了对两种状态的重大改进 最先进的神经ASC模型。 源代码和经过训练的模型可从<a href="https://github.com/DeepLearnXMU" target="_blank" rel="noopener">https://github.com/DeepLearnXMU/PSSAttention</a>获得。</p>
<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h2><p>基于方面的情感分析在该领域中是一项单独的任务，旨在推断出输内容在某一方面的情感极性。</p>
<p>目前该工作的处理模型：占主导地位的ASC模型已发展为基于神经网络（NN）的模型，它可以自动的学习输入内容的情感关系，表现良好。attention机制在该任务中也有着重要的作用。</p>
<p><strong>现存的基于attention的ASC模型有一个重大的缺陷</strong>：这种机制倾向于过分关注少数带有情感极性的频繁单词，而忽略了很少出现的单词。</p>
<p>两个模式：“apparent patterns” and “inap-parent patterns”<br>其中，“明显模式”被解释为带有强烈情绪极性的高频词汇，而“不明显模式”则被解释为训练数据中的低频词汇，神经网络通常会对显示模式的词语过度学习，针对不明显的词语忽视掉。<br><strong>一个反面例子</strong>：<br><img src="https://img-blog.csdnimg.cn/20191222135819263.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQzMzk2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>在前三个训练句中，由于语境词“小”经常与消极情绪一起出现，注意机制对其给予了更多的关注，并将包含“小”情绪的句子与消极情绪直接联系起来。这就不可避免地导致了另一个信息上下文单词“crowded”被部分忽略，尽管它也是消极意义上的词语。因此,情绪的神经ASC模型错误地预测最后两个测试句子:在第一个测试中句子,神经ASC模型未能捕获的负面情绪与“拥挤”;同时,在第二个测试句子,注意机制直接关注“小”尽管这样与方面词没有关系。（<strong>本次测试样例中的aspect是place？？</strong>）</p>
<p>在本文中，我们提出了<strong>一种针对神经ASC模型的新型渐进式自我监督注意力学习方法</strong>。该方法可以自动的递增的从训练语料中获得注意力监督信息，它可以用于指导ASC模型中attention机制的训练。</p>
<p><strong>想法依据</strong>：注意权重最大的上下文词对输入句子的情感预测影响最大。因此，在模型训练过程中应考虑正确预测的训练实例的上下文词。 相反，预测错误的训练数据应该被忽视。为此，我们迭代地对所有训练实例进行情绪预测。</p>
<p><strong>大致过程</strong>：特别的是，在每次迭代时，我们从每一次训练实例中提取出最大的attention权重去规范attention监督信息，这可以用于规范attention机制的训练：在正确预测的情况下，我们将保留此词以供考虑； 否则，预计该词的注意力下降。然后，我们屏蔽了到目前为止每个训练实例提取的所有上下文词，然后<strong>重新进行上述过程</strong>以发现更多注意机制的监督信息。 最后，我们用调节器增强标准训练目标，该调节器强制这些挖掘的上下文词的注意力分布与其预期分布相一致。</p>
<p><strong>本文突出贡献</strong>：<br>(1)通过深入分析，指出了目前一般的注意力机制存在的不足。<br>(2)提出了一种新的神经ASC模型注意监控信息自动提取的增量方法。<br>(3)我们将我们的方法应用于两个主要的神经ASC模型:记忆网络(MN) 和转换网络(TNet)。几个基准数据集的实验结果证明了该方法的有效性。</p>
<h2 id="2-背景"><a href="#2-背景" class="headerlink" title="2.背景"></a>2.背景</h2><p>本节简单给出MN和TNet两个模型的介绍，这两个模型都实现了令人满意的效果。<br><strong>几个参数介绍：</strong><br>x=   (x1,x2,…,xN) ：输入句子文本<br>t= (t1,t2,…,tT) ：给出的目标aspect<br>y,yp∈{Positive,  Negative,  Neutral}用于表示真实的标签和预测的标签（即情感极性）<br><img src="https://img-blog.csdnimg.cn/20191222165031285.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQzMzk2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">)<img src="https://img-blog.csdnimg.cn/20191222165050794.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQzMzk2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><strong>MN模型</strong>：先介绍一个方面嵌入矩阵，将每个target aspect的单词tj转换为词向量表示形式，然后定义最终t的词向量表示形式为v(t)，作为该词的<strong>平均aspect词嵌入向量</strong>。 同时，另一个嵌入矩阵用于将每个上下文单词xi投影到连续存储的内存中，用mi表示。然后，使用内部attention机制生成句子x的与aspect相关的情感语义表示<br><img src="https://img-blog.csdnimg.cn/20191222145515516.png" alt="在这里插入图片描述"><br>其中M是一个attention矩阵，并且<strong>hi</strong>是从上下文词中引出的xi的最终语义表示，被从上下文词嵌入矩阵导出。 最后，我们使用完全连接的输出层基于o和v（t）进行分类。</p>
<p><strong>TNet</strong>：三个组件<br>(1)底层是Bi-LSTM，它将输入x转换为<strong>上下文化的单词表示形式</strong> （<strong>此处有疑问</strong>）<br><img src="https://private.codecogs.com/gif.latex?h%5E%7B%280%29%7D%28x%29%20=%20%28h_1%5E%7B%280%29%7D,h_2%5E%7B%280%29%7D,%5Ccdots,h_N%5E%7B%280%29%7D%29" alt="在这里插入图片描述"><br>(即Bi-LSTM的隐藏状态)。</p>
<p>(2)中间部分作为整个模型的核心，包含L层上下文保持转换(Context-Preserving Transformation:CPT)，其中单词表示形式更新为<img src="https://private.codecogs.com/gif.latex?h%5E%7B%28l&plus;1%29%7D%28x%29%20=%20CPT%28h%5E%7B%28l%29%7D%28x%29%29" alt="在这里插入图片描述">)。CPT层的关键操作是特定于目标的转换。它包含另一个Bi-LSTM，用于通过注意机制生成v(t)，然后将v(t)合并到单词表示中。此外，CPT层还配备了上下文保存机制(Context-Preserving Mechanism: CPM)来保存上下文信息和学习更抽象的单词级特性。最后，我们得到了单词级语义表示<br><img src="https://private.codecogs.com/gif.latex?h%28x%29%20=%20%28h_1,h_2,%5Ccdots,h_N%29,with%20h_i%20=h_i%5E%7B%28L%29%7D" alt="在这里插入图片描述"><br>(3)最上层是CNN层，用于生成与方面相关的句子表示o进行情感分类。</p>
<p>在这项工作中，我们考虑了原始TNet的另一种替代方案，该替代方案用注意力机制替换了最顶层的CNN，以产生与方面相关的句子表示形式为：o = Atten（h（x），v（t））。 在第4节中，我们将研究原始的TNet及其配备注意机制的变体的性能，该机制由TNet-ATT表示。</p>
<p><strong>训练对象</strong>：上述两种模型都以gold-truth情绪标签的负对数可能性为研究对象<br><img src="https://img-blog.csdnimg.cn/20191222151213443.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQzMzk2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="3-本文方法"><a href="#3-本文方法" class="headerlink" title="3.本文方法"></a>3.本文方法</h2><p>在本节中，我们首先描述了方法背后的基本认识，然后提供了其详细信息。最后，我们阐述了如何将挖掘的监督信息纳入注意机制到神经ASC模型中。我们的方法只适用于神经ASC模型的训练优化，对模型测试没有任何影响</p>
<h3 id="3-1基本介绍（直观理解）"><a href="#3-1基本介绍（直观理解）" class="headerlink" title="3.1基本介绍（直观理解）"></a>3.1基本介绍（直观理解）</h3><p>我们的方法的基本直觉源于以下事实：在注意力ASC模型中，每个上下文单词在给定方面的重要性主要取决于其关注权重。 因此，关注度最大的上下文词对输入句子的情感预测影响最大。 因此，对于训练句子，如果ASC模型的预测是正确的，我们认为继续关注该上下文词是合理的。 相反的话，应该降低该上下文词的注意力权重。<br>但是，如前所述，具有最大注意力权重的上下文词通常是具有强烈情感极性的上下文词。 它通常在训练语料库中频繁发生，因此在模型训练过程中往往会过分考虑。 这同时导致对其他上下文单词，尤其是具有情感极性的低频单词的学习不足。 <strong>为了解决该问题，一种直观且可行的方法是在重新研究训练实例的其余上下文词的效果之前，首先屏蔽该最重要的上下文词的影响。 在这种情况下，可以根据它们的注意力权重发现其他具有情感极性的低频上下文词</strong></p>
<h3 id="3-2算法细节"><a href="#3-2算法细节" class="headerlink" title="3.2算法细节"></a>3.2算法细节</h3><p>我们提出了一种新颖的增量方法，可以从训练实例中自动挖掘有影响力的上下文词，然后可以将其用作神经ASC模型的注意监督信息。（说好几遍了。。。）<br><img src="https://img-blog.csdnimg.cn/20191222151828977.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQzMzk2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>首先使用初始训练语料库D进行模型训练，然后获得初始模型参数$\Theta ^{(0)}$（第1行）。 然后，我们继续训练K迭代模型，在其中可以迭代地提取所有训练实例的有影响力的上下文单词（第6-25行）。 在此过程中，对于每个训练实例（x，t，y），我们引入初始化为∅的两个单词集（第2-5行），以记录其提取的上下文单词：（1）$S_{a}(x)$包括对 x的情绪预测有积极作用的上下文单词。每个$S_{a}(x)$的单词将被考虑更加细化的模型训练中（2）$S_{m}(x)$包含具有误导作用的上下文词，预期其注意力权重将降低。 具体来说，在第k次训练迭代中，我们采用以下步骤来处理（x，t，y）：<br><img src="https://img-blog.csdnimg.cn/20191222153036559.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQzMzk2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>在第1步中</strong>，我们首先应用上一次迭代的模型参数θ（k-1）生成纵横表示v（t）（第9行）。 重要的是，根据sa（x）和sm（x），我们然后屏蔽所有先前提取的x的上下文词以创建新的句子x’，其中每个被屏蔽的词都用特殊标记“ 〈mask〉”替换（第10行） 以此方式，在x’的情感预测期间将屏蔽这些上下文词的影响，因此可以从x’提取其他上下文词。 最后我们得到单词之间的关系：<br><img src="https://img-blog.csdnimg.cn/20191222153336482.png" alt="在这里插入图片描述"><br><strong>在第2步中</strong>，基于v（t）和h（x’），利用θ（k-1）预测x’作为yp的情感极性（第12行），其中单词级注意力权重分布<br><img src="https://img-blog.csdnimg.cn/20191222153553720.png" alt="在这里插入图片描述"><br>权重分布由下式得到<br><img src="https://img-blog.csdnimg.cn/20191222153637602.png" alt="在这里插入图片描述"></p>
<p><strong>在步骤3中</strong>，我们使用熵E（α（x’） ）以测量α（x’）的方差（第13行），有助于确定影响上下文上下文词的存在，以进行x’的情感预测:<br><img src="https://img-blog.csdnimg.cn/20191222153739401.png" alt="在这里插入图片描述"><br>如果E（α（x’））小于阈值Cα（第14行），我们认为存在至少一个上下文词，对x’的情感预测有很大影响。 因此，我们提取具有最大注意权重的上下文词x’m（第15-20行），将其用作注意监督信息以完善模型训练。 具体来说，我们针对x’的不同预测结果采取两种策略来处理x’m：如果预测正确，我们希望继续关注x’m，将其添加到sa（x）中（第16-17行）； 否则，我们期望减少x’m的注意力权重，因此将其包括到sm（x）中（第18-19行）。</p>
<p><strong>在第4步中</strong>，我们将t，x’和y组合成一个三元组，并将其与收集到的三元组合并，以形成一个新的训练语料库D（k）（第22行）。 然后，我们将D（k）做出影响级以继续更新模型参数以进行下一次迭代（第24行）。 通过这样做，我们使模型具有适应性，可以发现更多有影响力的上下文词。</p>
<p>通过上述步骤的集合，我们可以提取所有训练实例的有影响力的上下文词。 表2说明了表1中显示的第一句话的上下文词挖掘过程。在此示例中，我们轮换着迭代这提取下面三个词“small”,  “crowded”和“quick”。前两个词包含在insa（x）中，最后一个包含在insm（x）中。最后，每个训练实例的提取上下文词将被包含到D中，形成具有注意力监控信息的最终训练语料Ds（第26-29行） ，这将用于进行最后的模型训练（第30行）。 </p>
<h3 id="3-3attention监督信息模型的训练"><a href="#3-3attention监督信息模型的训练" class="headerlink" title="3.3attention监督信息模型的训练"></a>3.3attention监督信息模型的训练</h3><p><img src="https://img-blog.csdnimg.cn/20191222154622883.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQzMzk2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">)<img src="https://img-blog.csdnimg.cn/20191222154642873.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQzMzk2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="4、实验部分"><a href="#4、实验部分" class="headerlink" title="4、实验部分"></a>4、实验部分</h2><p><strong>数据集</strong>：我们将提出的方法应用于MN和TNet-ATT（参见第2节），并在三个基准数据集上进行了实验：LAPTOP， REST和TWITTER。在数据集中，已经提供了每个句子的目标方面。 此外，我们删除了一些带有冲突情绪标签的实例（Chen et al。，2017）。 表3列出了最终数据集的统计信息。（上面的表）</p>
<p><strong>对比模型</strong>：我们将两个增强的ASC模型称为MN（+ AS）和TNet-ATT（+ AS），并将它们与MN，TNet和TNet-ATT进行比较。 请注意，我们的模型需要进行额外的K + 1次迭代训练，因此，我们还将它们与上述进行了额外的K + 1次迭代训练的模型进行了比较，分别表示为MN（+ KT），TNet（+ KT）和TNet-ATT（+ KT）。此外为了研究不同种attention监督信息的影响，我们还列出了MN（+ ASa）和MN（+ ASm）的性能，它们分别仅利用了sa（x）和sm（x）的上下文词，并且对于TNet-ATT（+ ASa）和TNet-ATT（+ ASm）都是相同的效果。</p>
<p><strong>训练细节</strong>：我们使用预先训练的GloVe vectors初始化矢量尺寸为300的单词嵌入。对于词汇量不大的单词，我们从均匀分布[-0.25，0.25]中随机采样其嵌入。 此外，我们在[-0.01，0.01]之间均匀初始化了其他模型参数。为缓解过度拟合，我们在LSTM的输入单词嵌入和最终与方面相关的句子表示上采用了dropout策略。 （Kingma and Ba，2015）被作为优化器，学习率为0.001。<br>在实施我们的方法时，我们根据经验将最大迭代数K为5，方程3中的γ设置为LAPTOP数据集上的0.1，REST数据集上的0.5，TWITTER数据集上为0.1。 所有超参数均为20％随机调整的训练数据。最后，我们使用F1-Macro和准确性作为我们的评估方法。<br><img src="https://img-blog.csdnimg.cn/20191222155726907.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQzMzk2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="4-1Effects-of-epsilon-a"><a href="#4-1Effects-of-epsilon-a" class="headerlink" title="4.1Effects of $\epsilon _{a}$"></a>4.1Effects of $\epsilon _{a}$</h3><p>$\epsilon _{a}$是一个非常重要的超参数，它控制挖掘注意超信息的迭代次数（请参见算法1第14行）。 因此，在这组实验中，我们将$\epsilon _{a}$从1.0更改为7.0，每次递增1，以研究其对我们的模型在验证集上的性能的影响。图3和图4显示了实验 不同模型的结果。 具体来说，$\epsilon _{a}$= 3.0的MN（+ AS）达到最佳性能，而当$\epsilon _{a}$= 4.0时，获得了TNet-ATT（+ AS）的最优性能。 我们观察到α的增加并没有导致进一步的改进，这可能是由于提取了更多嘈杂的上下文词所致。由于这些结果，我们分别将MN（+ AS）和TNet-ATT（+ AS）的$\epsilon _{a}$设置为3.0和4.0。 </p>
<h3 id="4-2-总体结果"><a href="#4-2-总体结果" class="headerlink" title="4.2 总体结果"></a>4.2 总体结果</h3><p>表4提供了所有实验结果。 为了增强我们实验结果的说服力，我们还在同一数据集上显示了MN（Wang等人，2018）和TNet（Liet等人，2018）先前报告的得分。 根据实验结果，我们可以得出以下结论：</p>
<p><strong>首先</strong>，我们重新实现的MN和TNet均与（Wang等人，2018; Li等人，2018）中报道的原始模型相当。 这些结果表明，我们重新实现的基准具有竞争力。 当我们用注意机制替换TNet的CNN时，TNet-ATT稍逊于TNet。 此外，当我们在这些模块上执行附加的K + 1迭代训练时，它们的性能并没有显着改变，这表明仅增加训练时间就无法增强神经ASC模型的性能。</p>
<p><strong>其次</strong> 在MN和TNet-ATT中提出的方法中，上下文单词in sa（x）比in sm（x）更有效，这是因为正确预测的训练实例的比例大于不正确训练实例的比例。 此外，MN（+ ASa）和MN（+ ASm）之间的性能差距比TNet-ATT的两个变体之间的性能差距要大。 一个潜在的原因是TNet-ATT的性能优于MN，这使TNet-ATT可以产生更正确预测的训练实例。 与MN相比，这反过来给TNet-ATT带来了更多关注的监督。</p>
<p>最后，当我们同时使用两种注意力监督信息时，无论哪种算法，测试集中MN（+ AS）在所有方面都明显优于MN。尽管我们的TNet-ATT稍逊于TNet，但TNet-ATT（+ AS）仍大大超过TNet和TNet-ATT。 这些结果强有力地证明了我们方法的有效性和普遍性。</p>
<h3 id="4-3案例研究"><a href="#4-3案例研究" class="headerlink" title="4.3案例研究"></a>4.3案例研究</h3><p>为了了解我们的方法如何改进神经ASC模型，我们深入分析了TNet-ATT和TNet-ATT（+ AS）的注意力结果。 已经发现，我们提出的方法可以很好地解决上述两个问题。<br><img src="https://img-blog.csdnimg.cn/20191222160606414.png" alt="在这里插入图片描述"><br>表5提供了两个测试案例。 TNet-ATT错误地将第一个测试句子的情绪预测为中立。 这是因为上下文词“不舒服”仅出现在两个带有负极性的训练实例中，这分散了对其的注意力。 使用我们的方法时，在这两种情况下，“uncomfortable”的平均注意力权重增加到基线的2.6倍。 因此，TNet-ATT（+ AS）能够为该上下文词分配更大的关注权重（0.0056→0.2940），从而导致对第一个测试句子的正确预测。 对于第二个测试语句，由于上下文单词“ cute”出现在大多数具有正极性的训练实例中，因此TNet-ATT直接将注意力集中在该单词上，然后错误地将情感感知预测为积极。 采用我们的方法，在具有神经或负极性的训练实例中，“可爱”的注意力权重显着降低。 具体而言，在这些情况下，“可爱”的平均权重降低到原始值的0.07倍。 因此，TNet-ATT（+ AS）将较小的权重（0.1090→0.0062）分配给“cute”，并获得正确的情感预测。</p>
<h2 id="5-相关工作"><a href="#5-相关工作" class="headerlink" title="5.相关工作"></a>5.相关工作</h2><p>最近，已经证明神经模型在ASC上是成功的。 例如，由于具有多重优势（例如更简单，更快速），具有注意力机制的MN被广泛使用（Tang等; Wang等）。另一种流行的神经模型是LSTM，它也涉及 一个关注机制来明确捕捉每个上下文词的重要性（Wang等人，2016）。 总的来说，注意力机制在所有这些模型中都起着至关重要的作用。</p>
<p>跟随这种趋势，研究人员诉诸了更为复杂的注意力机制来重新完善神经ASC模型。 Chen 提出了一种多注意机制来捕获相隔很远距离的情感特征，以使其对不相关的信息更具鲁棒性。 Ma等人为ASC设计了一个交互式注意力网络，其中引入了两个注意力网络来对目标和上下文进行交互建模。 Liu 提出对ASC利用多种注意力：一个是从给定方面的左上下文获得的，另一个是从给定方面的右上下文获得的。 最近，ASC也探索了基于变换的模型（Li等，2018），注意力机制被CNN取代。</p>
<p>与这些工作不同的是，我们的工作与引入注意力监督以精炼的研究相一致。 注意机制，已成为事件检测（Liuet等人，2017），机器翻译（Liu等人，2016）和警察杀人检测（Nguyen and Nguyen，2018）等多个基于NN的NLP任务中的热门研究主题。 ）。 但是，这种有监督的注意力获取是很费力的。 因此，我们主要致力于自动采矿监督信息，以获取神经ASC模型的注意机制。从理论上讲，我们的方法与这些模型正交，因此我们将对这些模型的适应性留作以后的工作。</p>
<p>我们的工作受到两个最新模型的启发：其中一个时（Wei等人，2017）提出使用分类阳离子网络逐步消除区分对象区域以解决弱监督语义分割问题，另一个是（Xu等人，2018） 其中提出了一种与全局信息集成的辍学方法，以鼓励模型挖掘不明显的特征或模式进行文本分类。 据我们所知，我们的工作是第一个探索自动挖掘ASC注意监控信息的人。</p>
<h2 id="6-总结与工作计划"><a href="#6-总结与工作计划" class="headerlink" title="6.总结与工作计划"></a>6.总结与工作计划</h2><p>在本文中，我们探索了如何自动挖掘监督信息，以用于神经ASC模型的注意机制。 通过深入的分析，我们首先指出了ASC注意机制的缺陷：一些带有情感极性的常用词往往被​​过度学习，而频率较低的词却缺乏足够的学习能力。 然后，我们提出了一种新的方法来自动地、增量地挖掘神经ASC模型的注意监督信息。 这些挖掘的信息可以通过正则化项进一步用于优化模型训练。 为了验证我们方法的有效性，我们将我们的方法应用于两个主要的神经ASC模型，实验结果表明我们的方法显着改善了这两个模型的性能。 因此，我们计划将我们的方法扩展到具有注意机制的其他神经NLP任务，例如神经文档分类（Yang等）和神经机器翻译（Zhang等）。</p>
]]></content>
      <tags>
        <tag>论文</tag>
      </tags>
  </entry>
  <entry>
    <title>&lt;Transformer&gt;Transformer模型理解博客索引</title>
    <url>/2020/05/28/Transformer%E6%A8%A1%E5%9E%8B%E7%90%86%E8%A7%A3%E5%8D%9A%E5%AE%A2%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<h1 id="1-详解Transformer-（Attention-Is-All-You-Need）"><a href="#1-详解Transformer-（Attention-Is-All-You-Need）" class="headerlink" title="1. 详解Transformer （Attention Is All You Need）"></a>1. <a href="https://zhuanlan.zhihu.com/p/48508221" target="_blank" rel="noopener">详解Transformer （Attention Is All You Need）</a></h1><h1 id="2-The-Illustrated-Transformer"><a href="#2-The-Illustrated-Transformer" class="headerlink" title="2. The Illustrated Transformer"></a>2. <a href="http://jalammar.github.io/illustrated-transformer/" target="_blank" rel="noopener">The Illustrated Transformer</a></h1><h1 id="3-The-Illustrated-Transformer【译】"><a href="#3-The-Illustrated-Transformer【译】" class="headerlink" title="3.The Illustrated Transformer【译】"></a>3.<a href="https://blog.csdn.net/yujianmin1990/article/details/85221271" target="_blank" rel="noopener">The Illustrated Transformer【译】</a></h1><h1 id="4-Transformer-模型详解"><a href="#4-Transformer-模型详解" class="headerlink" title="4.Transformer 模型详解"></a>4.<a href="https://blog.csdn.net/Wisimer/article/details/104415321" target="_blank" rel="noopener">Transformer 模型详解</a></h1><h1 id="5-从中文Transformer到BERT的模型精讲-以及基于BERT情感分类实战"><a href="#5-从中文Transformer到BERT的模型精讲-以及基于BERT情感分类实战" class="headerlink" title="5.从中文Transformer到BERT的模型精讲,以及基于BERT情感分类实战"></a>5.<a href="https://www.bilibili.com/video/av73631845?from=search&seid=4116979672298307428" target="_blank" rel="noopener">从中文Transformer到BERT的模型精讲,以及基于BERT情感分类实战</a></h1>]]></content>
      <categories>
        <category>Transformer</category>
      </categories>
      <tags>
        <tag>Transformer</tag>
      </tags>
  </entry>
  <entry>
    <title>&lt;java&gt;常用的集合类笔记</title>
    <url>/2020/05/04/java%E5%B8%B8%E7%94%A8%E9%9B%86%E5%90%88%E7%B1%BB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>摘要：<br>介绍常用的set、Map、List</p>
<a id="more"></a>
<p><strong>概述</strong>：</p>
<ul>
<li>List , Set, Map都是接口，前两个继承至Collection接口，Map为独立接口</li>
<li>Set下有<strong>HashSet</strong>，LinkedHashSet，TreeSet</li>
<li>List下有<strong>ArrayList</strong>，Vector，<strong>LinkedList</strong></li>
<li>Map下有Hashtable，LinkedHashMap，<strong>HashMap</strong>，TreeMap</li>
</ul>
<h1 id="A、总结"><a href="#A、总结" class="headerlink" title="A、总结"></a><a href="https://blog.csdn.net/zhangqunshuai/article/details/80660974?ops_request_misc=&request_id=&biz_id=102&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0" target="_blank" rel="noopener">A、总结</a></h1><h2 id="1-List-有序-可重复："><a href="#1-List-有序-可重复：" class="headerlink" title="1.List 有序,可重复："></a>1.List 有序,可重复：</h2><ul>
<li><strong>ArrayList</strong><br>优点: 底层数据结构是数组，查询快，增删慢。<br>缺点: 线程不安全，效率高</li>
<li><strong>Vector</strong><br>优点: 底层数据结构是数组，查询快，增删慢。<br>缺点: 线程安全，效率低</li>
<li><strong>LinkedList</strong><br>优点: 底层数据结构是链表，查询慢，增删快。<br>缺点: 线程不安全，效率高</li>
</ul>
<h2 id="2-Set-无序-唯一："><a href="#2-Set-无序-唯一：" class="headerlink" title="2.Set 无序,唯一："></a>2.Set 无序,唯一：</h2><ul>
<li><strong>HashSet</strong><br>底层数据结构是哈希表。(无序,唯一)<br>如何来保证元素唯一性?</li>
</ul>
<p>1.依赖两个方法：hashCode()和equals()</p>
<ul>
<li><strong>LinkedHashSet</strong><br>底层数据结构是链表和哈希表。(FIFO插入有序,唯一)</li>
</ul>
<p>1.由链表保证元素有序<br>2.由哈希表保证元素唯一</p>
<ul>
<li><strong>TreeSet</strong><br>底层数据结构是红黑树。(唯一，有序)<br>1 如何保证元素排序的呢?<br>自然排序<br>比较器排序<br>2如何保证元素唯一性的呢?<br>根据比较的返回值是否是0来决定</li>
</ul>
<p><strong>Tips：</strong><br><strong>Set中元素唯一，list不唯一；<br>list中vector安全，ArrayList和LinkedList不安全；<br>ArrayList查询方便，因为底层是数组，LinkedList增删方便，底层是链表结构</strong></p>
<h2 id="3-Map："><a href="#3-Map：" class="headerlink" title="3.Map："></a>3.Map：</h2><p>Map接口有三个比较重要的实现类，分别是HashMap、TreeMap和HashTable。</p>
<h3 id="Map的Tips："><a href="#Map的Tips：" class="headerlink" title="Map的Tips："></a>Map的Tips：</h3><p>1.TreeMap是有序的，HashMap和HashTable是无序的。<br>2.Hashtable是线程安全的，HashMap不是线程安全的。<br>3.Hashtable不允许null值，HashMap允许null值（key和value都允许）<br>4.HashMap效率较高，Hashtable效率较低。</p>
<h1 id="B、几种常用集合的函数使用"><a href="#B、几种常用集合的函数使用" class="headerlink" title="B、几种常用集合的函数使用"></a>B、几种常用集合的函数使用</h1><h2 id="1-List"><a href="#1-List" class="headerlink" title="1. List"></a>1. List</h2><h3 id="1-1ArrayList"><a href="#1-1ArrayList" class="headerlink" title="1.1ArrayList"></a>1.1<a href="https://blog.csdn.net/Barcon/article/details/82628120" target="_blank" rel="noopener">ArrayList</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化</span></span><br><span class="line">List&lt;String&gt; person=<span class="keyword">new</span> ArrayList&lt;&gt;();或者</span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"><span class="comment">//添加</span></span><br><span class="line">person.add(index,element);</span><br><span class="line">person.add(<span class="string">"jackie"</span>);   <span class="comment">//索引为0  //.add(e)</span></span><br><span class="line">person.add(<span class="string">"peter"</span>);    <span class="comment">//索引为1</span></span><br><span class="line">person.add(<span class="string">"annie"</span>);    <span class="comment">//索引为2</span></span><br><span class="line">person.add(<span class="string">"martin"</span>);   <span class="comment">//索引为3</span></span><br><span class="line"><span class="comment">//删除元素</span></span><br><span class="line">person.remove(<span class="number">3</span>);   <span class="comment">//.remove(index)</span></span><br><span class="line">person.remove(<span class="string">"marry"</span>);     <span class="comment">//.remove(Object o)</span></span><br><span class="line"><span class="comment">//获取</span></span><br><span class="line">person.get(<span class="number">1</span>); <span class="comment">//.get(index)</span></span><br><span class="line"><span class="comment">//获取列表的长度num</span></span><br><span class="line"><span class="keyword">int</span> num=person.size();</span><br><span class="line"><span class="comment">//list中是否包含某个元素</span></span><br><span class="line">person.contains(Object o);<span class="comment">//返回值为boolean类型数据</span></span><br><span class="line"><span class="comment">//list中根据索引将元素数值改变(替换)</span></span><br><span class="line">person.set(index,element);</span><br><span class="line">person.set(<span class="number">0</span>,<span class="string">"zhangsan"</span>);</span><br><span class="line"><span class="comment">//查看（判断）元素的索引;因为可能存在多个相同的元素值，list允许元素相同</span></span><br><span class="line">person.indexOf(<span class="string">"zhangsan"</span>);<span class="comment">//从第一个索引向后一次equals（）方法获取元素值相同的索引</span></span><br><span class="line">person.lastIndexOf(<span class="string">"zhangsan"</span>)<span class="comment">//从最后一个索引向前遍历list获取相同元素值得索引</span></span><br><span class="line"><span class="comment">//由索引截取list</span></span><br><span class="line">List&lt;String&gt; newPerson=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">newPerson=person.subList(fromIndex, toIndex);<span class="comment">//子表中不包含toIndex</span></span><br><span class="line"><span class="comment">//list间赋值</span></span><br><span class="line">List&lt;String&gt; person2=<span class="keyword">new</span> ArrayList&lt;&gt;()；</span><br><span class="line">person2.add(<span class="string">"12"</span>);</span><br><span class="line">person2.add(<span class="string">"13"</span>);</span><br><span class="line">person.addAll(person2);<span class="comment">//将列表person2加至person末尾</span></span><br><span class="line">person.addAll(<span class="number">0</span>, person2);<span class="comment">//将列表person2加至person索引指示的位置</span></span><br><span class="line"><span class="comment">//与上同理，list之间是否包含</span></span><br><span class="line">person.containsAll(person2);</span><br><span class="line"><span class="comment">//对比两个list中的所有元素</span></span><br><span class="line">person.equals(newPerson);<span class="comment">//返回值为boolean类型</span></span><br><span class="line"><span class="comment">//判断list是否为空</span></span><br><span class="line">person.isEmpty();<span class="comment">//返回值为boolean类型</span></span><br><span class="line"><span class="comment">//将集合转换为字符串</span></span><br><span class="line">String liString=<span class="string">""</span>;</span><br><span class="line">liString=person.toString()</span><br><span class="line"><span class="comment">//将List转换成数组</span></span><br><span class="line">person.toArray();</span><br><span class="line"><span class="comment">//获取迭代值对象</span></span><br><span class="line">ListIterator lit = person.listIterator();  </span><br><span class="line"><span class="keyword">while</span>(lit.hasNext())  </span><br><span class="line">    &#123;  </span><br><span class="line">        System.out.println(lit.next());  </span><br><span class="line">        <span class="comment">//向迭代对象中添加分隔符字符串</span></span><br><span class="line">         lit.add(<span class="string">"-----分隔符-----"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">System.out.println(<span class="string">"=====下面开始反向迭代====="</span>);  </span><br><span class="line"><span class="keyword">while</span>(lit.hasPrevious())  </span><br><span class="line">    &#123;  </span><br><span class="line">        System.out.println(lit.previous());  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-2-LinkedList"><a href="#1-2-LinkedList" class="headerlink" title="1.2 LinkedList"></a>1.2 <a href="https://blog.csdn.net/huyang0304/article/details/82389595?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-3&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-3" target="_blank" rel="noopener">LinkedList</a></h3><p><strong>优点</strong>：</p>
<ul>
<li>有序、可以向前面和向后添加 、中间插入也很方便 、可以用实现简单队列模式（removeFirst()  处理队列中的任务，add(); 向队列中排队）</li>
</ul>
<p><strong>缺点</strong>:</p>
<ul>
<li>消耗内存有点大、定位删除和定位查找 都是比较慢、检索能力差</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化</span></span><br><span class="line">List&lt;String&gt; person=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"><span class="comment">//增元素</span></span><br><span class="line">person.add(E e); 在链表后添加一个元素</span><br><span class="line">person.addFirst(E e); 在链表头部插入一个元素；</span><br><span class="line">person.addLast(E e);在链表尾部添加一个元素；</span><br><span class="line">person.push(E e);与addFirst方法一致  </span><br><span class="line">person.offer(E e);在链表尾部插入一个元素                                                                                                                                                  person.add(<span class="keyword">int</span> index, E element);在指定位置插入一个元素。      </span><br><span class="line">person.offerFirst(E e);JDK1<span class="number">.6</span>版本之后，在头部添加；                                                          person.offerLast(E e);JDK1<span class="number">.6</span>版本之后，在尾部添加； </span><br><span class="line"><span class="comment">//删</span></span><br><span class="line">person.remove() ：移除链表中第一个元素;    通用方法  </span><br><span class="line">person.remove(E e)：移除指定元素；   通用方法</span><br><span class="line">person.removeFirst(E e)：删除头，获取元素并删除；  特有方法</span><br><span class="line">person.removeLast(E e)：删除尾；  特有方法</span><br><span class="line">person.pollFirst()：删除头；  特有方法</span><br><span class="line">person.pollLast()：删除尾；  特有方法</span><br><span class="line">person.pop()：和removeFirst方法一致，删除头。 </span><br><span class="line">person.poll()：查询并移除第一个元素     特有方法 </span><br><span class="line"><span class="comment">//查</span></span><br><span class="line">person.get(<span class="keyword">int</span> index)：按照下标获取元素；  通用方法</span><br><span class="line">person.getFirst()：获取第一个元素；  特有方法</span><br><span class="line">person.getLast()：获取最后一个元素； 特有方法</span><br><span class="line">person.peek()：获取第一个元素，但是不移除；  特有方法</span><br><span class="line">person.peekFirst()：获取第一个元素，但是不移除； </span><br><span class="line">person.peekLast()：获取最后一个元素，但是不移除；</span><br><span class="line">person.pollFirst()：查询并删除头；  特有方法</span><br><span class="line">person.pollLast()：删除尾；  特有方法</span><br><span class="line">person.poll()：查询并移除第一个元素     特有方法</span><br></pre></td></tr></table></figure>

<h2 id="2-Set"><a href="#2-Set" class="headerlink" title="2. Set"></a>2. Set</h2><h3 id="2-1-HashSet"><a href="#2-1-HashSet" class="headerlink" title="2.1 HashSet"></a>2.1 <a href="https://blog.csdn.net/zhaobin0731/article/details/98878314?utm_medium=distribute.pc_relevant.none-task-blog-baidujs-5" target="_blank" rel="noopener">HashSet</a></h3><p>HashSet是set接口的实现类,储存的是无序，唯一的对象。<br>由于是无序的所以每组数据都没有索引，凡是需要通过索引来进行操作的方法都没有。<br>不能使用普通for循环来进行遍历，只有加强型for和迭代器两种遍历方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化</span></span><br><span class="line">HashSet&lt;String&gt; set=<span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line"><span class="comment">//添加元素，添加成功返回true，否则返回false</span></span><br><span class="line">set.add(Object obj);</span><br><span class="line">set.add(<span class="string">"tom"</span>);</span><br><span class="line">set.add(<span class="string">"bob"</span>);</span><br><span class="line"><span class="comment">//返回Set集合中的元素个数</span></span><br><span class="line">set.size();</span><br><span class="line"><span class="comment">//验证非空</span></span><br><span class="line">set.isEmpty();<span class="comment">//返回Boolean值</span></span><br><span class="line"><span class="comment">//移除此Set中的所有元素</span></span><br><span class="line">set.clear();</span><br><span class="line"><span class="comment">//是否包含某元素</span></span><br><span class="line">set.contains(<span class="string">"bob"</span>);</span><br><span class="line"><span class="comment">//删除集合中的元素，删除成功返回true，否则返回false</span></span><br><span class="line">set.remove(<span class="string">"bob"</span>);</span><br><span class="line"><span class="comment">//返回在此Set中的元素上进行迭代的迭代器</span></span><br><span class="line">Iterator&lt;String&gt; iterator=set.iterator();</span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext()) &#123;</span><br><span class="line">			System.out.println(iterator.next());</span><br><span class="line">		&#125;</span><br><span class="line"><span class="comment">//遍历集合是无序的,可能每次结果不相同</span></span><br></pre></td></tr></table></figure>
<h3 id="2-2-TreeSet"><a href="#2-2-TreeSet" class="headerlink" title="2.2 TreeSet"></a>2.2 <a href="https://www.cnblogs.com/Tony-cheen/p/5681831.html" target="_blank" rel="noopener">TreeSet</a></h3><p>TreeSet 是一个有序的集合，它的作用是提供有序的Set集合。</p>
<h2 id="3-Map"><a href="#3-Map" class="headerlink" title="3. Map"></a>3. Map</h2><h3 id="3-1-HashMap"><a href="#3-1-HashMap" class="headerlink" title="3.1 HashMap"></a>3.1 <a href="https://blog.csdn.net/login_sonata/article/details/76598675?ops_request_misc=&request_id=&biz_id=102&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-3" target="_blank" rel="noopener">HashMap</a></h3><p>根据键的hashCode值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，但遍历顺序却是不确定的。 HashMap最多只允许一条记录的键为null，允许多条记录的值为null。</p>
<p>HashMap非线程安全，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致。如果需要满足线程安全，可以用 Collections的synchronizedMap方法使HashMap具有线程安全的能力，或者使用ConcurrentHashMap。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化</span></span><br><span class="line">HashMap&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="comment">//添加键值对</span></span><br><span class="line">map.put(<span class="string">"zhang"</span>, <span class="string">"31"</span>);<span class="comment">//存放键值对</span></span><br><span class="line"><span class="comment">//通过键拿值</span></span><br><span class="line">map.get(<span class="string">"zhang"</span>);</span><br><span class="line"><span class="comment">//判断是否包含某个键</span></span><br><span class="line">map.containsKey(<span class="string">"zhang"</span>);</span><br><span class="line"><span class="comment">//判空</span></span><br><span class="line">map.isEmpty();<span class="comment">//返回值为boolean类型</span></span><br><span class="line"><span class="comment">//map大小</span></span><br><span class="line">map.size();</span><br><span class="line"><span class="comment">//从键值中删除</span></span><br><span class="line">map.remove(<span class="string">"zhang"</span>);</span><br><span class="line"><span class="comment">//循环取值</span></span><br><span class="line">map.put(<span class="string">"cheng"</span>, <span class="string">"32"</span>);</span><br><span class="line">map.put(<span class="string">"yun"</span>, <span class="string">"33"</span>);</span><br><span class="line"><span class="keyword">for</span> (String key : map.keySet()) </span><br><span class="line">		System.out.println(key);	</span><br><span class="line"><span class="keyword">for</span> (String values : map.values())</span><br><span class="line">		System.out.println(values);	</span><br><span class="line"><span class="comment">//清除map</span></span><br><span class="line">map.clear();</span><br></pre></td></tr></table></figure>
<h2 id="4-Stack"><a href="#4-Stack" class="headerlink" title="4. Stack"></a>4. Stack</h2><p>Stack继承于Vector，因此它也包含Vector中的全部API。vector实现了List。但因为比较常用单把它摘出来。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stack的基本使用</span><br><span class="line">初始化</span><br><span class="line">Stack stack=<span class="keyword">new</span> Stack</span><br><span class="line">判断是否为空</span><br><span class="line">stack.empty()</span><br><span class="line">取栈顶值（不出栈）</span><br><span class="line">stack.peek()</span><br><span class="line">进栈</span><br><span class="line">stack.push(Object);</span><br><span class="line">出栈</span><br><span class="line">stack.pop();</span><br><span class="line"> </span><br><span class="line">实例：</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stack stack=<span class="keyword">new</span> Stack();</span><br><span class="line">        <span class="comment">//1.empty()栈是否为空</span></span><br><span class="line">        System.out.println(stack.empty());</span><br><span class="line">        <span class="comment">//2.peek()栈顶值    3.进栈push()</span></span><br><span class="line">        stack.push(<span class="keyword">new</span> Integer(<span class="number">1</span>));</span><br><span class="line">        stack.push(<span class="string">"b"</span>);</span><br><span class="line">        System.out.println(stack.peek());</span><br><span class="line">        <span class="comment">//4.pop()出栈</span></span><br><span class="line">        stack.pop();</span><br><span class="line">        System.out.println(stack.peek());</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">import</span> java.util.Stack;</span><br><span class="line"><span class="number">2</span> <span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="number">3</span> <span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="number">4</span> </span><br><span class="line"><span class="number">5</span> <span class="comment">/**</span></span><br><span class="line"><span class="comment">6  * <span class="doctag">@desc</span> Stack的测试程序。测试常用API的用法</span></span><br><span class="line"><span class="comment">7  *</span></span><br><span class="line"><span class="comment">8  * <span class="doctag">@author</span> skywang</span></span><br><span class="line"><span class="comment">9  */</span></span><br><span class="line"><span class="number">10</span> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackTest</span> </span>&#123;</span><br><span class="line"><span class="number">11</span> </span><br><span class="line"><span class="number">12</span>     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="number">13</span>         Stack stack = <span class="keyword">new</span> Stack();</span><br><span class="line"><span class="number">14</span>         <span class="comment">// 将1,2,3,4,5添加到栈中</span></span><br><span class="line"><span class="number">15</span>         <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;<span class="number">6</span>; i++) &#123;</span><br><span class="line"><span class="number">16</span>             stack.push(String.valueOf(i));</span><br><span class="line"><span class="number">17</span>         &#125;</span><br><span class="line"><span class="number">18</span> </span><br><span class="line"><span class="number">19</span>         <span class="comment">// 遍历并打印出该栈</span></span><br><span class="line"><span class="number">20</span>         iteratorThroughRandomAccess(stack) ;</span><br><span class="line"><span class="number">21</span> </span><br><span class="line"><span class="number">22</span>         <span class="comment">// 查找“2”在栈中的位置，并输出</span></span><br><span class="line"><span class="number">23</span>         <span class="keyword">int</span> pos = stack.search(<span class="string">"2"</span>);</span><br><span class="line"><span class="number">24</span>         System.out.println(<span class="string">"the postion of 2 is:"</span>+pos);</span><br><span class="line"><span class="number">25</span> </span><br><span class="line"><span class="number">26</span>         <span class="comment">// pup栈顶元素之后，遍历栈</span></span><br><span class="line"><span class="number">27</span>         stack.pop();</span><br><span class="line"><span class="number">28</span>         iteratorThroughRandomAccess(stack) ;</span><br><span class="line"><span class="number">29</span> </span><br><span class="line"><span class="number">30</span>         <span class="comment">// peek栈顶元素之后，遍历栈</span></span><br><span class="line"><span class="number">31</span>         String val = (String)stack.peek();</span><br><span class="line"><span class="number">32</span>         System.out.println(<span class="string">"peek:"</span>+val);</span><br><span class="line"><span class="number">33</span>         iteratorThroughRandomAccess(stack) ;</span><br><span class="line"><span class="number">34</span> </span><br><span class="line"><span class="number">35</span>         <span class="comment">// 通过Iterator去遍历Stack</span></span><br><span class="line"><span class="number">36</span>         iteratorThroughIterator(stack) ;</span><br><span class="line"><span class="number">37</span>     &#125;</span><br><span class="line"><span class="number">38</span> </span><br><span class="line"><span class="number">39</span>     <span class="comment">/**</span></span><br><span class="line"><span class="comment">40      * 通过快速访问遍历Stack</span></span><br><span class="line"><span class="comment">41      */</span></span><br><span class="line"><span class="number">42</span>     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">iteratorThroughRandomAccess</span><span class="params">(List list)</span> </span>&#123;</span><br><span class="line"><span class="number">43</span>         String val = <span class="keyword">null</span>;</span><br><span class="line"><span class="number">44</span>         <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;list.size(); i++) &#123;</span><br><span class="line"><span class="number">45</span>             val = (String)list.get(i);</span><br><span class="line"><span class="number">46</span>             System.out.print(val+<span class="string">" "</span>);</span><br><span class="line"><span class="number">47</span>         &#125;</span><br><span class="line"><span class="number">48</span>         System.out.println();</span><br><span class="line"><span class="number">49</span>     &#125;</span><br><span class="line"><span class="number">50</span> </span><br><span class="line"><span class="number">51</span>     <span class="comment">/**</span></span><br><span class="line"><span class="comment">52      * 通过迭代器遍历Stack</span></span><br><span class="line"><span class="comment">53      */</span></span><br><span class="line"><span class="number">54</span>     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">iteratorThroughIterator</span><span class="params">(List list)</span> </span>&#123;</span><br><span class="line"><span class="number">55</span> </span><br><span class="line"><span class="number">56</span>         String val = <span class="keyword">null</span>;</span><br><span class="line"><span class="number">57</span>         <span class="keyword">for</span>(Iterator iter = list.iterator(); iter.hasNext(); ) &#123;</span><br><span class="line"><span class="number">58</span>             val = (String)iter.next();</span><br><span class="line"><span class="number">59</span>             System.out.print(val+<span class="string">" "</span>);</span><br><span class="line"><span class="number">60</span>         &#125;</span><br><span class="line"><span class="number">61</span>         System.out.println();</span><br><span class="line"><span class="number">62</span>     &#125;</span><br><span class="line"><span class="number">63</span> </span><br><span class="line"><span class="number">64</span> &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>&lt;数据分析&gt; 中文文本分类FastText-pytorch</title>
    <url>/2020/06/12/%E4%B8%AD%E6%96%87%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%20FastText-pytorch/</url>
    <content><![CDATA[<p>摘要：中文文本分类FastText-pytorch<br>代码：<a href="https://github.com/649453932/Chinese-Text-Classification-Pytorch" target="_blank" rel="noopener">https://github.com/649453932/Chinese-Text-Classification-Pytorch</a></p>
<a id="more"></a>
<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>因为学习需要用到文本分析相关模型，就根据一个github库中的代码尝试实现文本分类的过程，在注释中添加学习笔记，若有错误请指正。<br>代码地址：<a href="https://github.com/649453932/Chinese-Text-Classification-Pytorch" target="_blank" rel="noopener">https://github.com/649453932/Chinese-Text-Classification-Pytorch</a></p>
<h1 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h1><p><img src="https://img-blog.csdnimg.cn/202006121807420.png" alt="!\[在这里插入图片描述\](https://img-blog.csdnimg.cn/20200612180633686.PNG"><br>其中runFastText为主函数，train_eval是训练函数，utils_fastTextTest是数据处理函数，名字与原github中有差别，代码大部分都相同。</p>
<h1 id="utils-fastTextTest-py"><a href="#utils-fastTextTest-py" class="headerlink" title="utils_fastTextTest.py"></a>utils_fastTextTest.py</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding: UTF-8</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pickle <span class="keyword">as</span> pkl</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> timedelta</span><br><span class="line"></span><br><span class="line">MAX_VOCAB_SIZE = <span class="number">10000</span> <span class="comment"># 词表长度限制</span></span><br><span class="line">UNK, PAD = <span class="string">'&lt;UNK&gt;'</span>, <span class="string">'&lt;PAD&gt;'</span> <span class="comment"># 未知字，padding符号</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_vocab</span><span class="params">(file_path, tokenizer, max_size, min_freq)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">      构建一个词表：</span></span><br><span class="line"><span class="string">      首先对数据集中的每一行句子按字/空格进行分割，然后统计所有元素的出现频率</span></span><br><span class="line"><span class="string">      接下来按照频率从高到低的顺序对所有频率大于min_freq的元素进行排序，取前max_size个元素</span></span><br><span class="line"><span class="string">      最后按照频率降序构建字典vocab_dic：&#123;元素:序号&#125;，vocab_dic的最后两个元素是'&lt;UNK&gt;'和'&lt;PAD&gt;'</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    vocab_dic = &#123;&#125;</span><br><span class="line">    <span class="keyword">with</span> open(file_path, <span class="string">'r'</span>, encoding=<span class="string">'UTF-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="comment"># tqdm是一个python的进度条工具包，在终端运行时显示程序循环的进度</span></span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> tqdm(f):<span class="comment"># 处理每一行</span></span><br><span class="line">            lin = line.strip() <span class="comment"># 移除头尾空格或换行符</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> lin: <span class="comment"># 跳过空行</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            content = lin.split(<span class="string">'\t'</span>)[<span class="number">0</span>] <span class="comment"># 句子和标签通过tab分割，前面的是句子内容，后面的是标签(lin.split('\t')[1])</span></span><br><span class="line">            <span class="keyword">for</span> word <span class="keyword">in</span> tokenizer(content): <span class="comment"># 按空格分割或者按字分割,tokenizer为可选择参数</span></span><br><span class="line">                vocab_dic[word] = vocab_dic.get(word, <span class="number">0</span>) + <span class="number">1</span> <span class="comment"># 统计词频或字频，即为每个词或字在训练集中出现的次数</span></span><br><span class="line">        <span class="comment"># 遍历词典，筛选出词频大于min_freq=1的词，然后按照词频从高到低排序，取前max_size=10000个词，组成新的列表vocab_list，vocab_list中的元素为元组(word, freq)</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        sorted函数用法：sorted(iterable, cmp=None, key=None, reverse=False)</span></span><br><span class="line"><span class="string">        iterable -- 可迭代对象。</span></span><br><span class="line"><span class="string">        cmp -- 比较的函数，这个具有两个参数，参数的值都是从可迭代对象中取出，此函数必须遵守的规则为，大于则返回1，小于则返回-1，等于则返回0。</span></span><br><span class="line"><span class="string">        key -- 主要是用来进行比较的元素，只有一个参数，具体的函数的参数就是取自于可迭代对象中，指定可迭代对象中的一个元素来进行排序。</span></span><br><span class="line"><span class="string">        reverse -- 排序规则，reverse = True 降序 ， reverse = False 升序（默认）。</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        vocab_list = sorted([_ <span class="keyword">for</span> _ <span class="keyword">in</span> vocab_dic.items() <span class="keyword">if</span> _[<span class="number">1</span>] &gt;= min_freq], key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>], reverse=<span class="literal">True</span>)[:max_size]</span><br><span class="line">        vocab_dic = &#123;word_count[<span class="number">0</span>]: idx <span class="keyword">for</span> idx, word_count <span class="keyword">in</span> enumerate(vocab_list)&#125;</span><br><span class="line">        <span class="comment"># 在vocab_dic的最后增加两个元素：&#123;'&lt;UNK&gt;':len(vocab_dic)&#125;和&#123;'&lt;PAD&gt;':len(vocab_dic)+1&#125;</span></span><br><span class="line">        vocab_dic.update(&#123;UNK: len(vocab_dic), PAD: len(vocab_dic) + <span class="number">1</span>&#125;)</span><br><span class="line">    <span class="keyword">return</span> vocab_dic</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_dataset</span><span class="params">(config, ues_word)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    加载数据集：</span></span><br><span class="line"><span class="string">    对数据集中的每一行，先分离内容和标签</span></span><br><span class="line"><span class="string">    然后对句子内容，按指定的方式进行分割（依照空格或字符），接着根据pad_size进行补足或截断</span></span><br><span class="line"><span class="string">    接着把分割后的元素，通过词表转化成一串序号words_line</span></span><br><span class="line"><span class="string">    最后把所有句子处理后的结果组成一个大列表，列表中的元素为：[(words_line, int(label), seq_len),...]</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> ues_word:</span><br><span class="line">        tokenizer = <span class="keyword">lambda</span> x: x.split(<span class="string">' '</span>)  <span class="comment"># 以空格隔开，word-level</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        tokenizer = <span class="keyword">lambda</span> x: [y <span class="keyword">for</span> y <span class="keyword">in</span> x]  <span class="comment"># char-level</span></span><br><span class="line">    <span class="comment"># if os.path.exists(config.vocab_path):</span></span><br><span class="line">    <span class="comment">#     vocab = pkl.load(open(config.vocab_path, 'rb'))</span></span><br><span class="line">    <span class="comment"># else:</span></span><br><span class="line">    <span class="comment"># 此处使用训练集自己构建词表</span></span><br><span class="line">    vocab = build_vocab(config.train_path, tokenizer=tokenizer, max_size=MAX_VOCAB_SIZE, min_freq=<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 构建完了之后保存为pickle</span></span><br><span class="line">    pkl.dump(vocab, open(config.vocab_path, <span class="string">'wb'</span>))</span><br><span class="line">    print(<span class="string">f"Vocab size: <span class="subst">&#123;len(vocab)&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">biGramHash</span><span class="params">(sequence, t, buckets)</span>:</span></span><br><span class="line">        t1 = sequence[t - <span class="number">1</span>] <span class="keyword">if</span> t - <span class="number">1</span> &gt;= <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> (t1 * <span class="number">14918087</span>) % buckets</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">triGramHash</span><span class="params">(sequence, t, buckets)</span>:</span></span><br><span class="line">        t1 = sequence[t - <span class="number">1</span>] <span class="keyword">if</span> t - <span class="number">1</span> &gt;= <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        t2 = sequence[t - <span class="number">2</span>] <span class="keyword">if</span> t - <span class="number">2</span> &gt;= <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> (t2 * <span class="number">14918087</span> * <span class="number">18408749</span> + t1 * <span class="number">14918087</span>) % buckets</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">load_dataset</span><span class="params">(path, pad_size=<span class="number">32</span>)</span>:</span></span><br><span class="line">        contents = []</span><br><span class="line">        <span class="keyword">with</span> open(path, <span class="string">'r'</span>, encoding=<span class="string">'UTF-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">            <span class="keyword">for</span> line <span class="keyword">in</span> tqdm(f): <span class="comment"># 打开数据文件，按行读取</span></span><br><span class="line">                lin = line.strip() <span class="comment"># 移除头尾空格或换行符</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> lin: <span class="comment"># 跳过空行</span></span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                content, label = lin.split(<span class="string">'\t'</span>) <span class="comment"># 句子和标签通过tab分割，前面的是句子内容，后面的是标签</span></span><br><span class="line">                words_line = []  <span class="comment"># words_line是句子通过词表转化后得到的数字表示</span></span><br><span class="line">                token = tokenizer(content) <span class="comment"># 按空格或字符来分割句子</span></span><br><span class="line">                seq_len = len(token)  <span class="comment"># 得到分割后的元素数量</span></span><br><span class="line">                <span class="keyword">if</span> pad_size: <span class="comment"># 如果有指定填充长度</span></span><br><span class="line">                    <span class="keyword">if</span> len(token) &lt; pad_size:</span><br><span class="line">                        token.extend([PAD] * (pad_size - len(token))) <span class="comment">#padding填充</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        token = token[:pad_size] <span class="comment"># 直接截断至填充长度</span></span><br><span class="line">                        seq_len = pad_size  <span class="comment"># 更新元素数量</span></span><br><span class="line">                <span class="comment"># word to id</span></span><br><span class="line">                <span class="keyword">for</span> word <span class="keyword">in</span> token:</span><br><span class="line">                    <span class="comment"># 拿到该元素在词表中的序号，然后将这个序号添加到words_line中。如果该元素不在词表中，则填入'&lt;UNK&gt;'（未知字）的序号</span></span><br><span class="line">                    words_line.append(vocab.get(word, vocab.get(UNK)))</span><br><span class="line"></span><br><span class="line">                <span class="comment"># fasttext ngram</span></span><br><span class="line">                buckets = config.n_gram_vocab</span><br><span class="line">                bigram = []</span><br><span class="line">                trigram = []</span><br><span class="line">                <span class="comment"># ------ngram------</span></span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(pad_size):</span><br><span class="line">                    bigram.append(biGramHash(words_line, i, buckets))</span><br><span class="line">                    trigram.append(triGramHash(words_line, i, buckets))</span><br><span class="line">                <span class="comment"># -----------------</span></span><br><span class="line">                <span class="comment"># 在contents中存入一个元组，元组的内容为（words_line，数字标签，元素数量，bigram，trigram）</span></span><br><span class="line">                contents.append((words_line, int(label), seq_len, bigram, trigram))</span><br><span class="line">        <span class="keyword">return</span> contents  <span class="comment"># [([...], 0), ([...], 1), ...]</span></span><br><span class="line">    train = load_dataset(config.train_path, config.pad_size)</span><br><span class="line">    dev = load_dataset(config.dev_path, config.pad_size)</span><br><span class="line">    test = load_dataset(config.test_path, config.pad_size)</span><br><span class="line">    <span class="keyword">return</span> vocab, train, dev, test</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DatasetIterater</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">      根据数据集产生batch</span></span><br><span class="line"><span class="string">      这里需要注意的是，在_to_tensor()中，代码把batch中的数据处理成了`(x, seq_len), y`的形式</span></span><br><span class="line"><span class="string">      其中x是words_line，seq_len是pad前的长度(超过pad_size的设为pad_size)，y是数据标签</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># 这里的batches就是经过build_dataset()中的load_dataset()处理后得到的contents：(words_line, int(label), seq_len, bigram, trigram)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, batches, batch_size, device)</span>:</span></span><br><span class="line">        self.batch_size = batch_size <span class="comment"># batch的容量（一次进多少个句子）</span></span><br><span class="line">        self.batches = batches  <span class="comment"># 数据集</span></span><br><span class="line">        self.n_batches = len(batches) // batch_size <span class="comment"># 数据集大小整除batch容量</span></span><br><span class="line">        self.residue = <span class="literal">False</span>  <span class="comment"># 记录batch数量是否为整数，false代表可以，true代表不可以，residuere是‘剩余物，残渣'的意思</span></span><br><span class="line">        <span class="keyword">if</span> len(batches) % self.n_batches != <span class="number">0</span>:</span><br><span class="line">            self.residue = <span class="literal">True</span></span><br><span class="line">        self.index = <span class="number">0</span> <span class="comment"># 迭代用的索引</span></span><br><span class="line">        self.device = device</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_to_tensor</span><span class="params">(self, datas)</span>:</span></span><br><span class="line">        <span class="comment"># xx = [xxx[2] for xxx in datas]</span></span><br><span class="line">        <span class="comment"># indexx = np.argsort(xx)[::-1]</span></span><br><span class="line">        <span class="comment"># datas = np.array(datas)[indexx]</span></span><br><span class="line">        x = torch.LongTensor([_[<span class="number">0</span>] <span class="keyword">for</span> _ <span class="keyword">in</span> datas]).to(self.device) <span class="comment"># 句子words_line</span></span><br><span class="line">        y = torch.LongTensor([_[<span class="number">1</span>] <span class="keyword">for</span> _ <span class="keyword">in</span> datas]).to(self.device) <span class="comment"># 标签</span></span><br><span class="line">        bigram = torch.LongTensor([_[<span class="number">3</span>] <span class="keyword">for</span> _ <span class="keyword">in</span> datas]).to(self.device)</span><br><span class="line">        trigram = torch.LongTensor([_[<span class="number">4</span>] <span class="keyword">for</span> _ <span class="keyword">in</span> datas]).to(self.device)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># pad前的长度(超过pad_size的设为pad_size，未超过的为原seq_size不变)</span></span><br><span class="line">        seq_len = torch.LongTensor([_[<span class="number">2</span>] <span class="keyword">for</span> _ <span class="keyword">in</span> datas]).to(self.device)</span><br><span class="line">        <span class="keyword">return</span> (x, seq_len, bigram, trigram), y</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.residue <span class="keyword">and</span> self.index == self.n_batches: <span class="comment"># 如果batch外还剩下一点句子，并且迭代到了最后一个batch</span></span><br><span class="line">            batches = self.batches[self.index * self.batch_size: len(self.batches)] <span class="comment"># 直接拿出剩下的所有数据</span></span><br><span class="line">            self.index += <span class="number">1</span></span><br><span class="line">            batches = self._to_tensor(batches)</span><br><span class="line">            <span class="keyword">return</span> batches</span><br><span class="line"></span><br><span class="line">        <span class="keyword">elif</span> self.index &gt;= self.n_batches:</span><br><span class="line">            self.index = <span class="number">0</span></span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line">        <span class="keyword">else</span>: <span class="comment"># 迭代器的入口，刚开始self.index是0，肯定小于self.n_batches</span></span><br><span class="line">            batches = self.batches[self.index * self.batch_size: (self.index + <span class="number">1</span>) * self.batch_size] <span class="comment"># 正常取一个batch的数据</span></span><br><span class="line">            self.index += <span class="number">1</span></span><br><span class="line">            batches = self._to_tensor(batches) <span class="comment"># 转化为tensor</span></span><br><span class="line">            <span class="keyword">return</span> batches</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.residue:</span><br><span class="line">            <span class="keyword">return</span> self.n_batches + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.n_batches</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_iterator</span><span class="params">(dataset, config)</span>:</span>  <span class="comment"># 这里的dataset是经过build_dataset()处理后得到的数据（vocab, train, dev, test）</span></span><br><span class="line">    iter = DatasetIterater(dataset, config.batch_size, config.device)</span><br><span class="line">    <span class="keyword">return</span> iter</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_time_dif</span><span class="params">(start_time)</span>:</span></span><br><span class="line">    <span class="string">"""获取已使用时间"""</span></span><br><span class="line">    end_time = time.time()</span><br><span class="line">    time_dif = end_time - start_time</span><br><span class="line">    <span class="keyword">return</span> timedelta(seconds=int(round(time_dif)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="string">'''提取预训练词向量'''</span></span><br><span class="line">    vocab_dir = <span class="string">"./THUCNews/data/vocab.pkl"</span></span><br><span class="line">    pretrain_dir = <span class="string">"./THUCNews/data/sgns.sogou.char"</span></span><br><span class="line">    emb_dim = <span class="number">300</span></span><br><span class="line">    filename_trimmed_dir = <span class="string">"./THUCNews/data/vocab.embedding.sougou"</span></span><br><span class="line">    word_to_id = pkl.load(open(vocab_dir, <span class="string">'rb'</span>))</span><br><span class="line">    embeddings = np.random.rand(len(word_to_id), emb_dim)</span><br><span class="line">    f = open(pretrain_dir, <span class="string">"r"</span>, encoding=<span class="string">'UTF-8'</span>)</span><br><span class="line">    <span class="keyword">for</span> i, line <span class="keyword">in</span> enumerate(f.readlines()):</span><br><span class="line">        <span class="comment"># if i == 0:  # 若第一行是标题，则跳过</span></span><br><span class="line">        <span class="comment">#     continue</span></span><br><span class="line">        lin = line.strip().split(<span class="string">" "</span>)</span><br><span class="line">        <span class="keyword">if</span> lin[<span class="number">0</span>] <span class="keyword">in</span> word_to_id:</span><br><span class="line">            idx = word_to_id[lin[<span class="number">0</span>]]</span><br><span class="line">            emb = [float(x) <span class="keyword">for</span> x <span class="keyword">in</span> lin[<span class="number">1</span>:<span class="number">301</span>]]</span><br><span class="line">            embeddings[idx] = np.asarray(emb, dtype=<span class="string">'float32'</span>)</span><br><span class="line">    f.close()</span><br><span class="line">    np.savez_compressed(filename_trimmed_dir, embeddings=embeddings)</span><br></pre></td></tr></table></figure>

<h1 id="train-eval-py"><a href="#train-eval-py" class="headerlink" title="train_eval.py"></a>train_eval.py</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding: UTF-8</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> metrics</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> utils <span class="keyword">import</span> get_time_dif</span><br><span class="line"><span class="keyword">from</span> tensorboardX <span class="keyword">import</span> SummaryWriter</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 权重初始化，默认xavier（如果不初始化，则默认的随机权重会特别大，对模型训练造成影响）</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init_network</span><span class="params">(model, method=<span class="string">'xavier'</span>, exclude=<span class="string">'embedding'</span>, seed=<span class="number">123</span>)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> name, w <span class="keyword">in</span> model.named_parameters(): <span class="comment"># 迭代网络中所有可训练的参数</span></span><br><span class="line">        <span class="keyword">if</span> exclude <span class="keyword">not</span> <span class="keyword">in</span> name:  <span class="comment"># 排除名字中包含指定关键词的参数（默认为'embedding'）</span></span><br><span class="line">            <span class="keyword">if</span> <span class="string">'weight'</span> <span class="keyword">in</span> name: <span class="comment"># 对权重进行初始化</span></span><br><span class="line">                <span class="keyword">if</span> method == <span class="string">'xavier'</span>:</span><br><span class="line">                    nn.init.xavier_normal_(w) <span class="comment"># 调用不同的初始化方法</span></span><br><span class="line">                <span class="keyword">elif</span> method == <span class="string">'kaiming'</span>:</span><br><span class="line">                    nn.init.kaiming_normal_(w)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    nn.init.normal_(w)</span><br><span class="line">            <span class="keyword">elif</span> <span class="string">'bias'</span> <span class="keyword">in</span> name: <span class="comment"># 对偏置进行初始化</span></span><br><span class="line">                nn.init.constant_(w, <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">else</span>: <span class="comment"># 跳过除权重和偏置外的其他参数</span></span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span><span class="params">(config, model, train_iter, dev_iter, test_iter)</span>:</span></span><br><span class="line">    start_time = time.time()</span><br><span class="line">    model.train() <span class="comment"># model.train()将启用BatchNormalization和Dropout，相应的，model.eval()则不启用BatchNormalization和Dropout</span></span><br><span class="line">    optimizer = torch.optim.Adam(model.parameters(), lr=config.learning_rate) <span class="comment"># 指定优化方法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 学习率指数衰减，每次epoch：学习率 = gamma * 学习率</span></span><br><span class="line">    <span class="comment"># scheduler = torch.optim.lr_scheduler.ExponentialLR(optimizer, gamma=0.9)</span></span><br><span class="line">    total_batch = <span class="number">0</span>  <span class="comment"># 记录进行到多少batch</span></span><br><span class="line">    dev_best_loss = float(<span class="string">'inf'</span>)</span><br><span class="line">    last_improve = <span class="number">0</span>  <span class="comment"># 记录上次验证集loss下降的batch数</span></span><br><span class="line">    flag = <span class="literal">False</span>  <span class="comment"># 记录是否很久没有效果提升</span></span><br><span class="line">    writer = SummaryWriter(log_dir=config.log_path + <span class="string">'/'</span> + time.strftime(<span class="string">'%m-%d_%H.%M'</span>, time.localtime()))</span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> range(config.num_epochs):</span><br><span class="line">        print(<span class="string">'Epoch [&#123;&#125;/&#123;&#125;]'</span>.format(epoch + <span class="number">1</span>, config.num_epochs))</span><br><span class="line">        <span class="comment"># scheduler.step() # 学习率衰减</span></span><br><span class="line">        <span class="keyword">for</span> i, (trains, labels) <span class="keyword">in</span> enumerate(train_iter):</span><br><span class="line">            outputs = model(trains)</span><br><span class="line">            model.zero_grad()</span><br><span class="line">            loss = F.cross_entropy(outputs, labels)</span><br><span class="line">            loss.backward()</span><br><span class="line">            optimizer.step()</span><br><span class="line">            <span class="keyword">if</span> total_batch % <span class="number">100</span> == <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># 每多少轮输出在训练集和验证集上的效果</span></span><br><span class="line">                true = labels.data.cpu() <span class="comment"># 从cpu tensor中取出标签数据</span></span><br><span class="line">                predic = torch.max(outputs.data, <span class="number">1</span>)[<span class="number">1</span>].cpu() <span class="comment"># 返回每一行中最大值的列索引</span></span><br><span class="line">                train_acc = metrics.accuracy_score(true, predic) <span class="comment"># 计算这个batch的分类准确率</span></span><br><span class="line">                dev_acc, dev_loss = evaluate(config, model, dev_iter) <span class="comment"># 计算开发集上的准确率和训练误差</span></span><br><span class="line">                <span class="keyword">if</span> dev_loss &lt; dev_best_loss:  <span class="comment"># 使用开发集判断模型性能是否提升</span></span><br><span class="line">                    dev_best_loss = dev_loss</span><br><span class="line">                    torch.save(model.state_dict(), config.save_path)</span><br><span class="line">                    improve = <span class="string">'*'</span></span><br><span class="line">                    last_improve = total_batch</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    improve = <span class="string">''</span></span><br><span class="line">                time_dif = get_time_dif(start_time)</span><br><span class="line">                msg = <span class="string">'Iter: &#123;0:&gt;6&#125;,  Train Loss: &#123;1:&gt;5.2&#125;,  Train Acc: &#123;2:&gt;6.2%&#125;,  Val Loss: &#123;3:&gt;5.2&#125;,  Val Acc: &#123;4:&gt;6.2%&#125;,  Time: &#123;5&#125; &#123;6&#125;'</span></span><br><span class="line">                print(msg.format(total_batch, loss.item(), train_acc, dev_loss, dev_acc, time_dif, improve))</span><br><span class="line">                writer.add_scalar(<span class="string">"loss/train"</span>, loss.item(), total_batch)</span><br><span class="line">                writer.add_scalar(<span class="string">"loss/dev"</span>, dev_loss, total_batch)</span><br><span class="line">                writer.add_scalar(<span class="string">"acc/train"</span>, train_acc, total_batch)</span><br><span class="line">                writer.add_scalar(<span class="string">"acc/dev"</span>, dev_acc, total_batch)</span><br><span class="line">                model.train()</span><br><span class="line">            total_batch += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> total_batch - last_improve &gt; config.require_improvement:</span><br><span class="line">                <span class="comment"># 验证集loss超过1000batch没下降，结束训练</span></span><br><span class="line">                <span class="comment"># 开发集loss超过一定数量的batch没下降，则结束训练</span></span><br><span class="line">                print(<span class="string">"No optimization for a long time, auto-stopping..."</span>)</span><br><span class="line">                flag = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> flag:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    writer.close()</span><br><span class="line">    test(config, model, test_iter)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(config, model, test_iter)</span>:</span></span><br><span class="line">    <span class="comment"># test</span></span><br><span class="line">    model.load_state_dict(torch.load(config.save_path))</span><br><span class="line">    model.eval()</span><br><span class="line">    start_time = time.time()</span><br><span class="line">    test_acc, test_loss, test_report, test_confusion = evaluate(config, model, test_iter, test=<span class="literal">True</span>)</span><br><span class="line">    msg = <span class="string">'Test Loss: &#123;0:&gt;5.2&#125;,  Test Acc: &#123;1:&gt;6.2%&#125;'</span></span><br><span class="line">    print(msg.format(test_loss, test_acc))</span><br><span class="line">    print(<span class="string">"Precision, Recall and F1-Score..."</span>)</span><br><span class="line">    print(test_report)</span><br><span class="line">    print(<span class="string">"Confusion Matrix..."</span>)</span><br><span class="line">    print(test_confusion)</span><br><span class="line">    time_dif = get_time_dif(start_time)</span><br><span class="line">    print(<span class="string">"Time usage:"</span>, time_dif)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">evaluate</span><span class="params">(config, model, data_iter, test=False)</span>:</span></span><br><span class="line">    model.eval() <span class="comment"># 不启用BatchNormalization和Dropout</span></span><br><span class="line">    loss_total = <span class="number">0</span></span><br><span class="line">    predict_all = np.array([], dtype=int)</span><br><span class="line">    labels_all = np.array([], dtype=int)</span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():  <span class="comment"># 不追踪梯度</span></span><br><span class="line">        <span class="keyword">for</span> texts, labels <span class="keyword">in</span> data_iter:  <span class="comment"># 对数据集中的每一组数据</span></span><br><span class="line">            outputs = model(texts)  <span class="comment"># 使用模型进行预测</span></span><br><span class="line">            loss = F.cross_entropy(outputs, labels) <span class="comment"># 计算模型损失</span></span><br><span class="line">            loss_total += loss <span class="comment"># 累加模型损失</span></span><br><span class="line">            labels = labels.data.cpu().numpy()</span><br><span class="line">            predic = torch.max(outputs.data, <span class="number">1</span>)[<span class="number">1</span>].cpu().numpy()</span><br><span class="line">            labels_all = np.append(labels_all, labels) <span class="comment"># 记录标签</span></span><br><span class="line">            predict_all = np.append(predict_all, predic) <span class="comment"># 记录预测结果</span></span><br><span class="line"></span><br><span class="line">    acc = metrics.accuracy_score(labels_all, predict_all) <span class="comment"># 计算分类误差</span></span><br><span class="line">    <span class="keyword">if</span> test:</span><br><span class="line">        report = metrics.classification_report(labels_all, predict_all, target_names=config.class_list, digits=<span class="number">4</span>)</span><br><span class="line">        confusion = metrics.confusion_matrix(labels_all, predict_all)</span><br><span class="line">        <span class="keyword">return</span> acc, loss_total / len(data_iter), report, confusion</span><br><span class="line">    <span class="keyword">return</span> acc, loss_total / len(data_iter) <span class="comment"># 返回分类误差和平均模型损失</span></span><br></pre></td></tr></table></figure>
<h1 id="FastText模型"><a href="#FastText模型" class="headerlink" title="FastText模型"></a>FastText模型</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding: UTF-8</span></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Config</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"""配置参数"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, dataset, embedding)</span>:</span></span><br><span class="line">        self.model_name = <span class="string">'FastText'</span></span><br><span class="line">        self.train_path = dataset + <span class="string">'/data/train.txt'</span>                                <span class="comment"># 训练集</span></span><br><span class="line">        self.dev_path = dataset + <span class="string">'/data/dev.txt'</span>                                    <span class="comment"># 验证集</span></span><br><span class="line">        self.test_path = dataset + <span class="string">'/data/test.txt'</span>                                  <span class="comment"># 测试集</span></span><br><span class="line">        self.class_list = [x.strip() <span class="keyword">for</span> x <span class="keyword">in</span> open(</span><br><span class="line">            dataset + <span class="string">'/data/class.txt'</span>, encoding=<span class="string">'utf-8'</span>).readlines()]              <span class="comment"># 类别名单</span></span><br><span class="line">        self.vocab_path = dataset + <span class="string">'/data/vocab.pkl'</span>                                <span class="comment"># 词表</span></span><br><span class="line">        self.save_path = dataset + <span class="string">'/saved_dict/'</span> + self.model_name + <span class="string">'.ckpt'</span>        <span class="comment"># 模型训练结果</span></span><br><span class="line">        self.log_path = dataset + <span class="string">'/log/'</span> + self.model_name</span><br><span class="line">        self.embedding_pretrained = torch.tensor(</span><br><span class="line">            np.load(dataset + <span class="string">'/data/'</span> + embedding)[<span class="string">"embeddings"</span>].astype(<span class="string">'float32'</span>))\</span><br><span class="line">            <span class="keyword">if</span> embedding != <span class="string">'random'</span> <span class="keyword">else</span> <span class="literal">None</span>                                       <span class="comment"># 预训练词向量</span></span><br><span class="line">        self.device = torch.device(<span class="string">'cuda'</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">'cpu'</span>)   <span class="comment"># 设备</span></span><br><span class="line"></span><br><span class="line">        self.dropout = <span class="number">0.5</span>                                              <span class="comment"># 随机失活</span></span><br><span class="line">        self.require_improvement = <span class="number">1000</span>                                 <span class="comment"># 若超过1000batch效果还没提升，则提前结束训练</span></span><br><span class="line">        self.num_classes = len(self.class_list)                         <span class="comment"># 类别数</span></span><br><span class="line">        self.n_vocab = <span class="number">0</span>                                                <span class="comment"># 词表大小，在运行时赋值</span></span><br><span class="line">        self.num_epochs = <span class="number">20</span>                                            <span class="comment"># epoch数</span></span><br><span class="line">        self.batch_size = <span class="number">128</span>                                           <span class="comment"># mini-batch大小</span></span><br><span class="line">        self.pad_size = <span class="number">32</span>                                              <span class="comment"># 每句话处理成的长度(短填长切)</span></span><br><span class="line">        self.learning_rate = <span class="number">1e-3</span>                                       <span class="comment"># 学习率</span></span><br><span class="line">        self.embed = self.embedding_pretrained.size(<span class="number">1</span>)\</span><br><span class="line">            <span class="keyword">if</span> self.embedding_pretrained <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">else</span> <span class="number">300</span>           <span class="comment"># 字向量维度</span></span><br><span class="line">        self.hidden_size = <span class="number">256</span>                                          <span class="comment"># 隐藏层大小</span></span><br><span class="line">        self.n_gram_vocab = <span class="number">250499</span>                                      <span class="comment"># ngram 词表大小</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">'''Bag of Tricks for Efficient Text Classification'''</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Model</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, config)</span>:</span></span><br><span class="line">        super(Model, self).__init__()</span><br><span class="line">        <span class="keyword">if</span> config.embedding_pretrained <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            self.embedding = nn.Embedding.from_pretrained(config.embedding_pretrained, freeze=<span class="literal">False</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.embedding = nn.Embedding(config.n_vocab, config.embed, padding_idx=config.n_vocab - <span class="number">1</span>)</span><br><span class="line">        self.embedding_ngram2 = nn.Embedding(config.n_gram_vocab, config.embed)</span><br><span class="line">        self.embedding_ngram3 = nn.Embedding(config.n_gram_vocab, config.embed)</span><br><span class="line">        self.dropout = nn.Dropout(config.dropout)</span><br><span class="line">        self.fc1 = nn.Linear(config.embed * <span class="number">3</span>, config.hidden_size)</span><br><span class="line">        <span class="comment"># self.dropout2 = nn.Dropout(config.dropout)</span></span><br><span class="line">        self.fc2 = nn.Linear(config.hidden_size, config.num_classes)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line"></span><br><span class="line">        out_word = self.embedding(x[<span class="number">0</span>])</span><br><span class="line">        out_bigram = self.embedding_ngram2(x[<span class="number">2</span>])</span><br><span class="line">        out_trigram = self.embedding_ngram3(x[<span class="number">3</span>])</span><br><span class="line">        out = torch.cat((out_word, out_bigram, out_trigram), <span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">        out = out.mean(dim=<span class="number">1</span>)</span><br><span class="line">        out = self.dropout(out)</span><br><span class="line">        out = self.fc1(out)</span><br><span class="line">        out = F.relu(out)</span><br><span class="line">        out = self.fc2(out)</span><br><span class="line">        <span class="keyword">return</span> out</span><br></pre></td></tr></table></figure>

<h1 id="runFastText-py主函数"><a href="#runFastText-py主函数" class="headerlink" title="runFastText.py主函数"></a>runFastText.py主函数</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding: UTF-8</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> train_eval <span class="keyword">import</span> train, init_network</span><br><span class="line"><span class="keyword">from</span> importlib <span class="keyword">import</span> import_module</span><br><span class="line"><span class="keyword">from</span> utils_fastTextTest <span class="keyword">import</span> build_dataset, build_iterator, get_time_dif</span><br><span class="line"><span class="comment"># import argparse</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># parser = argparse.ArgumentParser(description='Chinese Text Classification')</span></span><br><span class="line"><span class="comment"># parser.add_argument('--model', type=str, required=True, help='choose a model: TextCNN, TextRNN, FastText, TextRCNN, TextRNN_Att, DPCNN, Transformer')</span></span><br><span class="line"><span class="comment"># parser.add_argument('--embedding', default='pre_trained', type=str, help='random or pre_trained')</span></span><br><span class="line"><span class="comment"># parser.add_argument('--word', default=False, type=bool, help='True for word, False for char')</span></span><br><span class="line"><span class="comment"># args = parser.parse_args()</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    dataset = <span class="string">'THUCNews'</span>  <span class="comment"># 数据集</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 搜狗新闻:embedding_SougouNews.npz, 腾讯:embedding_Tencent.npz, 随机初始化:random</span></span><br><span class="line">    embedding = <span class="string">'embedding_SougouNews.npz'</span></span><br><span class="line">    model_name = <span class="string">'FastText'</span>  <span class="comment"># 'TextRCNN'  # TextCNN, TextRNN, FastText, TextRCNN, TextRNN_Att, DPCNN, Transformer</span></span><br><span class="line"></span><br><span class="line">    x = import_module(<span class="string">'models.'</span> + model_name)</span><br><span class="line">    config = x.Config(dataset, embedding) <span class="comment"># 加载神经网络模型的参数</span></span><br><span class="line">    np.random.seed(<span class="number">1</span>)</span><br><span class="line">    torch.manual_seed(<span class="number">1</span>)</span><br><span class="line">    torch.cuda.manual_seed_all(<span class="number">1</span>)</span><br><span class="line">    torch.backends.cudnn.deterministic = <span class="literal">True</span>  <span class="comment"># 固定随机因子，保证每次结果一样</span></span><br><span class="line"></span><br><span class="line">    start_time = time.time()</span><br><span class="line">    print(<span class="string">"Loading data..."</span>)</span><br><span class="line">    vocab, train_data, dev_data, test_data = build_dataset(config, <span class="literal">False</span>)</span><br><span class="line">    train_iter = build_iterator(train_data, config)</span><br><span class="line">    dev_iter = build_iterator(dev_data, config)</span><br><span class="line">    test_iter = build_iterator(test_data, config)</span><br><span class="line">    time_dif = get_time_dif(start_time)</span><br><span class="line">    print(<span class="string">"Time usage:"</span>, time_dif)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># train</span></span><br><span class="line">    config.n_vocab = len(vocab)</span><br><span class="line">    model = x.Model(config).to(config.device)</span><br><span class="line">    <span class="keyword">if</span> model_name != <span class="string">'Transformer'</span>:</span><br><span class="line">        init_network(model)</span><br><span class="line">    print(model.parameters)</span><br><span class="line">    train(config, model, train_iter, dev_iter, test_iter)</span><br></pre></td></tr></table></figure>
<h1 id="训练结果"><a href="#训练结果" class="headerlink" title="训练结果"></a>训练结果</h1><p>因为无GPU，代码中添加了Ngram图，训练较慢。截图仅有两个epoch。<br>参考结果：不加N-Gram信息，就是词袋模型，准确率89.59%，加上2-gram和3-gram后准确率92.23%。<br><img src="https://img-blog.csdnimg.cn/20200612181905614.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQzMzk2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>[video(video-TQauKbQ1-1591957225364)(type-edu_course)(url-<a href="https://edu.csdn.net/course/blogPlay?goods_id=17131&amp;blog_creator=weixin_43433969&amp;marketing_id=141)(image-https://img-bss.csdnimg.cn/20191229134635364.jpg)(title-PyTorch从入门到实战一次学会)]" target="_blank" rel="noopener">https://edu.csdn.net/course/blogPlay?goods_id=17131&amp;blog_creator=weixin_43433969&amp;marketing_id=141)(image-https://img-bss.csdnimg.cn/20191229134635364.jpg)(title-PyTorch从入门到实战一次学会)]</a></p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>1.<a href="https://zhuanlan.zhihu.com/p/73176084" target="_blank" rel="noopener">中文文本分类 pytorch实现</a><br>2.<a href="https://www.cnblogs.com/lokvahkoor/p/12334207.html" target="_blank" rel="noopener">中文文本分类代码分析</a><br>3.<a href="https://blog.csdn.net/qq_43019117/article/details/82770124" target="_blank" rel="noopener">FastText中词序的处理</a></p>
]]></content>
      <tags>
        <tag>文本分类</tag>
      </tags>
  </entry>
  <entry>
    <title>&lt;springboot&gt;springboot获取参数集中方式</title>
    <url>/2020/05/04/springboot%E8%8E%B7%E5%8F%96%E5%8F%82%E6%95%B0%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p>1、通过json获取参数<br>2、请求路径参数@PathVariable<br>3、@RequestParam的使用<br>4、@RequestBody</p>
<a id="more"></a>
<h1 id="1-通过json获取参数"><a href="#1-通过json获取参数" class="headerlink" title="1 通过json获取参数"></a>1 通过json获取参数</h1><p>通过浏览器的url为后端控制层函数赋值,通过注解@responseBody 将java对象转换为json格式的数据返回给前端页面。</p>
<p><strong>@ResponseBody</strong>注解的作用是将controller的方法返回的对象通过适当的转换器转换为指定的格式之后，写入到response对象的body区，通常用来返回JSON数据或者是XML数据。一般在异步获取数据时使用【也就是AJAX】。</p>
<p><strong>后端Controller层代码如下：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/param"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;String,Object&gt; <span class="title">demo1</span><span class="params">(String name,<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">	Map&lt;String,Object&gt; paramMap=<span class="keyword">new</span> HashMap&lt;String,Object&gt;();</span><br><span class="line">	paramMap.put(<span class="string">"name"</span>,name);</span><br><span class="line">	paramMap.put(<span class="string">"age"</span>,age);</span><br><span class="line">	<span class="keyword">return</span> paramMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>前端浏览器请求为：</strong><br> <a href="http://localhost:8080/param?name=zhangsan&amp;age=14" target="_blank" rel="noopener">http://localhost:8080/param?name=zhangsan&amp;age=14</a></p>
<p> <strong>之后前端返回的Json数据为</strong>：<br> {“name”：zhangsan，“age”：14}</p>
<h1 id="2-请求路径参数-PathVariable"><a href="#2-请求路径参数-PathVariable" class="headerlink" title="2  请求路径参数@PathVariable"></a>2  请求路径参数@PathVariable</h1><p>获取路径参数。即前端浏览器发起url/{id}请求的这种形式。<br>后端Controller层代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/param/&#123;name&#125;/&#123;age&#125;"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;String,Object&gt; <span class="title">demo2</span><span class="params">(@PathVariable(<span class="string">"name"</span>)</span> String name , @<span class="title">pathVariable</span><span class="params">(<span class="string">"age"</span>)</span> <span class="keyword">int</span> age)</span>&#123;</span><br><span class="line">	Map&lt;String,Object&gt; paramMap=<span class="keyword">new</span> HashMap&lt;String,Object&gt;();</span><br><span class="line">	paramMap.put(<span class="string">"name"</span>,name);</span><br><span class="line">	paramMap.put(<span class="string">"age"</span>,age);</span><br><span class="line">	<span class="keyword">return</span> paramMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中@PathVariable(value = “name”, required = false)中有value和required两个参数，第一个即为指定传递的参数，第二个为该参数是否必须，若为false则可以在前端不传入该参数，默认为null空值。</p>
<h1 id="3-RequestParam的使用"><a href="#3-RequestParam的使用" class="headerlink" title="3 @RequestParam的使用"></a>3 @RequestParam的使用</h1><p>使用@RequestParm用于绑定controller上的参数,可以是多个参数，也可以是一个Map集合，GET，POST均可；</p>
<p><strong>语法：</strong>@RequestParam(value=”参数名”,required=”true/false”,defaultValue=””)<br><strong>value</strong>：参数名<br><strong>required</strong>：是否包含该参数，默认为true，表示该请求路径中必须包含该参数，如果不包含就报错。<br><strong>defaultValue</strong>：默认参数值，如果设置了该值，required=true将失效，自动为false,如果没有传该参数，就使用默认值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/param/&#123;name&#125;/&#123;age&#125;"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;String,Object&gt; <span class="title">demo2</span><span class="params">(@RequestParam(<span class="string">"name"</span>)</span> String name , @<span class="title">RequestParam</span><span class="params">(<span class="string">"age"</span>)</span> <span class="keyword">int</span> age)</span>&#123;</span><br><span class="line">	Map&lt;String,Object&gt; paramMap=<span class="keyword">new</span> HashMap&lt;String,Object&gt;();</span><br><span class="line">	paramMap.put(<span class="string">"name"</span>,name);</span><br><span class="line">	paramMap.put(<span class="string">"age"</span>,age);</span><br><span class="line">	<span class="keyword">return</span> paramMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>@RequestParam 和@PathVariable 之间的区别：</strong><br>        @RequestParam 用来获得静态URL中传入的参数，@PathVariable 用来获得动态URL中的参数</p>
<h1 id="4-RequestBody"><a href="#4-RequestBody" class="headerlink" title="4 @RequestBody"></a>4 @RequestBody</h1><p>@RequestBody绑定的是一个对象实体，将 HTTP 请求正文插入方法中，使用适合的 HttpMessageConverter 将请求体写入某个对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1) 该注解用于读取Request请求的body部分数据，使用系统默认配置的HttpMessageConverter进行解析，然后把相应的数据绑定</span><br><span class="line">    到要返回的对象上； </span><br><span class="line">2) 再把HttpMessageConverter返回的对象数据绑定到 controller中方法的参数上。</span><br></pre></td></tr></table></figure>
<p><strong>使用方法：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"user/login"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="comment">// 将ajax（datas）发出的请求写入 User 对象中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">login</span><span class="params">(@RequestBody User user)</span> </span>&#123;   </span><br><span class="line"><span class="comment">// 这样就不会再被解析为跳转路径，而是直接将user对象写入 HTTP 响应正文中</span></span><br><span class="line">    <span class="keyword">return</span> user;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(value = <span class="string">"requestBody"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">requestBody</span><span class="params">(@RequestBody  User user)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"user:"</span>+user.getName());</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>request的body部分的数据编码格式由header部分的Content-Type指定；</p>
<p>@RequestBody不支持Get请求？（<strong>存疑</strong>）因为get请求没有HttpEntity。</p>
]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title>&lt;学习笔记&gt; word2vec是如何得到向量的（CBOW模型）</title>
    <url>/2020/04/30/word2vec%E6%98%AF%E5%A6%82%E4%BD%95%E5%BE%97%E5%88%B0%E5%90%91%E9%87%8F%E7%9A%84%EF%BC%88CBOW%E6%A8%A1%E5%9E%8B%EF%BC%89/</url>
    <content><![CDATA[<h1 id="学习笔记"><a href="#学习笔记" class="headerlink" title="学习笔记"></a>学习笔记</h1><p>只是自己的学习笔记，只把自己要记忆的知识写下来。<br>简单理解的链接： <a href="https://www.zhihu.com/question/44832436" target="_blank" rel="noopener">word2vec是如何得到向量的</a></p>
<a id="more"></a>

<p><strong>word2vec的准备操作</strong>：中文需要将每句话用工具分词（jieba等）</p>
<p><strong>word2vec的作用</strong>：是将语料库中的词训练出各自的词向量，供NLP其他后续具体任务的使用。</p>
<p><strong>word2vec的处理方法</strong>：两种训练方法<strong>CBOW</strong>模型和<strong>Skip-gram</strong>模型。]</p>
<p><strong>word2vec的算法加速方法</strong>：<strong>Negative Sample</strong>与<strong>Hierarchical Softmax</strong></p>
<blockquote>
<p>1.<strong>CBOW</strong>模型根据中心词W(t)周围的词来预测中心词<br>2.<strong>Skip-gram</strong>模型则根据中心词W(t)来预测周围词</p>
</blockquote>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMyLnpoaW1nLmNvbS84MC92Mi0wZjQzOWUxYmI0NGM3MWM4ZTY5NGNjNjVjYjUwOTI2M19oZC5qcGc?x-oss-process=image/format,png" alt="在这里插入图片描述"></p>
<blockquote>
<p>上图中两个矩阵是CBOW模型要不断学习迭代的:$W_{v<em>n}$与$W_{n</em>v}^{‘}$</p>
</blockquote>
<p><strong>输入层</strong>是被预测那个词的上下文词的one-hot向量（该向量是针对语料库中所有分词的）</p>
<p><strong>第一个权重矩阵</strong>：$W_{v<em>n}$为输入权重矩阵，（V</em>N矩阵，V为自己设定的数，一般为50-300，好像是，N为one-hot向量的维数，初始化权重矩阵W）。<strong>这里的V与N具体指代的内容存疑。</strong></p>
<p><strong>接下来的步骤</strong>：将上下文单词的one-hot向量分别与输入权重矩阵相乘，得到第一次迭代的词向量（后面需要不断的迭代词向量，通过学习输入权重矩阵）；将所有上下文“词向量”相加取平均值即可得到神经网络中间层。</p>
<p><strong>第二个权重矩阵</strong>：$W_{n*v}^{‘}$为输出权重矩阵，这个矩阵中N为one-hot向量的维度，v为自己取得数字。</p>
<p><strong>接下来的步骤</strong>：运用softmax将预测结果规整到一定范围内。这里就可以用到前面提到的两个加速算法了，因为仅仅依靠softmax太慢。</p>
<p><strong>加速算法</strong>：<strong>Negative Sample</strong>与<strong>Hierarchical Softmax</strong></p>
<p>如下图<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWM0LnpoaW1nLmNvbS84MC92Mi0xNzEzNDUwZmEyYTBmMzdjOGNiY2NlNGZmZWYwNGJhYV9oZC5qcGc?x-oss-process=image/format,png" alt="在这里插入图片描述"></p>
<p>最最重要的：<strong>任何一个单词的one-hot表示乘以这个矩阵都将得到自己的word embedding。</strong>（word2vec的目的）</p>
]]></content>
      <tags>
        <tag>word2vec</tag>
      </tags>
  </entry>
  <entry>
    <title>&lt;论文&gt; Unsupervised Machine Translation Using Monolingual Corpora Only</title>
    <url>/2020/04/30/Unsupervised%20Machine%20Translation%20Using%20Monolingual%20Corpora%20Only%EF%BC%9A%E4%BB%85%E4%BD%BF%E7%94%A8%E5%8D%95%E8%AF%AD%E8%AF%AD%E6%96%99%E5%BA%93%E7%9A%84%E6%97%A0%E7%9B%91%E7%9D%A3%E6%9C%BA%E5%99%A8%E7%BF%BB%E8%AF%91/</url>
    <content><![CDATA[<p>论文名称：Unsupervised Machine Translation Using Monolingual Corpora Only<br>作者： Guillaume Lample / Ludovic Denoyer /Marc Aurelio Ranzato<br>发表时间：2018/4/30<br>论文链接：<a href="https://arxiv.org/pdf/1711.00043v1.pdf" target="_blank" rel="noopener">https://arxiv.org/pdf/1711.00043v1.pdf</a><br>代码链接：<a href="https://github.com/facebookresearch/MUSE" target="_blank" rel="noopener">https://github.com/facebookresearch/MUSE</a> 以及 <a href="https://github.com/facebookresearch/fastText" target="_blank" rel="noopener">https://github.com/facebookresearch/fastText</a></p>
<a id="more"></a>

<p>发现一篇很详细的翻译笔记：<a href="https://blog.csdn.net/ljp1919/article/details/102728699?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522158599074719726869003034%2522%252C%2522scm%2522%253A%252220140713.130056874..%2522%257D&request_id=158599074719726869003034&biz_id=0&utm_source=distribute.pc_search_result.none-task-blog-all_SOOPENSEARCH-3" target="_blank" rel="noopener">地址</a></p>
<p>在此仅作自己的学习笔记总结：</p>
<h1 id="1-论文概述"><a href="#1-论文概述" class="headerlink" title="1 论文概述"></a>1 论文概述</h1><p><strong>本文目的</strong>：希望不利用平行语料库实现机器翻译，本文提出的模型，仅需要两个语种各自的单语种语料数据集，并将2者映射到同一隐空间中。模型主要是学习通过从共享的隐特征向量空间中重建这两种语种。<br><strong>模型的两个原则</strong>：第一个原则：这个模型必须能够从一个带噪声的输入中重建出一个给定语种的句子，如标准去噪自动编码器。第二个原则：该模型能够在目标域中对带有噪声的翻译句子重建出源句，反之亦然。<br><strong>模型重要思想</strong>：关键思想是在两种语言（或领域）之间建立共同的潜在空间，并通过根据两个原则在两个领域中进行重构来学习翻译：（i）该模型必须能够从特定语言中重构给定语言的句子。 噪声版本，如标准降噪自动编码器中的那样（Vincent等，2008）。 （ii）在目标域中相同句子经过嘈杂翻译的情况下，该模型还学会重建任何源句，反之亦然。 对于（ii），翻译后的句子是通过使用反向翻译程序获得的（Sennrich et al。，2015），即 通过使用学习的模型将源句子翻译到目标域。 除了这些重建目标之外，我们使用对抗性正则化术语来约束源句和目标句的潜在表示形式以使其具有相同的分布，从而该模型尝试欺骗鉴别器，同时对鉴别器进行训练以识别给定潜在句子表示形式的语言（Ganin 等人，2016年）。 然后反复重复此过程，从而产生质量提高的翻译模型。 为了保持我们的方法完全不受监督，我们使用了一个简单的无监督翻译模型来初始化我们的算法，该模型基于一个句子的逐词翻译，并使用源自相同单语数据的双语词典（Conneau et al。，2017）。 通过仅使用单语数据，我们就可以将两种语言的句子编码到相同的特征空间中，并且从那里，我们还可以使用任何一种语言进行解码/翻译； 参见图1的说明：<br><img src="https://img-blog.csdnimg.cn/20200404173425817.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQzMzk2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>x和z分别代表encode和decode两端的输入：<br><img src="https://img-blog.csdnimg.cn/20200404175037569.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQzMzk2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>在本文中，我们注意使用equence-to-sequence模型。 编码器是双向LSTM，它返回隐藏状态序列z =（z1，z2，…，zm）。 在每个步骤中，作为LSTM的解码器将采用先前的隐藏状态，当前字和上下文矢量由编码器状态上的加权总和给出。</p>
<p><strong>方法总览</strong>：给定相同或其他域中相同句子的嘈杂版本，我们通过重构特定域中的句子来训练编码器和解码器。<br><img src="https://img-blog.csdnimg.cn/20200404175833601.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQzMzk2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h1 id="2-模型各个模块"><a href="#2-模型各个模块" class="headerlink" title="2 模型各个模块"></a>2 模型各个模块</h1><p><strong>噪声模型训练</strong>：<strong>如何通过噪声语句训练自动编码</strong><br>本文采用与去噪自编码器(DAE)相似的策略将噪声添加到输入句子中。<br>训练的目标函数为：<br><img src="https://img-blog.csdnimg.cn/20200404180401308.png" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20200404180819755.png" alt="在这里插入图片描述"><br><strong>跨域训练</strong>：<br>如何实现源语句与翻译语句之间 的映射？<br> (1)从源语种中采样出一个句子x，在l2中生成此时的翻译结果。这个 翻译结果是基于当前翻译模型M生成的，所以可以表示为y=M(x)<br>(2)再对该翻译结果y进行加噪，得到corrupted的C(y)。目标是学习能够在C(y)中重建出x的encoder和decoder。所以这里的加噪在C(y)这里。<br>(3)根据C(y)重建x<br>此时的损失目标函数为：<br><img src="https://img-blog.csdnimg.cn/20200404181923118.png" alt="在这里插入图片描述"><br><strong>对抗训练</strong>：还未理解</p>
<p>当 encoder 所输出的特征位于同一个空间而不管输入的句子是何语种时，那么 decoder 就有可能无视encoder中的输入句子而实现decode为特定语种。其实，隐空间就像是一个标准，在这个标准上可以任意转为其他格式(这里特指语种)，而其他语种需要统一转到该隐空间，进行标准统一。</p>
<p>但是需要注意，decoder 在目标域中生成句子时仍然可能有错误的翻译。限制 encoder 在同一特征空间映射两种语言，并不意味着句子之间存在严格的对应关系。所幸的是，前面介绍的公式2中跨域训练的损失减轻了这种担忧。最近关于双语词典的研究表明，这种约束在词级别(word level)上是非常有效的，这表明只要这两种隐表征在特征空间上表现出较强的结构性，那么这种约束在句子层面( sentence level)上也可能有效。</p>
<p><img src="https://img-blog.csdnimg.cn/20200404190059530.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQzMzk2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>下图为本文最重点的图，描述了模型是如何工作的：<br><img src="https://img-blog.csdnimg.cn/20200404184311342.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQzMzk2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>模型主要包含原文重建和译文重建两个部分。图中上面是原文重建部分，使用的是自编码器，输入源语言最后的输出仍然是源语言。下面是译文重建部分，给定源语言之后，先经过M模型翻译为对应的译文，然后经过encoder-decoder模型翻译回原文</p>
<h1 id="3-训练"><a href="#3-训练" class="headerlink" title="3 训练"></a>3 训练</h1><h2 id="3-1-迭代训练"><a href="#3-1-迭代训练" class="headerlink" title="3.1 迭代训练"></a>3.1 迭代训练</h2><p>最终学习算法在算法1中进行了描述，该模型的一般体系结构如图2所示。如前所述，我们的模型依赖于从初始翻译模型M（1）（第3行）开始的迭代算法。根据等式2的跨域损耗函数的需要，此函数用于转换可用的单语数据。在每次迭代中，通过最小化等式4 –的损耗来训练新的编码器和解码器（第7行）。 然后，通过组合生成的编码器和解码器来创建新的翻译模型M（t + 1），然后重复该过程。</p>
<p>为快速启动该过程，M（1）使用学习到的并行词典对每个句子进行逐词翻译，使用Conneau等人提出的仅利用单语数据的无监督方法。<br><img src="https://img-blog.csdnimg.cn/20200404185051800.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQzMzk2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h1 id="4-实验"><a href="#4-实验" class="headerlink" title="4 实验"></a>4 实验</h1><p><strong>数据集</strong>：WMT’14 English-French、WMT’14 English-French、Multi30k-Task1</p>
<h2 id="4-1-Baselines"><a href="#4-1-Baselines" class="headerlink" title="4.1 Baselines"></a>4.1 Baselines</h2><p><strong>Word-by-word translation (WBW)</strong>：逐词翻译系统。该系统对相关语种，比如English-French 性能较好，但是在相距较远的语种如English-German表现较差。</p>
<p><strong>Word reordering (WR)</strong>：WR系统是对WBW的结果用LSTM模型做了一次词序调整。由于难以穷尽一个句子中单词(有些句子单词量大于100个)的全部排列组合，这里仅仅考虑相邻单词之间的互换操作。在实验过程中选择最好的交换，迭代10次。这个baseline仅仅用于 WMT dataset ，这是因为 WMT dataset 有足够多的数据可以训练一个较好的语言模型。</p>
<p><strong>Oracle Word Reordering (OWR)</strong>：使用参考，我们仅使用WBW给出的字词就能产生最佳的生成效果。 这种方法的性能是任何模型都可以完成的，而无需替换单词。</p>
<p><strong>Supervised Learning</strong>：考虑了与我们完全相同的模型，但是在监督下进行训练，在原来的平行句上使用了标准的交叉熵损失。</p>
<h1 id="5-相关工作"><a href="#5-相关工作" class="headerlink" title="5 相关工作"></a>5 相关工作</h1><p>与我们类似的工作是Shen等人的非平行文本样式转换方法。 作者考虑了序列到序列模型，在该模型中，赋予解码器的潜在状态也被馈送到鉴别器。 编码器与解码器一起训练以重建输入，但也愚弄了鉴别器。 作者还发现，训练两个鉴别器（一个用于源，一个用于目标域）是有益的。 然后，他们训练了解码器，以使在特定域中的句子解码过程中，根据各自的区分器无法区分出重复的隐藏状态。<br>在此之前，Hu等人训练了变分自动编码器（VAE），其中解码器输入是非结构化潜在向量的级联，以及表示要生成的句子属性的结构化代码。 鉴别器在解码器的顶部被训练以对所生成句子的标签进行分类，而解码器被训练为满足该鉴别器。 由于解码过程的不可微性，在每个步骤中，其解码器都将在上一步中预测的概率向量作为输入。<br>也许，最相关的先前工作是由He等人完成的。 （2016b），他实际上是直接针对3.2节中提出的模型选择指标进行了优化。 他们的方法的一个缺点（尚未应用到完全无人监督的环境中）是，它需要使用效率非常低的基于强化学习的方法，通过离散预测的顺序向后传播。 在这项工作中，我们改为建议a）使用对称体系结构，以及b）在训练目标与源之间的翻译时将源与目标之间的翻译冻结，反之亦然。通过交替此过程，我们使用完全可区分的模型进行操作，并且我们有效地收敛。</p>
<h1 id="6-总结"><a href="#6-总结" class="headerlink" title="6 总结"></a>6 总结</h1><p>我们提出了一种新的神经机器翻译方法，其中仅使用单语数据集学习翻译模型，而句子或文档之间没有任何对齐。 我们方法的原则是从简单的无监督逐词翻译模型开始，并基于<strong>重构损失</strong>来迭代地改进此模型，<strong>并使用鉴别器来对齐源语言和目标语言的潜在分布</strong>。 我们的实验表明，我们的方法无需任何形式的监督就能学习有效的翻译模型</p>
]]></content>
      <tags>
        <tag>论文</tag>
      </tags>
  </entry>
  <entry>
    <title>&lt;学习笔记&gt; word2vec笔记（Hierarchical Softmax）</title>
    <url>/2020/04/30/word2vec%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0#1Hierarchical%20Softmax/</url>
    <content><![CDATA[<h1 id="word2vec学习笔记-1"><a href="#word2vec学习笔记-1" class="headerlink" title="word2vec学习笔记#1"></a>word2vec学习笔记#1</h1><p>文章来自于<strong><a href="https://www.hankcs.com/nlp/word2vec.html" target="_blank" rel="noopener">码农场</a></strong>大佬的博文，做自己的摘抄笔记。</p>
<a id="more"></a>
<h2 id="word2vec"><a href="#word2vec" class="headerlink" title="word2vec"></a>word2vec</h2><pre><code>word2vec作为神经概率语言模型的输入，其本身其实是神经概率模型的副产品，是为了通
过神经网络学习某个语言模型而产生的中间结果。具体来说，“某个语言模型”指的是
“CBOW”和“Skip-gram”。具体学习过程会用到两个降低复杂度的近似方法——Hierarchical 
Softmax或Negative Sampling。两个模型乘以两种方法，一共有四种实现。</code></pre><h2 id="Hierarchical-Softmax"><a href="#Hierarchical-Softmax" class="headerlink" title="Hierarchical Softmax"></a>Hierarchical Softmax</h2><p><strong>模型共同点</strong></p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly93dzMuc2luYWltZy5jbi9sYXJnZS82Y2JiODY0NWd3MWY1dG8wdXd5ZHNqMjE2aTBpa2RpMy5qcGc?x-oss-process=image/format,png" alt="图一"><br><strong>两种模型的网络结构如下</strong><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly93dzMuc2luYWltZy5jbi9sYXJnZS82Y2JiODY0NWd3MWY1dG82ZTVkOWxqMjE2YzBxa3doay5qcGc?x-oss-process=image/format,png" alt="在这里插入图片描述"><br>上图中w(t)表示句子中t位置处的词语</p>
<h3 id="CBOW"><a href="#CBOW" class="headerlink" title="CBOW"></a>CBOW</h3><p>原理：一种根据上下文词语预测当前空缺位置的概率的模型，如上左图。<br>学习目标是最大化下面的似然函数：<br><img src="https://img-blog.csdnimg.cn/20191212223414310.png" alt="在这里插入图片描述"><br>其中W为语料库中的认一个词。<br><strong>输入层</strong>是上下文的词语的词向量（现在是在训练CBOW模型，词向量只是个副产品，确切来说，是CBOW模型的一个参数。训练开始的时候，词向量是个<strong>随机值</strong>，随着训练的进行不断被更新）。<br><strong>输出层</strong>输出最可能的w。由于语料库中词汇量是固定的|C|个，所以上述过程其实可以看做一个多分类问题。给定特征，从|C|个分类中挑一个。</p>
<p>由上输出层的分析可知，最后是对输出层的数据进行分类，下方用的<strong>Hierarchical Softmax</strong><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly93dzMuc2luYWltZy5jbi9sYXJnZS82Y2JiODY0NWd3MWY1d215NGpkbndqMjE0dzEyYTQydi5qcGc?x-oss-process=image/format,png" alt="在这里插入图片描述"><br>非叶子节点就是一个分类器（感知机），用1或者0来代替分类的结果，每一个叶子节点即为语料库中的一个词语，可以通过上述的概率表述出条件概率   $P(w|context(w))$<br>引入下列符号：<br>1、$p^w$:从根节点到w对应的叶子节点的路径<br>2、$l^w$:路径包含的节点个数<br>3、$P_{1}^{w}$、$P_{2}^{w}$、$P_{3}^{w}$……$P_{l^w}^{w}$：为路径中的各个节点<br>4、$d_{2}^{w}$、$d_{3}^{w}$、$d_{4}^{w}$……$d_{l}^{w}$在零到一范围内，其中$d_{l}^{w}$表示第j个对应的编码（根节点无编码）<br>5、$\Theta _{1}^{w}$、$\Theta _{2}^{w}$、$\Theta _{3}^{w}$……$\Theta _{l^w}^{w}$为路径$p^w$中非叶节点对应的参数向量<br>得w的条件概率：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly93dzQuc2luYWltZy5jbi9sYXJnZS82Y2JiODY0NWd3MWY1d29oazNwaTdqMjBrYTA0MnQ5MS5qcGc?x-oss-process=image/format,png" alt="在这里插入图片描述"><br>从根节点到叶节点经过了 $l^w$-1个节点，编码从下标2开始（根节点无编码），对应的参数向量下标从1开始（根节点为1）。</p>
<p>每一项是一个逻辑斯谛回归：（即为每一个0或者1的选择都有着两个不同的概率，且二者的和为一）<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly93dzIuc2luYWltZy5jbi9sYXJnZS82Y2JiODY0NWd3MWY1d29xNW9lb2pqMjBwbTA1eXQ5YS5qcGc?x-oss-process=image/format,png" alt="在这里插入图片描述"><br>将上式两种情况综合到一个公式中去：（下式中$d_{l}^{w}$有两种取值：0或者1）<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly93dzIuc2luYWltZy5jbi9sYXJnZS82Y2JiODY0NWd3MWY1d293YzJvaTJqMjBxbTAybWpycy5qcGc?x-oss-process=image/format,png" alt="在这里插入图片描述"><br>目标函数取对数似然：（一种结果转化方式？）<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly93dzMuc2luYWltZy5jbi9sYXJnZS82Y2JiODY0NWd3MWY1d295aWt5cDBqMjBmYzAza2dscy5qcGc?x-oss-process=image/format,png" alt="在这里插入图片描述"><br>将上面几个公式结合得到如下：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly93dzQuc2luYWltZy5jbi9sYXJnZS82Y2JiODY0NWd3MWY1d3AwbXdzNWdqMjB6aTA4NmduOS5qcGc?x-oss-process=image/format,png" alt="在这里插入图片描述"><br>简化为：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly93dzEuc2luYWltZy5jbi9sYXJnZS82Y2JiODY0NWd3MWY1d3AyYWhvYmxqMjB1ZzAyYWRnZS5qcGc?x-oss-process=image/format,png" alt="在这里插入图片描述"><br>上式就是结果似然函数，将其最大化则得到我们最初需要通过CBOW预测的结果，将上式各项都取到最大化<br>每一项有两个参数，一个是每个节点的参数向量$\Theta <em>{j-1}^{w}$，另一个是输出层的输入$X</em>{w}$（即是中间层的输出结果转变为Hierarchical Softmax的输入）对这两个值求偏导：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly93dzEuc2luYWltZy5jbi9sYXJnZS82Y2JiODY0NWd3MWY1d3B0NHhnOHRqMjEyNjAzcTc1Ni5qcGc?x-oss-process=image/format,png" alt="在这里插入图片描述"><br>因为有如下的性质<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly93dzMuc2luYWltZy5jbi9sYXJnZS82Y2JiODY0NWd3MWY1d3B1czMzM3FqMjBiaTAyZ214NS5qcGc?x-oss-process=image/format,png" alt="在这里插入图片描述"><br>所以带入上式即可得到<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly93dzEuc2luYWltZy5jbi9sYXJnZS82Y2JiODY0NWd3MWY1d3B3aXhha25qMjBuZTAya3Q5My5qcGc?x-oss-process=image/format,png" alt="在这里插入图片描述"><br>最终结果为<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly93dzEuc2luYWltZy5jbi9sYXJnZS82Y2JiODY0NWd3MWY1d3B4ajYxd2pqMjBjbzAyazBzcy5qcGc?x-oss-process=image/format,png" alt="在这里插入图片描述"><br>$\Theta <em>{j-1}^{w}$的迭代公式即为<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly93dzQuc2luYWltZy5jbi9sYXJnZS82Y2JiODY0NWd3MWY1d3B6ajBtMHpqMjBsMjAyNnQ5MC5qcGc?x-oss-process=image/format,png" alt="在这里插入图片描述"><br>$X</em>{w}$偏导式为<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly93dzEuc2luYWltZy5jbi9sYXJnZS82Y2JiODY0NWd3MWY1d3AyYWhvYmxqMjB1ZzAyYWRnZS5qcGc?x-oss-process=image/format,png" alt="在这里插入图片描述"><br>所有直接将 $\Theta <em>{j-1}^{w}$的偏导数中的$\Theta _{j-1}^{w}$替换为$X</em>{w}$，得到关于$X_{w}$的偏导数<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly93dzQuc2luYWltZy5jbi9sYXJnZS82Y2JiODY0NWd3MWY1d3E1Y2Zxa25qMjBqZTAzcXQ5Mi5qcGc?x-oss-process=image/format,png" alt="在这里插入图片描述"><br>得到的是$X_{w}$的更新迭代，因为$X_{w}$并不是输入的向量，而是一个中间产物，所以必须把该结果向上传递至每个单词的词向量中：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly93dzQuc2luYWltZy5jbi9sYXJnZS82Y2JiODY0NWd3MWY1d3FjZGR3dzdqMjBxNjA0MndmNC5qcGc?x-oss-process=image/format,png" alt="在这里插入图片描述"><br><strong>重点：两个参数的更新伪代码</strong>：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly93dzEuc2luYWltZy5jbi9sYXJnZS82Y2JiODY0NWd3MWY1d3FnejBlbHFqMjBwbTBxYXE1YS5qcGc?x-oss-process=image/format,png" alt="在这里插入图片描述"></p>
]]></content>
      <tags>
        <tag>word2vec</tag>
      </tags>
  </entry>
  <entry>
    <title>&lt;剑指offer&gt; 剑指offer 07.09</title>
    <url>/2020/05/06/%E5%89%91%E6%8C%87offer%20%5B07%2009%5D/</url>
    <content><![CDATA[<p>摘要：<br>07 重建二叉树<br>09 用两个栈实现队列</p>
<a id="more"></a>
<h1 id="面试题07-重建二叉树"><a href="#面试题07-重建二叉树" class="headerlink" title="面试题07 重建二叉树"></a>面试题07 <a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/solution/mian-shi-ti-07-zhong-jian-er-cha-shu-di-gui-fa-qin/" target="_blank" rel="noopener">重建二叉树</a></h1><h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p>输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。<br><img src="https://img-blog.csdnimg.cn/2020050515530552.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQzMzk2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"> </p>
<h2 id="解析："><a href="#解析：" class="headerlink" title="解析："></a>解析：</h2><ul>
<li><strong>递推参数</strong>： 前序遍历中根节点的索引pre_root、中序遍历左边界in_left、中序遍历右边界in_right</li>
<li><strong>终止条件</strong>： 当 in_left &gt; in_right ，子树中序遍历为空，说明已经越过叶子节点，此时返回 nullnull 。</li>
<li><strong>递推工作</strong>：</li>
</ul>
<p>1.立根节点root： 值为前序遍历中索引为pre_root的节点值。<br>2.搜索根节点root在中序遍历的索引i<br>3.构建根节点root的左子树和右子树： 通过调用 recur() 方法开启下一层递归<br>——左子树： 根节点索引为 pre_root + 1 ，中序遍历的左右边界分别为 in_left 和 i - 1。<br>——右子树： 根节点索引为 i - in_left + pre_root + 1（即：根节点索引 + 左子树长度 + 1），中序遍历的左右边界分别为 i + 1 和 in_right。</p>
<ul>
<li><strong>返回值</strong>： 返回 root，含义是当前递归层级建立的根节点 root 为上一递归层级的根节点的左或右子节点。<h2 id="解法："><a href="#解法：" class="headerlink" title="解法："></a>解法：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//java解法</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    HashMap&lt;Integer,Integer&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span>[] preNode;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">            preNode=preorder;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;inorder.length;i++)&#123;</span><br><span class="line">                map.put(inorder[i],i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> recur(<span class="number">0</span>,<span class="number">0</span>,inorder.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode <span class="title">recur</span><span class="params">(<span class="keyword">int</span> pre_root,<span class="keyword">int</span> in_left,<span class="keyword">int</span> in_right)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(in_left&gt;in_right)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> idx=map.get(preNode[pre_root]);</span><br><span class="line">            TreeNode root=<span class="keyword">new</span> TreeNode(preNode[pre_root]);</span><br><span class="line">            <span class="comment">// 左子树递归</span></span><br><span class="line">            root.left=recur(pre_root+<span class="number">1</span>,in_left,idx-<span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 右子树递归</span></span><br><span class="line">            root.right=recur(idx-in_left+pre_root+<span class="number">1</span>,idx+<span class="number">1</span>,in_right);</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#python解法</span></span><br><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span><span class="params">(self, preorder: List[int], inorder: List[int])</span> -&gt; TreeNode:</span></span><br><span class="line">        self.inNode,self.HashMap=preorder,&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(inorder)):</span><br><span class="line">            self.HashMap[inorder[i]]=i</span><br><span class="line">        <span class="keyword">return</span> self.recur(<span class="number">0</span>,<span class="number">0</span>,len(inorder)<span class="number">-1</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recur</span><span class="params">(self,pre_root:int,in_left:int,in_right:int)</span> -&gt;TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> in_left&gt;in_right: <span class="keyword">return</span></span><br><span class="line">        root=TreeNode(self.inNode[pre_root])</span><br><span class="line">        idx=self.HashMap[self.inNode[pre_root]]</span><br><span class="line">        root.left=self.recur(pre_root+<span class="number">1</span>,in_left,idx<span class="number">-1</span>)</span><br><span class="line">        root.right=self.recur(idx-in_left+pre_root+<span class="number">1</span>,idx+<span class="number">1</span>,in_right)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="面试题09-用两个栈实现队列"><a href="#面试题09-用两个栈实现队列" class="headerlink" title="面试题09 用两个栈实现队列"></a>面试题09 用两个栈实现队列</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:</h2><p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )</p>
<h2 id="解法：-1"><a href="#解法：-1" class="headerlink" title="解法："></a>解法：</h2><h3 id="普通思路一："><a href="#普通思路一：" class="headerlink" title="普通思路一："></a>普通思路一：</h3><p>一个栈存储元素，一个栈辅助，每次添加元素时利用两个栈将顺序调整为队列“先进先出”的形式；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CQueue</span> </span>&#123;</span><br><span class="line"><span class="comment">//用栈实现队列</span></span><br><span class="line">    Stack&lt;Integer&gt; s1=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; s2=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> size=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">appendTail</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!s1.isEmpty())&#123;</span><br><span class="line">            s2.push(s1.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        s1.push(value);</span><br><span class="line">        size++;</span><br><span class="line">        <span class="keyword">while</span>(!s2.isEmpty())&#123;</span><br><span class="line">            s1.push(s2.pop());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deleteHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s1.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> s1.pop();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//通过两个LinkedList实现队列</span></span><br><span class="line">	LinkedList&lt;Integer&gt; s1=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; s2=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">appendTail</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!s1.isEmpty())&#123;</span><br><span class="line">            s2.add(s1.removeLast());</span><br><span class="line">        &#125;</span><br><span class="line">        s1.add(value);</span><br><span class="line">        <span class="keyword">while</span>(!s2.isEmpty())&#123;</span><br><span class="line">            s1.add(s2.removeLast());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deleteHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s1.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s1.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CQueue</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.s1,self.s2=[],[]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">appendTail</span><span class="params">(self, value: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">while</span> self.s1:</span><br><span class="line">            self.s2.append(self.s1.pop())</span><br><span class="line">        self.s1.append(value)</span><br><span class="line">        <span class="keyword">while</span> self.s2:</span><br><span class="line">            self.s1.append(self.s2.pop())</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteHead</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> self.s1:</span><br><span class="line">           <span class="keyword">return</span> self.s1.pop()</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<h3 id="优化思路二："><a href="#优化思路二：" class="headerlink" title="优化思路二："></a><a href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/solution/mian-shi-ti-09-yong-liang-ge-zhan-shi-xian-dui-l-2/" target="_blank" rel="noopener">优化思路二：</a></h3><p>在删除队列元素时，利用两个栈实现队列：<br>利用A栈添加元素，B专用于栈弹出元素；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CQueue</span> </span>&#123;</span><br><span class="line">    LinkedList&lt;Integer&gt; A, B;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        A = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        B = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">appendTail</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        A.add(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deleteHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!B.isEmpty()) <span class="keyword">return</span> B.removeLast();</span><br><span class="line">        <span class="keyword">if</span>(A.isEmpty()) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!A.isEmpty())</span><br><span class="line">            B.add(A.removeLast());</span><br><span class="line">        <span class="keyword">return</span> B.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CQueue</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.A, self.B = [], []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">appendTail</span><span class="params">(self, value: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.A.append(value)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteHead</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> self.B: <span class="keyword">return</span> self.B.pop()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.A: <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> self.A:</span><br><span class="line">            self.B.append(self.A.pop())</span><br><span class="line">        <span class="keyword">return</span> self.B.pop()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>&lt;论文&gt;基于情绪分析方向使用依赖信息加强注意力机制</title>
    <url>/2020/04/30/%E5%9F%BA%E4%BA%8E%E6%83%85%E7%BB%AA%E5%88%86%E6%9E%90%E6%96%B9%E5%90%91%E4%BD%BF%E7%94%A8%E4%BE%9D%E8%B5%96%E4%BF%A1%E6%81%AF%E5%8A%A0%E5%BC%BA%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6_%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="基于情绪分析方向使用依赖信息加强注意力机制"><a href="#基于情绪分析方向使用依赖信息加强注意力机制" class="headerlink" title="基于情绪分析方向使用依赖信息加强注意力机制"></a>基于情绪分析方向使用依赖信息加强注意力机制</h1><blockquote>
<p>原文题目: Using Dependency Information to Enhance AttentionMechanism for Aspect-based Sentiment Analysis</p>
</blockquote>
<a id="more"></a>
<p><strong>idea1</strong>:是否可以<strong>将情绪分析(分类)的研究应用到法条的选择中</strong>,通过其他算法将大概的案情相关法条缩减范围,通过情绪分析的方法将确定上述的几个法条是否可以在案情中使用.同理适用到其他对文本判定类别的应用之中.</p>
<p>本文是将<strong>attention机制</strong>应用到<strong>文本情绪分析</strong>中,即为ABSA.</p>
<blockquote>
<p>aspect 指的是下文例子中的food和service等词,针对这些方面进行情感分析,可能是积极,消极,中立.</p>
</blockquote>
<p><strong>摘要</strong>：注意力机制已经被证实对ABSA（情绪分析）有效。最近出现许多研究针对于基于依赖关系实现注意力机制。然而，缺点在于依赖树必须先获得这棵树，而且存在受到误差传播的影响。因为发现注意力机制的计算是基于图去依赖分析，我们设计了一个基于多任务的新方法去转移对ABSA的依赖知识。分别针对<strong>ABSA</strong>训练了一个<strong>基于注意力的LSTM模型</strong>，针对<strong>依赖解析</strong>训练了一个<strong>基于图的模型</strong>.这个转移可以缓解因为训练数据不足造成的网络训练不足的问题.在semeval的2014餐馆笔记本一系列实验中表明我们的模型可以从依赖关系知识中获得可观的收益,并获得与具有复杂网络结构的最新模型相同的性能.</p>
<p><strong>关键词</strong>:<strong>Aspect-based Sentiment Analysis, Multi-task Learning, DependencyParsing, Attention Mechanism</strong></p>
<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h2><p> 文本情感分析的重要性,在互联网时代,大量的自动评价应用是很有发展前景的.例子: For example, in the sentence“greatfood but the service was dreadful”, targets are food and service, and the correspondingsentiment polarities are positive and negative respectively.其中target是food和service.</p>
<p> attention机制对情感分析是很重要的,它可以强制模型去学习上下文文本与目标的关系.<strong>(存疑?)</strong>.但是当句子很复杂,特别是当文本与目标之间差别巨大,传统的attention模型有能力限制.为了克服这个缺点,一些研究者用依赖关系去完整计算对长距离的特定的目标.在这些工作中,依赖树可以用于对传统机器学习模型和基于神经网络的模型提取关系特征,或建立递归神经网络方法中用于输入的特定递归结构.但是这些方法高度依赖于自动依赖解析器产生的输入依赖解析树,树可能有错误，因此遭受错误传播问题。<br>      经过深层次的研究发现这个attention机制的计算实际上是基于图依赖分析的一部分.attention机制是去计算在句子中任何一个词与target之间的关系,当基于图依赖分析会计算出句子中任意两个词语之间的关系.所以从图依赖分析中获得的信息可以协助attention网络的训练!!! 在这篇论文中,我们以多任务学习的方式结合了一个基于attention的LSTM模型和一个基于图依赖分析的模型.我们通过一系列实验和对注意力机制改善的可视化演示了我们方法的有效性。</p>
<blockquote>
<p> 本文的主要贡献为:</p>
<ol>
<li>第一个检测到注意力层计算是基于图的依赖分析的一部分的人。 因此，联合学习与基于图的依赖关系解析可以帮助培训注意层.<br>2.我们提出了一种基于方面的情感分析的通用方法，该方法可以转移依赖性知识以获得更好的与方面相关的表示。 该架构对所有基于LSTM的ABSA模型均有效<br>3.我们提出了一种有效的方法来增强注意力机制。 它无需使用额外的依赖解析器即可传输依赖关系的知识。 在预测阶段，可以节省大量的计算资源。</li>
</ol>
</blockquote>
<p>本文的其余部分的结构如下。 第2节介绍了有关基于方面的情感分析的文献。 提议的方法的总体设计在第3节中进行了描述。第4节介绍了实验设置和分析。 最后，第5节介绍了结论和未来的工作。</p>
<h2 id="2-相关工作"><a href="#2-相关工作" class="headerlink" title="2.相关工作"></a>2.相关工作</h2><h3 id="2-1-基于方面的情感分析"><a href="#2-1-基于方面的情感分析" class="headerlink" title="2.1 基于方面的情感分析"></a>2.1 基于方面的情感分析</h3><p><strong>基于方面的情感分析</strong>在文献中经常被认为是分类问题.传统的方法是基于一系列人工定义的特征做研究,但是该结果十分依赖人工的标注是否正确.而且特征的标注是一件是十分耗费人力的工作.</p>
<p>后续的工作中在以后的工作中，方法像许多其他NLP任务一样变成了基于神经网络的方法。 简而言之，其发展大致可分为三个阶段。 最初，将任务建模为句子分类问题。 假设某产品有怀疑，则ABSA任务实际上是一个3N分类问题，因为每个方面都与三个情感极性有关：积极，消极和中立。 第二阶段是递归神经网络。 提出了许多基于递归神经网络的树结构模型。 在最近阶段，大多数作品都基于基于方面的句子表示的思想，该句子生成针对特定方面的句子表示。 Wang等采用这种想法，并利用注意力机制来产生这样的表示。 德宏等 设计了一个交互式注意力网络（IAN），它使用两个注意力网络对目标和上下文进行交互建模。 唐等提出了一种名为“具有方面嵌入的门控卷积网络”的模型（GCAE），该模型使用方面信息通过CNN和门控机制控制句子的情感特征流。 同样，黄等将目标的合并结果视为应用于句子的额外卷积核。 也有研究者将ABSA任务视为一个问答问题，其中基于内存的网络起着主要作用.</p>
<h3 id="2-2依赖性解析"><a href="#2-2依赖性解析" class="headerlink" title="2.2依赖性解析"></a>2.2依赖性解析</h3><p><strong>*依赖性分析</strong>在情感分析中也被广泛使用*。 大多数方法从依赖树中获得直接或简短的依赖特征，以捕获句子中单词之间的关系。 Xinbo等在计算注意力权重以捕获确定目标的远程信息时，将依赖项嵌入作为附加输入。 铁二等将句子中每个依赖子树的情感极性视为隐藏变量。 考虑隐藏变量之间的相互作用来计算整个句子的极性。 Soujanya等人通过允许情感基于输入情感的依存关系从一个概念流到另一个概念.更好地理解句子中每个概念的语境作用。 但是它们都需要附加的依赖解析器，通常是斯坦福依赖解析器，并且受错误传播问题的影响。 而且，其解析过程也消耗了大量的计算资源.  </p>
<h2 id="3-模型"><a href="#3-模型" class="headerlink" title="3 模型"></a>3 模型</h2><p>本文提出一个多任务学习模型去传递依赖性的知识给基于aspect情感分析模型. 3.1中展示基于attention的LSTM模型,3.2中为基于图依赖分析模型,3.3中为最后的多任务学习模型.</p>
<h3 id="3-1-基于attention的LSTM模型"><a href="#3-1-基于attention的LSTM模型" class="headerlink" title="3.1 基于attention的LSTM模型"></a>3.1 基于attention的LSTM模型</h3><p>对于基于aspect的情感分析模型任务,基于attention的LSTM模型已经被证明了是有用的.它建立了一个指向性的LSTM层提取输入文本中每个词的上下文表示.之后，应用注意层来计算每个单词对aspect的贡献并获得最终的aspect相关表示,情感极性最终由softmax层计算.(<strong>对此段还是存在问题</strong>)</p>
<p>输入句子中给出n个词语$W_{s1}$,$W_{s2}$,$W_{s3}$,……$W_{sn}$,和m个词组aspect为$W_{a1}$,$W_{a2}$,$W_{a3}$,……$W_{am}$,我们将每一个$W_{i}$词与嵌入向量e($W_{i}$)通过向量矩阵E一一对应起来.其中矩阵的横向量为单词总量,纵向量个数为词向量的维度.这些aspect的代表$e_{a_aspect}$是目标单词的词向量的平均值.(如下图中的第一个表达式)<br><img src="https://img-blog.csdnimg.cn/20191221175253667.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQzMzk2OQ==,size_16,color_FFFFFF,t_70" alt="图一"><br>LSTM层被用于提取每一个单词的上下文表示关系.每一个时间步的输出都是最后的表达.<strong>下公式中的V1V2等都是作为attention的输入</strong><img src="https://img-blog.csdnimg.cn/20191221175555841.png" alt="在这里插入图片描述"><br>之后,一个attention层被用于计算每句子中一个词$w_{si}$针对<strong>aspect</strong>的权重$\alpha _{i}$.它的输出是所有文本特征的加权总和。<strong>(该输出即为图一中attention的唯一输出)</strong></p>
<blockquote>
<p>疑问? 图一中的H是指代这什么内容???<br>猜测:图一中的attention层分为两个其中H为encoder层,aspect embedding为decoder层??</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20191221175928342.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20191221175945554.png" alt="在这里插入图片描述"><br>在计算βi之前，我们将$e_{a_aspect}$乘以Wα。 原因是具有一定含义的一个aspect在实际场景中可以有几种表达方式。 以笔记本电脑为例，屏幕还可以表示为显示，分辨率和外观。 因此，相似aspect的短语应被分组为一个方面。 这里我们使用一个简单的全连接神经网络来实现方面短语分组.$f_{score}$是一个基于内容的功能，<strong>可以计算每个单词对目标意见的贡献</strong>。</p>
<p>最后，基于最终表示z，创建一个softmax层来预测概率分布的情感类别。<img src="https://img-blog.csdnimg.cn/20191221181558457.png" alt="在这里插入图片描述"><br>其中Ci表示当前样本的真实标号，Pi(Ci)表示P中真实标号的概率。</p>
<h3 id="3-2-基于图依赖分析"><a href="#3-2-基于图依赖分析" class="headerlink" title="3.2 基于图依赖分析"></a>3.2 基于图依赖分析</h3><p><img src="https://img-blog.csdnimg.cn/20191221181742147.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQzMzk2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>图2基于图的依赖解析器的神经模型架构图,所有的MLP共享相同的参数。 在获得所有可能的n（n-1）个arcs的分数之后，可以使用动态编程算法找到最高的得分树.</p>
<p>我们遵循基于圆弧因素的基于图的依赖解析器，其中一个树的分数是其所有head-modifier arcs（h，m）的总和。考虑到ABSA任务数据集仅是具有情感极性的注释（即是积极消极或者中立），我们只用词向量作为输入就可，CHEN已经证实了POS（词性）对于依赖分析更加有指导性.网络结构在图二中已经展示了.</p>
<p>对于基于图的依赖关系解析，获取LSTM层输出的过程与3.1节中说明的ABSA模型的过程相同。 假设我们已经在公式2中获得了LSTM层的输出，则头部修改器arc score（h，m，s）的分数是通过一个简单的MLP层计算得出的.<br><img src="https://img-blog.csdnimg.cn/20191221193128568.png" alt="在这里插入图片描述"><br>在获得n（n-1）个可能弧的所有分数之后，找到最高得分的依存关系树成为最大化树空间Y（s）中生成树的问题。 使用Eisner的解码算法（1996年）可以有效地解决这一问题。</p>
<p><strong>最后的模型如下</strong>:<br><img src="https://img-blog.csdnimg.cn/20191221193222345.png" alt="在这里插入图片描述"><br>在训练该模型时，不像我们仅使用结构损失而不使用由弧形标签错误产生的损失，因为这会使模型更加复杂且难以训练。 <strong>换句话说，我们只预测解析树的结构，而忽略弧的特定类别。</strong> 结构损失是基于余量的目标，旨在最大程度地提高金树的分数与预测解析树的最高分数之间的余量：<br><img src="https://img-blog.csdnimg.cn/20191221193423659.png" alt="在这里插入图片描述"></p>
<h3 id="3-3-多任务学习"><a href="#3-3-多任务学习" class="headerlink" title="3.3 多任务学习"></a>3.3 多任务学习</h3><p><img src="https://img-blog.csdnimg.cn/20191221193502123.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQzMzk2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>图3</strong> 多任务学习模型的插图 虚线的右边是基线模型。 FC代表完全连接的网络。</p>
<p>从用于attention计算的公式5与为了依赖分析的公式10中,我们可以看到attention机制仅仅是基于图依赖分析计算的一部分.<br>使用文章开始的英文例子“great food but the service was dread-ful”,<strong>基于图的依存关系分析计算出句子中任意两个单词之间的关系</strong>,而<strong>注意力机制仅计算目标单词“ food”与句子中任何其他单词之间的相关性</strong>。 因此，依赖项语法中的信息可以帮助注意层的训练。</p>
<blockquote>
<p><strong>上述两句话就是前面两个模型的作用</strong></p>
</blockquote>
<p>我们建议将深度学习成功应用于依赖分析，以基于图的依赖分析模型进行联合学习。 <strong>两个模块共享一个单词嵌入层和一个LSTM层，而其他层则是特定于任务的。</strong> 最终模型的结构如图3所示。句子和Aspect共享相同的单词嵌入矩阵。 总损失由以下公式计算：</p>
<blockquote>
<p><strong>需要去了解以下什么是依赖分析 dependence analysis???</strong></p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20191221193945540.png" alt="在这里插入图片描述"><br>其中λ是影响网络优化方向的超参数</p>
<h2 id="4-实验"><a href="#4-实验" class="headerlink" title="4 实验"></a>4 实验</h2><h3 id="4-1数据集"><a href="#4-1数据集" class="headerlink" title="4.1数据集"></a>4.1数据集</h3><p>对于ABSA任务，我们使用两个公共方面级别的注释数据集：SemEval 2014 Task4餐厅和笔记本电脑评论数据集。 还提供了培训和测试集。 表1给出了这两个数据集的完整统计信息。</p>
<p><img src="https://img-blog.csdnimg.cn/20191221201034275.png" alt="在这里插入图片描述"><br>对于基于图的依赖项解析任务，我们使用Penn TreeBank (PTB)[17]数据集的Stanford dependency conversion，使用与                      相同的训练/测试分割。这些数据来自1989年的《华尔街日报》。</p>
<h3 id="4-2-实验设置"><a href="#4-2-实验设置" class="headerlink" title="4.2 实验设置"></a>4.2 实验设置</h3><p>我们的模型是使用DyNet工具包[20]在python中实现的，用于神经网络训练。 在我们所有的实验中，我们使用在8400亿个令牌的未标记数据上预训练的300维GloVe向量4 [22]来初始化嵌入层，而所有其他参数都是随机初始化的。 单词嵌入矩阵中只包含频率最高的10,000个单词,其余的低频单词由<UNK>代替. 所有参数均通过网络培训进行更新。 对于公式12中的整体损失，经过一些尝试后，将λ设置为0.05。</p>
<p>为了最优化结果,使用衰减率和基础学习率设置为0.001的RMSProp优化器。 上面未提及的其他参数设置为DyNet提供的默认值。</p>
<h3 id="4-3-与现存的方法进行比较"><a href="#4-3-与现存的方法进行比较" class="headerlink" title="4.3 与现存的方法进行比较"></a>4.3 与现存的方法进行比较</h3><p>为了权威地演示该模型的性能，我们将其与以下模型进行比较：</p>
<p>LSTM + ATT使用注意力机制从当前方面提取上下文表示，然后应用softmax层进行分类。</p>
<p>TD-LSTM在构建学习模型时整合了目标词和上下文词之间的联系。 它使用两个LSTM网络捕获目标词及其上下文之间的联系，以生成目标相关表示。</p>
<p>ATAE-LSTM利用方面嵌入和词嵌入的串联作为LSTM层的输入，然后添加一个公共 注意层以获得与方面有关的表示。 Wang等揭示了情感的情感极性也与所连接的方面有关。</p>
<p>MemNet是一种基于记忆网络的ABSA任务方法。 它堆叠了一个多层注意模型，以获取每个上下文词对当前方面的情感极性判断的贡献。 该模型不仅在速度上大大超过了基于LSTM的模型，而且还可以与基于最新功能的SVM系统相媲美。</p>
<p>DOC：MULT以多任务学习的方式从文档级情感分类中转移知识 。 它也基于LSTM + ATT。 文档级别的标签数据相对容易在线访问，例如亚马逊评论。</p>
<p>GCAE是一个基于卷积神经网络和门控机制的模型。 它在方面方面具有附加的卷积层。 然后，目标的合并结果将作为额外的卷积过滤器应用于句子。</p>
<p>我们使用常用的准确性和macro-f1作为评估指标。 结果示于表2。基于它们，我们有以下观察结果:</p>
<blockquote>
<p>1–当与LSTM + ATT模型进行比较时，我们观察到依赖性知识非常有帮助。 它为所有数据集中的指标均带来了巨大的改进。<br>2–DOC：MULT是另一种多任务学习方法。 与没有多任务学习的模型相比，它也取得了很大的进步。 但是，当整个句子的情感极性与各个方面的情感极性不一致时，该句子级别的情感信息将干扰对方面级别的情感极性的预测。 在那种情况下，来自依赖弧的知识仍然可以帮助我们找到与各方面相对应的情感词。 因此，基于图的依赖关系分析的多任务学习可以实现更好的性能。<br>3–作为一种多任务学习方法，DOC：MULT和DP：MULT都极大地提高了LSTM + ATT模型的性能，这也反映了一个事实，即数据 稀缺。 当前数据不足以训练非常有效的基于神经网络的模型。<br>4–当我们分析表3中所示的测试结果的混淆矩阵时，我们发现类别之间的样本不平衡也给网络培训带来了困难。 中立类别的召回率远低于其他两个类别。 一方面，这是由于中性样本自身的歧义所致。 另一方面，中性样本太少使模型很难学习与中性有关的模式。</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20191221202042327.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQzMzk2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="4-4-attention权重的可视化"><a href="#4-4-attention权重的可视化" class="headerlink" title="4.4 attention权重的可视化"></a>4.4 attention权重的可视化</h3><p>在本节中，我们从数据集中选择一些测试样本并可视化它们的注意权重。 通过与没有多任务学习的模型结果进行比较，我们可以确认依赖信息是否发挥了应有的作用。 结果如图4所示。选择的样本都在多方面提出了意见相反的情感极性，这不能用句子级情感分析方法正确地进行分析。主要观察如下：</p>
<blockquote>
<p>–我们的模型可以更准确地定位与方面相关的情感词4（b）。 即使评论对包含多个情感词的多个方面进行了评论，该模型仍然可以找到针对特定方面的那些相关情感词。</p>
<p>–在我们的模型4（a）中，与方面相关的情感词的权重更高。 这可以使关注层获得的与方面有关的表示包含更多的情感信息</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20191221202216546.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQzMzk2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<blockquote>
<p>–同时，当对不同方面的看法不同时，我们的模型将赋予对比连接更大的权重，例如图4（a）和4（b）中的“ but”。 当不同方面的情感倾向完全相反时，这种现象尤其明显。 这些词包含丰富的依赖性信息，可以为注意机制带来极大的好处</p>
</blockquote>
<p>这些现象都表明我们的模型具有更好的注意力表现，并证实依赖知识对注意力机制非常有帮助。 该知识有助于模型获得更好的与方面有关的表示，并最终改善总体性能.</p>
<h2 id="5-结论"><a href="#5-结论" class="headerlink" title="5 结论"></a>5 结论</h2><p>在本文中，我们提出了一种基于多任务学习策略的基于方面的情感分析的新方法。 据我们所知，我们是第一个检测注意力机制和基于图的依存关系分析之间的关系的人。 我们使用依赖知识来增强关注层的性能，然后提高整体性能。 我们已经证明了我们提出的方法的有效性，并可视化了注意层的改进。 我们的方法也具有一定的通用性。 它可以应用于其他基于LSTM的ABSA模型，以进一步提高其性能。 将来，我们将寻找更有效的方法来转移对ABSA任务的依赖性知识，并将更加关注中性注释的识别。</p>
]]></content>
      <categories>
        <category>论文</category>
      </categories>
      <tags>
        <tag>论文</tag>
      </tags>
  </entry>
  <entry>
    <title>&lt;数据分析&gt; 深度学习数据预处理（pandas篇）</title>
    <url>/2020/04/30/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86%EF%BC%88pandas%E7%AF%87%EF%BC%89/</url>
    <content><![CDATA[<p>摘要：数据预处理的四种技术：数据合并，数据清洗，数据标准化，数据转换</p>
<a id="more"></a>
<p>只是做自己的学习笔记使用，如有错误请评论区指出。<br>数据预处理的四种技术：<strong>数据合并，数据清洗，数据标准化，数据转换</strong></p>
<h1 id="导包和数据集"><a href="#导包和数据集" class="headerlink" title="导包和数据集"></a>导包和数据集</h1><p>工具使用pandas和numpy</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">train_df =pd.read_csv(<span class="string">'../datas/train.csv'</span>)  <span class="comment"># train set</span></span><br><span class="line">test_df  = pd.read_csv(<span class="string">'../datas/test.csv'</span>)   <span class="comment"># test  set</span></span><br><span class="line">combine  = [train_df, test_df]</span><br></pre></td></tr></table></figure>
<h1 id="查看数据维度以及类型"><a href="#查看数据维度以及类型" class="headerlink" title="查看数据维度以及类型"></a>查看数据维度以及类型</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查看前五条数据</span></span><br><span class="line"><span class="keyword">print</span> train_df.head(<span class="number">5</span>)  </span><br><span class="line"><span class="comment">#查看每列数据类型以及nan情况</span></span><br><span class="line"><span class="keyword">print</span> train_df.info()  </span><br><span class="line"><span class="comment">#获得所有object属性</span></span><br><span class="line"><span class="keyword">print</span> train_data.describe(include=[<span class="string">'O'</span>]).columns</span><br></pre></td></tr></table></figure>
<h1 id="操作训练集中的信息"><a href="#操作训练集中的信息" class="headerlink" title="操作训练集中的信息"></a>操作训练集中的信息</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#统计Title单列元素对应的个数</span></span><br><span class="line"><span class="keyword">print</span> train_df[<span class="string">'Title'</span>].value_counts() </span><br><span class="line"><span class="comment">#属性列删除(针对Name和Passengerld两列操作)</span></span><br><span class="line">train_df = train_df.drop([<span class="string">'Name'</span>, <span class="string">'PassengerId'</span>], axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<h1 id="1-合并数据"><a href="#1-合并数据" class="headerlink" title="1.合并数据"></a>1.合并数据</h1><pre><code>建立关系表： 
data1 = pd.DataFrame({&apos;key1&apos;:list(&apos;aavde&apos;),&apos;key2&apos;:list(&apos;asdfs&apos;),&apos;key3&apos;:list(str(12345))})</code></pre><p><img src="https://img-blog.csdnimg.cn/20200321215122841.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQzMzk2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<pre><code>data1 = pd.DataFrame(np.random.rand(3,3),index = list(&apos;abc&apos;),columns = list(&apos;ABC&apos;)) </code></pre><p><img src="https://img-blog.csdnimg.cn/20200321215330416.png" alt="在这里插入图片描述"></p>
<h2 id="堆叠"><a href="#堆叠" class="headerlink" title="堆叠"></a>堆叠</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#方法一：</span></span><br><span class="line">pd.concat(objs,join=‘outer’, join_axes=<span class="literal">None</span>,ignore_index=<span class="literal">False</span>, </span><br><span class="line">keys=<span class="literal">None</span>, levels=<span class="literal">None</span>, names=<span class="literal">None</span>, verify_interity=<span class="literal">False</span>, copy=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p><strong>objs</strong>    接受用于合并的series,dataframe的组合。以列表的形式，eg：[data1,data2]其中data1和data2为两个二维表<br><strong>axis</strong>    表示堆叠的轴向，默认axis为0，表示纵向堆叠，以行为主的堆叠方式<br><strong>join</strong>    接受inner或outer。表示其他轴向上的索引是按交集还是并集进行合并，默认为outer；<strong>outer</strong>表示并集，不存在的关系其值用NaN代替；<strong>inner</strong>表示交集，结果仅返回无空值的行或者列（此处由axis的取值决定，0：列中无空值；1：行中无空值）<br><strong>ignore_index</strong>    接受boolean.表示是否不保留连接轴上的索引，产生一组新索引range(toatal_length)默认为False<br><strong>verify_intergrity</strong>    接受boolean，检查新连接的轴是否包含重复项。如果发现重复项，则引发异常。默认为False</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#方法二:利用append实现纵向堆叠，前提是合并的两张表列名应该一致</span></span><br><span class="line">data1.append(data2,ignore_index=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>
<h2 id="通过主键合并数据"><a href="#通过主键合并数据" class="headerlink" title="通过主键合并数据"></a>通过主键合并数据</h2><p>具体实例可见 <a href="https://blog.csdn.net/moshanghuali/article/details/89764552?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522158479591419726869037198%2522%252C%2522scm%2522%253A%252220140713.130056874..%2522%257D&request_id=158479591419726869037198&biz_id=0&utm_source=distribute.pc_search_result.none-task" target="_blank" rel="noopener">链接</a><br>    主键合并就是通过一个或者多个键将两个数据集的行连接起来。类似于sql中的join。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#通用表达</span></span><br><span class="line">pd.merge(left,right,how,on,left_on,right_on,left_index,right_index,sort,suffixes)  </span><br><span class="line"></span><br><span class="line"><span class="comment">#例如;此时data_1与data_2的共同列名为key2.将其传给on。作为合并主键，进行交集合并,其中inner和outer的含义同上</span></span><br><span class="line">pd.merge(data_1,data_2,on = <span class="string">'key2'</span>,how = <span class="string">'inner'</span>)</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20200321213611755.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQzMzk2OQ==,size_16,color_FFFFFF,t_70" alt="你还好吗"><br><strong>可以通过主键合并的情况如下：</strong><br><strong>1</strong> 左右数据有共同的列名，用共同的列名作为主键。此时使用on参数，传入共同的列名。合并后的数据列数为原来数据的列数和减去连接键的数量<br><strong>2</strong> 使用不同列名主键进行合并<br><strong>3</strong> 赋予left_index和right_index参数。使用原本数据的index(行索引)作为主键进行合并</p>
<p>还可以通过<strong>不同的列名作为主键</strong>进行融合</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pd.merge(data_1,data_2,how = <span class="string">'inner'</span>,left_on = <span class="string">'key1'</span>,right_on = <span class="string">'key2'</span>) <span class="comment"># 左右的合并主键分别是key1和key2。</span></span><br></pre></td></tr></table></figure>
<p>通过<strong>索引</strong>为主键</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pd.merge(data_1,data_2,how = <span class="string">'inner'</span>,left_index = <span class="literal">True</span>,right_index=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p><strong>join方法</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#通用表达</span></span><br><span class="line">dataframe.join(self,other,on=<span class="literal">None</span>,how=‘left’,lsuffix=’’,resuffix=’’,sort=<span class="literal">False</span>)</span><br><span class="line"><span class="comment">#例如</span></span><br><span class="line">data_1.join(data_2,on = <span class="string">'key2'</span>,lsuffix=<span class="string">' '</span>,rsuffix=<span class="string">' '</span>)</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20200321221302628.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQzMzk2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h1 id="2-清洗数据"><a href="#2-清洗数据" class="headerlink" title="2.清洗数据"></a>2.清洗数据</h1><h2 id="检测重复值"><a href="#检测重复值" class="headerlink" title="检测重复值"></a>检测重复值</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dataframe.drop_duplicates(subset=<span class="literal">None</span>,keep=‘first’,inplace=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#例如</span></span><br><span class="line">data_repeat.drop_duplicates(subset=<span class="string">'key2'</span>)</span><br><span class="line">data_repeat.drop_duplicates(subset=[<span class="string">'key1'</span>,<span class="string">'key2'</span>])</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20200321221838894.png" alt="在这里插入图片描述"></p>
<h2 id="检测与处理缺失值"><a href="#检测与处理缺失值" class="headerlink" title="检测与处理缺失值"></a>检测与处理缺失值</h2><p><strong>检测</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data_null = pd.DataFrame(&#123;<span class="string">'key1'</span>:[np.nan,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,np.nan],<span class="string">'key2'</span>:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,np.nan]&#125;)</span><br><span class="line"></span><br><span class="line">data_null.isnull()   <span class="comment"># 以true或者false来表示是否是缺失值。</span></span><br><span class="line">data_null.isnull().sum()   <span class="comment"># 统计一下缺失值数目，结果将按列缺失值的个数</span></span><br></pre></td></tr></table></figure>
<p><strong>处理</strong><br>    处理缺失值的方法主要有：<strong>删除法，替换法，插值法。</strong></p>
<p><strong>删除缺失值</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#其中subset指出需要删除空值的列名，与how属性联动才可以使用</span></span><br><span class="line">dataframe.dropna(axis = <span class="number">0</span>,how = ‘any’,thresh=<span class="literal">None</span>,subset=<span class="literal">None</span>,inplace = <span class="literal">None</span>)</span><br><span class="line"><span class="comment"># thresh属性 表示能够容忍生下来的非缺失值的个数。</span></span><br></pre></td></tr></table></figure>
<p><em>上面的thresh属性存在疑问</em><br><img src="https://img-blog.csdnimg.cn/20200321222833377.png" alt="在这里插入图片描述"><br><strong>替换缺失值</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dataframe.fillna(value = <span class="literal">None</span>,method=<span class="literal">None</span>,axis=<span class="literal">None</span>,inpalce=<span class="literal">False</span>,limit=<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#例如：使用111代替缺失值</span></span><br><span class="line">data_null.fillna(<span class="number">111</span>)</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20200321223611745.png" alt="在这里插入图片描述"></p>
<h1 id="3-数据的标准化"><a href="#3-数据的标准化" class="headerlink" title="3.数据的标准化"></a>3.数据的标准化</h1><p><a href="https://blog.csdn.net/g_optimistic/article/details/93162100?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">数据标准化</a></p>
<h1 id="4-数据的转换"><a href="#4-数据的转换" class="headerlink" title="4.数据的转换"></a>4.数据的转换</h1><p><a href="https://blog.csdn.net/g_optimistic/article/details/92831389?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522158480195419724848323709%2522%252C%2522scm%2522%253A%252220140713.130056874..%2522%257D&request_id=158480195419724848323709&biz_id=0&utm_source=distribute.pc_search_result.none-task" target="_blank" rel="noopener">见链接</a></p>
<h1 id="numpy操作数据"><a href="#numpy操作数据" class="headerlink" title="numpy操作数据"></a><a href="https://blog.csdn.net/weixin_45252110/article/details/96027968?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522158479622919724811821089%2522%252C%2522scm%2522%253A%252220140713.130056874..%2522%257D&request_id=158479622919724811821089&biz_id=0&utm_source=distribute.pc_search_result.none-task" target="_blank" rel="noopener">numpy操作数据</a></h1>]]></content>
      <tags>
        <tag>pandas</tag>
      </tags>
  </entry>
  <entry>
    <title>&lt;剑指offer&gt; 剑指offer 03.04.05.06</title>
    <url>/2020/05/05/%E5%89%91%E6%8C%87offer%5B03,04,05,06%5D/</url>
    <content><![CDATA[<p>摘要：<br>03 数组中重复的数字<br>04 二维数组中的查找<br>05 替换空格<br>06 从尾到头打印链表</p>
<a id="more"></a>
<h1 id="面试题03-数组中重复的数字"><a href="#面试题03-数组中重复的数字" class="headerlink" title="面试题03 数组中重复的数字"></a>面试题03 数组中重复的数字</h1><h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p>找出数组中重复的数字。</p>
<p>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字</p>
<h2 id="解法："><a href="#解法：" class="headerlink" title="解法："></a>解法：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; set=<span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n=nums.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!set.add(nums[i]))&#123;</span><br><span class="line">                res=nums[i];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#python3</span><br><span class="line">class Solution:</span><br><span class="line">    def findRepeatNumber(self, nums: List[int]) -&gt; int:</span><br><span class="line">        mySet&#x3D;set()</span><br><span class="line">        for num in nums:</span><br><span class="line">            if num in mySet:</span><br><span class="line">                return num</span><br><span class="line">            else:</span><br><span class="line">                mySet.add(num)</span><br></pre></td></tr></table></figure>

<h1 id="面试题04-二维数组中的查找"><a href="#面试题04-二维数组中的查找" class="headerlink" title="面试题04 二维数组中的查找"></a>面试题04 <a href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/solution/mian-shi-ti-04-er-wei-shu-zu-zhong-de-cha-zhao-zuo/" target="_blank" rel="noopener">二维数组中的查找</a></h1><h2 id="题目：-1"><a href="#题目：-1" class="headerlink" title="题目："></a>题目：</h2><p>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">findNumberIn2DArray</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix == <span class="keyword">null</span>|| matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> row=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> col=matrix[<span class="number">0</span>].length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(row&lt;matrix.length&amp;&amp;col&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(target==matrix[row][col])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(target&gt;matrix[row][col])&#123;</span><br><span class="line">                row++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                col--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#python3</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findNumberIn2DArray</span><span class="params">(self, matrix: List[List[int]], target: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> matrix: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        col,row =len(matrix[<span class="number">0</span>])<span class="number">-1</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> col&gt;=<span class="number">0</span> <span class="keyword">and</span> row&lt;len(matrix):</span><br><span class="line">            <span class="keyword">if</span> matrix[row][col]&lt;target :row+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> matrix[row][col]&gt;target : col-=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<h1 id="面试题05-替换空格"><a href="#面试题05-替换空格" class="headerlink" title="面试题05 替换空格"></a>面试题05 替换空格</h1><h2 id="题目：-2"><a href="#题目：-2" class="headerlink" title="题目："></a>题目：</h2><p>请实现一个函数，把字符串 s 中的每个空格替换成”%20”。</p>
<h2 id="解法：-1"><a href="#解法：-1" class="headerlink" title="解法："></a>解法：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// String s1=s.toString();</span></span><br><span class="line">            <span class="comment">// String res=s1.replace(" ","%20");</span></span><br><span class="line">            <span class="keyword">return</span> s.toString().replace(<span class="string">" "</span>,<span class="string">"%20"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#python3</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">replaceSpace</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">return</span> s.replace(<span class="string">" "</span>,<span class="string">"%20"</span>)</span><br></pre></td></tr></table></figure>
<h1 id="面试题-06-从尾到头打印链表"><a href="#面试题-06-从尾到头打印链表" class="headerlink" title="面试题 06 从尾到头打印链表"></a>面试题 06 <a href="https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/solution/mian-shi-ti-06-cong-wei-dao-tou-da-yin-lian-biao-d/" target="_blank" rel="noopener">从尾到头打印链表</a></h1><h2 id="题目：-3"><a href="#题目：-3" class="headerlink" title="题目："></a>题目：</h2><p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p>
<h2 id="解法：-2"><a href="#解法：-2" class="headerlink" title="解法："></a>解法：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//java</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] reversePrint(ListNode head) &#123;</span><br><span class="line">		<span class="comment">// 1.借助栈的方法</span></span><br><span class="line">         LinkedList&lt;Integer&gt; stack=<span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">     	 <span class="keyword">while</span>(head!=<span class="keyword">null</span>)&#123;</span><br><span class="line">             stack.addLast(head.val);</span><br><span class="line">            head=head.next;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">int</span>[] arr=<span class="keyword">new</span> <span class="keyword">int</span>[stack.size()];</span><br><span class="line">        </span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)</span><br><span class="line">             arr[i]=stack.removeLast();</span><br><span class="line">         <span class="keyword">return</span> arr;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 2.迭代法：</span></span><br><span class="line">    ArrayList&lt;Integer&gt; tmp=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] reversePrint(ListNode head) &#123;</span><br><span class="line">        recur(head);</span><br><span class="line">        <span class="keyword">int</span>[] arr=<span class="keyword">new</span> <span class="keyword">int</span>[tmp.size()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">            arr[i]=tmp.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recur</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        recur(head.next);</span><br><span class="line">        tmp.add(head.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"><span class="comment">#python3</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reversePrint</span><span class="params">(self, head: ListNode)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="comment"># 递归法</span></span><br><span class="line">        <span class="keyword">return</span> self.reversePrint(head.next)+[head.val] <span class="keyword">if</span> head <span class="keyword">else</span> []</span><br><span class="line">        <span class="comment"># 借助栈</span></span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            stack.append(head.val)</span><br><span class="line">            head = head.next</span><br><span class="line">        <span class="keyword">return</span> stack[::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>&lt;剑指offer&gt; 剑指offer 11、12、13</title>
    <url>/2020/05/13/%E5%89%91%E6%8C%87offer%5B11%E3%80%8112%E3%80%8113%5D/</url>
    <content><![CDATA[<p>摘要：<br>11 旋转数组的最小数字<br>12 矩阵的路径<br>13 机器人的运动范围</p>
<a id="more"></a>
<h1 id="面试题11-旋转数组的最小数字"><a href="#面试题11-旋转数组的最小数字" class="headerlink" title="面试题11 旋转数组的最小数字"></a>面试题11 旋转数组的最小数字</h1><h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。</p>
<h2 id="解法："><a href="#解法：" class="headerlink" title="解法："></a>解法：</h2><h3 id="思路一："><a href="#思路一：" class="headerlink" title="思路一："></a>思路一：</h3><p>遍历数组查询到反转点，时间复杂度未O(n),空间复杂度O(1);</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minArray</span><span class="params">(<span class="keyword">int</span>[] numbers)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numbers.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(numbers[i]&gt;numbers[i+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">return</span> numbers[i+<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numbers[<span class="number">0</span>]; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minArray</span><span class="params">(self, numbers: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(numbers)<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> numbers[i]&gt;numbers[i+<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">return</span> numbers[i+<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> numbers[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>

<h3 id="思路二："><a href="#思路二：" class="headerlink" title="思路二："></a><a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/solution/mian-shi-ti-11-xuan-zhuan-shu-zu-de-zui-xiao-shu-3/" target="_blank" rel="noopener">思路二：</a></h3><p>使用二分法查找数组元素，时间复杂度降低至对数级别：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minArray</span><span class="params">(<span class="keyword">int</span>[] numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j=numbers.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">            <span class="keyword">int</span> m=(i+j)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(numbers[m]&gt;numbers[j]) i=m+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(numbers[m]&lt;numbers[j]) j=m;</span><br><span class="line">            <span class="keyword">else</span> j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numbers[i];   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minArray</span><span class="params">(self, numbers: List[int])</span> -&gt; int:</span></span><br><span class="line">        i,j=<span class="number">0</span>,len(numbers)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> i&lt;j:</span><br><span class="line">            m=(i+j)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> numbers[m]&lt;numbers[j]: j=m</span><br><span class="line">            <span class="keyword">elif</span> numbers[m]&gt;numbers[j]: i=m+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>: j-=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> numbers[i]</span><br></pre></td></tr></table></figure>
<h1 id="面试题12-矩阵的路径"><a href="#面试题12-矩阵的路径" class="headerlink" title="面试题12 矩阵的路径"></a>面试题12 <a href="https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/solution/mian-shi-ti-12-ju-zhen-zhong-de-lu-jing-shen-du-yo/" target="_blank" rel="noopener">矩阵的路径</a></h1><h2 id="题目：-1"><a href="#题目：-1" class="headerlink" title="题目："></a>题目：</h2><p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。<br>[[“a”,”b”,”c”,”e”],<br>[“s”,”f”,”c”,”s”],<br>[“a”,”d”,”e”,”e”]]<br>但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。</p>
<h2 id="解法：-1"><a href="#解法：-1" class="headerlink" title="解法："></a>解法：</h2><p>深度优先搜索（DFS）+ 剪枝 </p>
<ul>
<li><strong>递归参数</strong>： 当前元素在矩阵 board 中的行列索引 i 和 j ，当前目标字符在 word 中的索引 k 。</li>
<li><strong>终止条件</strong>：<br>  1.返回 falsefalse ： ① 行或列索引越界 或 ② 当前矩阵元素与目标字符不同 或 ③ 当前矩阵元素已访问过 。</li>
</ul>
<p>2.返回 truetrue ： 字符串 word 已全部匹配，即 k = len(word) - 1 。</p>
<ul>
<li><strong>递推工作</strong>：</li>
</ul>
<p>1.标记当前矩阵元素： 将 board[i][j] 值暂存于变量 tmp ，并修改为字符 ‘/‘ ，代表此元素已访问过，防止之后搜索时重复访问。<br>2.搜索下一单元格： 朝当前元素的 上、下、左、右 四个方向开启下层递归，使用 或 连接 （代表只需一条可行路径） ，并记录结果至 res 。<br>3.还原当前矩阵元素： 将 tmp 暂存值还原至 board[i][j] 元素。</p>
<ul>
<li><strong>回溯返回值</strong>： 返回 res ，代表是否搜索到目标字符串。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] words=word.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;board.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;board[<span class="number">0</span>].length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dfs(board,words,i,j,<span class="number">0</span>)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] board,<span class="keyword">char</span>[] words,<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">0</span>||i&gt;board.length-<span class="number">1</span>||j&lt;<span class="number">0</span>||j&gt;board[<span class="number">0</span>].length-<span class="number">1</span>||words[k]!=board[i][j]) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(k==words.length-<span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">boolean</span> res;</span><br><span class="line">        <span class="keyword">char</span> tmp=board[i][j];</span><br><span class="line">        board[i][j]=<span class="string">'/'</span>;</span><br><span class="line">        res=dfs(board,words,i+<span class="number">1</span>,j,k+<span class="number">1</span>)||dfs(board,words,i-<span class="number">1</span>,j,k+<span class="number">1</span>)|dfs(board,words,i,j+<span class="number">1</span>,k+<span class="number">1</span>)||dfs(board,words,i,j-<span class="number">1</span>,k+<span class="number">1</span>);</span><br><span class="line">        board[i][j]=tmp;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exist</span><span class="params">(self, board: List[List[str]], word: str)</span> -&gt; bool:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(i, j, k)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> <span class="number">0</span> &lt;= i &lt; len(board) <span class="keyword">or</span> <span class="keyword">not</span> <span class="number">0</span> &lt;= j &lt; len(board[<span class="number">0</span>]) <span class="keyword">or</span> board[i][j] != word[k]: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> k == len(word) - <span class="number">1</span>: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            tmp, board[i][j] = board[i][j], <span class="string">'/'</span></span><br><span class="line">            res = dfs(i + <span class="number">1</span>, j, k + <span class="number">1</span>) <span class="keyword">or</span> dfs(i - <span class="number">1</span>, j, k + <span class="number">1</span>) <span class="keyword">or</span> dfs(i, j + <span class="number">1</span>, k + <span class="number">1</span>) <span class="keyword">or</span> dfs(i, j - <span class="number">1</span>, k + <span class="number">1</span>)</span><br><span class="line">            board[i][j] = tmp</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(board)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(board[<span class="number">0</span>])):</span><br><span class="line">                <span class="keyword">if</span> dfs(i, j, <span class="number">0</span>): <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<h1 id="面试题13-机器人的运动范围"><a href="#面试题13-机器人的运动范围" class="headerlink" title="面试题13 机器人的运动范围"></a>面试题13 <a href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/solution/mian-shi-ti-13-ji-qi-ren-de-yun-dong-fan-wei-dfs-b/" target="_blank" rel="noopener">机器人的运动范围</a></h1><h2 id="题目：-2"><a href="#题目：-2" class="headerlink" title="题目："></a>题目：</h2>地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？</li>
</ul>
<h2 id="解法一：深度优先遍历"><a href="#解法一：深度优先遍历" class="headerlink" title="解法一：深度优先遍历"></a>解法一：深度优先遍历</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m,k;</span><br><span class="line">    <span class="keyword">boolean</span>[][] visited;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 深度优先遍历</span></span><br><span class="line">        <span class="keyword">this</span>.m=m;</span><br><span class="line">        <span class="keyword">this</span>.n=n;</span><br><span class="line">        <span class="keyword">this</span>.k=k;</span><br><span class="line">        <span class="keyword">this</span>.visited=<span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span> si,<span class="keyword">int</span> sj)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=m||j&gt;=n||k&lt;si+sj||visited[i][j]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        visited[i][j]=<span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+dfs(i+<span class="number">1</span>,j,(i+<span class="number">1</span>)%<span class="number">10</span>!=<span class="number">0</span> ? si+<span class="number">1</span>:si-<span class="number">8</span>,sj)+dfs(i,j+<span class="number">1</span>,si,(j+<span class="number">1</span>)%<span class="number">10</span>!=<span class="number">0</span> ? sj+<span class="number">1</span>:sj-<span class="number">8</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">movingCount</span><span class="params">(self, m: int, n: int, k: int)</span> -&gt; int:</span></span><br><span class="line">        深度优先遍历</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(i,j,si,sj)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> i&gt;=m <span class="keyword">or</span> j&gt;=n <span class="keyword">or</span> k&lt;si+sj <span class="keyword">or</span> (i,j)<span class="keyword">in</span> visited: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            visited.add((i,j))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>+dfs(i+<span class="number">1</span>,j,si+<span class="number">1</span> <span class="keyword">if</span> (i+<span class="number">1</span>)%<span class="number">10</span> <span class="keyword">else</span> si<span class="number">-8</span>,sj)+dfs(i,j+<span class="number">1</span>,si, sj+<span class="number">1</span> <span class="keyword">if</span> (j+<span class="number">1</span>)%<span class="number">10</span> <span class="keyword">else</span> sj<span class="number">-8</span>)</span><br><span class="line">        visited=set()</span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<h2 id="解法二：广度优先遍历"><a href="#解法二：广度优先遍历" class="headerlink" title="解法二：广度优先遍历"></a>解法二：广度优先遍历</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 广度优先遍历</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        Queue&lt;<span class="keyword">int</span>[]&gt; queue= <span class="keyword">new</span> LinkedList&lt;<span class="keyword">int</span>[]&gt;();</span><br><span class="line">        queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> &#125;);</span><br><span class="line">        <span class="keyword">while</span>(queue.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] x = queue.poll();</span><br><span class="line">            <span class="keyword">int</span> i = x[<span class="number">0</span>], j = x[<span class="number">1</span>], si = x[<span class="number">2</span>], sj = x[<span class="number">3</span>];</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= m || j &gt;= n || k &lt; si + sj || visited[i][j]) <span class="keyword">continue</span>;</span><br><span class="line">            visited[i][j] = <span class="keyword">true</span>;</span><br><span class="line">            res ++;</span><br><span class="line">            queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123; i + <span class="number">1</span>, j, (i + <span class="number">1</span>) % <span class="number">10</span> != <span class="number">0</span> ? si + <span class="number">1</span> : si - <span class="number">8</span>, sj &#125;);</span><br><span class="line">            queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123; i, j + <span class="number">1</span>, si, (j + <span class="number">1</span>) % <span class="number">10</span> != <span class="number">0</span> ? sj + <span class="number">1</span> : sj - <span class="number">8</span> &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 广度优先遍历</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">movingCount</span><span class="params">(self, m: int, n: int, k: int)</span> -&gt; int:</span></span><br><span class="line">      queue,visited=[(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)],set()</span><br><span class="line">      <span class="keyword">while</span> queue:</span><br><span class="line">          i,j,si,sj=queue.pop(<span class="number">0</span>)</span><br><span class="line">          <span class="keyword">if</span> i&gt;=m <span class="keyword">or</span> j&gt;=n <span class="keyword">or</span> k&lt;si+sj <span class="keyword">or</span> (i,j)<span class="keyword">in</span> visited:</span><br><span class="line">              <span class="keyword">continue</span></span><br><span class="line">          visited.add((i,j))</span><br><span class="line">          queue.append((i+<span class="number">1</span>,j,si+<span class="number">1</span> <span class="keyword">if</span> (i+<span class="number">1</span>)%<span class="number">10</span> <span class="keyword">else</span> si<span class="number">-8</span>,sj))</span><br><span class="line">          queue.append((i,j+<span class="number">1</span>,si, sj+<span class="number">1</span> <span class="keyword">if</span>(j+<span class="number">1</span>)%<span class="number">10</span> <span class="keyword">else</span> sj<span class="number">-8</span>))</span><br><span class="line">      <span class="keyword">return</span> len(visited)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>第一个博客</title>
    <url>/2020/04/27/%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<a id="more"></a>
<p>这是本博客网站的第一次尝试 ！！</p>
]]></content>
      <tags>
        <tag>TestingTag</tag>
      </tags>
  </entry>
  <entry>
    <title>&lt;剑指offer&gt; 剑指offer 10-1.10-2</title>
    <url>/2020/05/06/%E5%89%91%E6%8C%87offer%5B10-1.10-2%5D/</url>
    <content><![CDATA[<p>摘要：<br>10-1 斐波那契数列<br>10-2 青蛙跳台阶问题</p>
<a id="more"></a>
<h1 id="面试题10-1-斐波那契数列"><a href="#面试题10-1-斐波那契数列" class="headerlink" title="面试题10-1 斐波那契数列"></a>面试题10-1 斐波那契数列</h1><h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p>写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项。斐波那契数列的定义如下：</p>
<p>F(0) = 0,   F(1) = 1<br>F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.<br>斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</p>
<p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p>
<h2 id="解法："><a href="#解法：" class="headerlink" title="解法："></a>解法：</h2><h3 id="思路一（未取模）："><a href="#思路一（未取模）：" class="headerlink" title="思路一（未取模）："></a>思路一（未取模）：</h3><p>根据斐波那契的公式，递归计算;<br>缺点：重复计算数值，耗时巨大</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> fib(n-<span class="number">1</span>)+fib(n-<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> self.fib(n<span class="number">-1</span>)+self.fib(n<span class="number">-2</span>)</span><br></pre></td></tr></table></figure>

<h3 id="思路二："><a href="#思路二：" class="headerlink" title="思路二："></a><a href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/solution/mian-shi-ti-10-i-fei-bo-na-qi-shu-lie-dong-tai-gui/" target="_blank" rel="noopener">思路二：</a></h3><p>动态规划法：以斐波那契数列性质 f(n + 1) = f(n) + f(n - 1)f(n+1)=f(n)+f(n−1) 为转移方程。</p>
<p>动态规划解析：<br>状态定义： 设 dpdp 为一维数组，其中 dp[i]dp[i] 的值代表 斐波那契数列第 ii 个数字 。<br>转移方程： dp[i + 1] = dp[i] + dp[i - 1]dp[i+1]=dp[i]+dp[i−1] ，即对应数列定义 f(n + 1) = f(n) + f(n - 1)f(n+1)=f(n)+f(n−1) ；<br>初始状态： dp[0] = 0dp[0]=0, dp[1] = 1dp[1]=1 ，即初始化前两个数字；<br>返回值： dp[n]dp[n] ，即斐波那契数列的第 n个数字。<br><img src="https://img-blog.csdnimg.cn/20200506180510389.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQzMzk2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> a=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> b=<span class="number">1</span>;</span><br><span class="line">       <span class="keyword">int</span> sum;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">           sum=(a+b)%<span class="number">1000000007</span>;</span><br><span class="line">           a=b;</span><br><span class="line">           b=sum;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> a;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        a=<span class="number">0</span></span><br><span class="line">        b=<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            sum=(a+b)%<span class="number">1000000007</span></span><br><span class="line">            a=b</span><br><span class="line">            b=sum</span><br><span class="line">        <span class="keyword">return</span> a</span><br></pre></td></tr></table></figure>
<h1 id="面试题10-2-青蛙跳台阶问题"><a href="#面试题10-2-青蛙跳台阶问题" class="headerlink" title="面试题10-2 青蛙跳台阶问题"></a>面试题10-2 青蛙跳台阶问题</h1><h2 id="题目：-1"><a href="#题目：-1" class="headerlink" title="题目："></a>题目：</h2><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</p>
<p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p>
<h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a><a href="https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/solution/mian-shi-ti-10-ii-qing-wa-tiao-tai-jie-wen-ti-dong/" target="_blank" rel="noopener">思路：</a></h2><p><strong>此类求 多少种可能性 的题目一般都有 递推性质</strong><br>为什么是斐波那契数列：设跳上 n 级台阶有 f(n)种跳法。在所有跳法中，青蛙的最后一步只有两种情况： 跳上 1 级或 2级台阶。<br>当为 1级台阶： 剩 n-1个台阶，此情况共有 f(n-1) 种跳法；<br>当为 2级台阶： 剩 n-2个台阶，此情况共有 f(n-2) 种跳法。</p>
<p>公式：f(n)=f(n−1)+f(n−2)</p>
<h2 id="解法：-1"><a href="#解法：-1" class="headerlink" title="解法："></a>解法：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numWays</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">1</span>, sum;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            sum = (a + b) % <span class="number">1000000007</span>;</span><br><span class="line">            a = b;</span><br><span class="line">            b = sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">作者：jyd</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/solution/mian-shi-ti-10-ii-qing-wa-tiao-tai-jie-wen-ti-dong/</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numWays</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        a, b = <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(n):</span><br><span class="line">            a, b = b, a + b</span><br><span class="line">        <span class="keyword">return</span> a % <span class="number">1000000007</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>&lt;剑指offer&gt; 剑指offer 14-1、14-2、15</title>
    <url>/2020/05/13/%E5%89%91%E6%8C%87offer%5B14-1%E3%80%8114-2%E3%80%8115%5D/</url>
    <content><![CDATA[<p>摘要：<br>14-1 剪绳子<br>14-2 剪绳子||<br>15 二进制中的一个数</p>
<a id="more"></a>
<h1 id="面试题14-1剪绳子"><a href="#面试题14-1剪绳子" class="headerlink" title="面试题14-1剪绳子"></a>面试题14-1剪绳子</h1><h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p>给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m] 。请问 k[0]<em>k[1]</em>…*k[m] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18</p>
<h2 id="解法："><a href="#解法：" class="headerlink" title="解法："></a>解法：</h2><h3 id="思路一："><a href="#思路一：" class="headerlink" title="思路一："></a>思路一：</h3><p>暴力遍历+备忘录法减少运算量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 暴力解法+备忘录减少运算量</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] f=<span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> mem(f,n);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mem</span><span class="params">(<span class="keyword">int</span>[] f,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(f[n]!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> f[n];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> res = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            res = Math.max(res, Math.max(i * (n - i), i * mem(f,n - i)));</span><br><span class="line">        &#125;</span><br><span class="line">        f[n]=res;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用辅助函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cuttingRope</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">memoize</span><span class="params">(n)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> n == <span class="number">2</span>: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> f[n] != <span class="number">0</span>: <span class="comment"># 如果f[n]已经计算过，直接返回避免重复计算</span></span><br><span class="line">                <span class="keyword">return</span> f[n]</span><br><span class="line">            res = <span class="number">-1</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">                res = max(res, max(i * (n - i),i * memoize(n - i)))</span><br><span class="line">            f[n] = res</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">        f = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">return</span> memoize(n)</span><br></pre></td></tr></table></figure>

<h3 id="思路二："><a href="#思路二：" class="headerlink" title="思路二："></a>思路二：</h3><p>贪心算法+数学推导：<br>① 当所有绳段长度相等时，乘积最大。② 最优的绳段长度为 3。<br><img src="https://img-blog.csdnimg.cn/20200511120545610.png" alt="在这里插入图片描述"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">3</span>) <span class="keyword">return</span> n-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> i=n%<span class="number">3</span>,j=n/<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">0</span>) <span class="keyword">return</span> (<span class="keyword">int</span>)Math.pow(<span class="number">3</span>,j);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(i==<span class="number">1</span>) <span class="keyword">return</span> (<span class="keyword">int</span>)Math.pow(<span class="number">3</span>,j-<span class="number">1</span>)*<span class="number">4</span>;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)Math.pow(<span class="number">3</span>,j)*<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cuttingRope</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> n&lt;=<span class="number">3</span>: <span class="keyword">return</span> n<span class="number">-1</span></span><br><span class="line">        i=n%<span class="number">3</span></span><br><span class="line">        j=n//<span class="number">3</span></span><br><span class="line">        <span class="keyword">if</span> i==<span class="number">0</span>: <span class="keyword">return</span> int(math.pow(<span class="number">3</span>,j))</span><br><span class="line">        <span class="keyword">elif</span> i==<span class="number">1</span>: <span class="keyword">return</span> int(math.pow(<span class="number">3</span>,j<span class="number">-1</span>)*<span class="number">4</span>)</span><br><span class="line">        <span class="keyword">return</span> int(math.pow(<span class="number">3</span>,j)*<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<h1 id="面试题14-2-剪绳子"><a href="#面试题14-2-剪绳子" class="headerlink" title="面试题14-2 剪绳子||"></a>面试题14-2 <a href="https://leetcode-cn.com/problems/jian-sheng-zi-ii-lcof/solution/mian-shi-ti-14-ii-jian-sheng-zi-iitan-xin-er-fen-f/" target="_blank" rel="noopener">剪绳子||</a></h1><h2 id="题目：-1"><a href="#题目：-1" class="headerlink" title="题目："></a>题目：</h2><p>给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m] 。请问 k[0]<em>k[1]</em>…*k[m] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p>
<p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p>
<h2 id="解法：-1"><a href="#解法：-1" class="headerlink" title="解法："></a>解法：</h2><p>添加大数求余：循环求余||快速幂求余算法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//循环求余</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">3</span>) <span class="keyword">return</span> n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> b = n % <span class="number">3</span>, p = <span class="number">1000000007</span>,a=n/<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">long</span> rem = <span class="number">1</span>, x = <span class="number">3</span>;</span><br><span class="line">        <span class="comment">// 循环求余数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;a; i++) &#123;</span><br><span class="line">            rem = (rem * x) % p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(b == <span class="number">0</span>) <span class="keyword">return</span> (<span class="keyword">int</span>)(rem * <span class="number">3</span>%p);</span><br><span class="line">        <span class="keyword">if</span>(b == <span class="number">1</span>) <span class="keyword">return</span> (<span class="keyword">int</span>)(rem * <span class="number">4</span>%p );</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)(rem * <span class="number">6</span>%p );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//快速幂求余</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">3</span>) <span class="keyword">return</span> n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> b = n % <span class="number">3</span>, p = <span class="number">1000000007</span>;</span><br><span class="line">        <span class="keyword">long</span> rem = <span class="number">1</span>, x = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> a = n / <span class="number">3</span> - <span class="number">1</span>; a &gt; <span class="number">0</span>; a /= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(a % <span class="number">2</span> == <span class="number">1</span>) rem = (rem * x) % p;</span><br><span class="line">            x = (x * x) % p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(b == <span class="number">0</span>) <span class="keyword">return</span> (<span class="keyword">int</span>)(rem * <span class="number">3</span> % p);</span><br><span class="line">        <span class="keyword">if</span>(b == <span class="number">1</span>) <span class="keyword">return</span> (<span class="keyword">int</span>)(rem * <span class="number">4</span> % p);</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)(rem * <span class="number">6</span> % p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cuttingRope</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">3</span>: <span class="keyword">return</span> n - <span class="number">1</span></span><br><span class="line">        a, b, p, x, rem = n // <span class="number">3</span> - <span class="number">1</span>, n % <span class="number">3</span>, <span class="number">1000000007</span>, <span class="number">3</span> , <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> a &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> a % <span class="number">2</span>: rem = (rem * x) % p</span><br><span class="line">            x = x ** <span class="number">2</span> % p</span><br><span class="line">            a //= <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> b == <span class="number">0</span>: <span class="keyword">return</span> (rem * <span class="number">3</span>) % p <span class="comment"># = 3^(a+1) % p</span></span><br><span class="line">        <span class="keyword">if</span> b == <span class="number">1</span>: <span class="keyword">return</span> (rem * <span class="number">4</span>) % p <span class="comment"># = 3^a * 4 % p</span></span><br><span class="line">        <span class="keyword">return</span> (rem * <span class="number">6</span>) % p <span class="comment"># = 3^(a+1) * 2  % p</span></span><br><span class="line"><span class="comment"># 由于语言特性，Python 可以不考虑大数越界问题</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cuttingRope</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">3</span>: <span class="keyword">return</span> n - <span class="number">1</span></span><br><span class="line">        a, b, p = n // <span class="number">3</span>, n % <span class="number">3</span>, <span class="number">1000000007</span></span><br><span class="line">        <span class="keyword">if</span> b == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">3</span> ** a % p</span><br><span class="line">        <span class="keyword">if</span> b == <span class="number">1</span>: <span class="keyword">return</span> <span class="number">3</span> ** (a - <span class="number">1</span>) * <span class="number">4</span> % p</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span> ** a * <span class="number">2</span> % p</span><br></pre></td></tr></table></figure>

<h1 id="面试题15-二进制中的一个数"><a href="#面试题15-二进制中的一个数" class="headerlink" title="面试题15 二进制中的一个数"></a>面试题15 二进制中的一个数</h1><h2 id="题目：-2"><a href="#题目：-2" class="headerlink" title="题目："></a>题目：</h2><p>请实现一个函数，输入一个整数，输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。</p>
<h2 id="解法：-2"><a href="#解法：-2" class="headerlink" title="解法："></a>解法：</h2><h3 id="思路一：-1"><a href="#思路一：-1" class="headerlink" title="思路一："></a>思路一：</h3><p>依次从右向左遍历二进制位，统计出一的个数；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// you need to treat n as an unsigned value</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 普通遍历法</span></span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n!=<span class="number">0</span>)&#123;</span><br><span class="line">            res+=n&amp;<span class="number">1</span>;</span><br><span class="line">            n&gt;&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hammingWeight</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">		<span class="comment">#普通遍历法</span></span><br><span class="line">        res=<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> n:</span><br><span class="line">            res+=n&amp;<span class="number">1</span></span><br><span class="line">            n&gt;&gt;=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="思路二：-1"><a href="#思路二：-1" class="headerlink" title="思路二："></a><a href="https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/solution/mian-shi-ti-15-er-jin-zhi-zhong-1de-ge-shu-wei-yun/" target="_blank" rel="noopener">思路二：</a></h3><p>利用n-1二进制位与n之间的不同，依次统计1的个数<br><img src="https://img-blog.csdnimg.cn/20200511142539510.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQzMzk2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// you need to treat n as an unsigned value</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n!=<span class="number">0</span>)&#123;</span><br><span class="line">            res++;</span><br><span class="line">            n=n&amp;(n-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hammingWeight</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># 借助n-1</span></span><br><span class="line">        res=<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> n:</span><br><span class="line">            res+=<span class="number">1</span></span><br><span class="line">            n=n&amp;(n<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>&lt;剑指offer&gt; 剑指offer 16、18</title>
    <url>/2020/05/13/%E5%89%91%E6%8C%87offer%5B16%E3%80%8118%5D/</url>
    <content><![CDATA[<p>摘要：<br>16 数值的整数次方<br>18 删除链表的节点</p>
<a id="more"></a>
<h1 id="面试题16-数值的整数次方"><a href="#面试题16-数值的整数次方" class="headerlink" title="面试题16 数值的整数次方"></a>面试题16 数值的整数次方</h1><h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p>实现函数double Power(double base, int exponent)，求base的exponent次方。不得使用库函数，同时不需要考虑大数问题。</p>
<h2 id="解法："><a href="#解法：" class="headerlink" title="解法："></a>解法：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">double</span> res=<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//Java 代码中 int32 变量 n \in [-2147483648, 2147483647]n∈[−2147483648,2147483647] ，</span></span><br><span class="line">        <span class="comment">//因此当 n = -2147483648n=−2147483648 时执行 n = -nn=−n 会因越界而赋值出错。</span></span><br><span class="line">        <span class="comment">//解决方法是先将 nn 存入 long 变量 bb ，后面用 bb 操作即可。</span></span><br><span class="line">        <span class="keyword">long</span> b=n;</span><br><span class="line">        <span class="keyword">if</span>(b&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            x=<span class="number">1</span>/x;</span><br><span class="line">            b=-b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(b&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(b%<span class="number">2</span>==<span class="number">1</span>)&#123;</span><br><span class="line">                res=res*x;</span><br><span class="line">            &#125;</span><br><span class="line">            x=x*x;</span><br><span class="line">            b=b/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">myPow</span><span class="params">(self, x: float, n: int)</span> -&gt; float:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> x: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        res=<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n&lt;<span class="number">0</span>:</span><br><span class="line">            x=<span class="number">1</span>/x</span><br><span class="line">            n=-n</span><br><span class="line">        <span class="keyword">while</span> n&gt;<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> n%<span class="number">2</span>==<span class="number">1</span>:</span><br><span class="line">                res=res*x</span><br><span class="line">            x=x**<span class="number">2</span></span><br><span class="line">            n//=<span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h1 id="面试题18-删除链表的节点"><a href="#面试题18-删除链表的节点" class="headerlink" title="面试题18 删除链表的节点"></a>面试题18 删除链表的节点</h1><h2 id="题目：-1"><a href="#题目：-1" class="headerlink" title="题目："></a>题目：</h2><p>给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。</p>
<p>返回删除后的链表的头节点。</p>
<h2 id="解法：-1"><a href="#解法：-1" class="headerlink" title="解法："></a>解法：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteNode</span><span class="params">(ListNode head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head.val==val) <span class="keyword">return</span> head.next;</span><br><span class="line">        ListNode pre=head;</span><br><span class="line">        ListNode cur=head.next;</span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="keyword">null</span>&amp;&amp;cur.val!=val)&#123;</span><br><span class="line">            pre=cur;</span><br><span class="line">            cur=cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            pre.next=cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteNode</span><span class="params">(self, head: ListNode, val: int)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> head.val==val: <span class="keyword">return</span> head.next</span><br><span class="line">        pre=head</span><br><span class="line">        cur=head.next</span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">and</span> cur.val!=val:</span><br><span class="line">            pre=cur</span><br><span class="line">            cur=cur.next</span><br><span class="line">        <span class="keyword">if</span> cur:</span><br><span class="line">            pre.next=cur.next</span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>&lt;剑指offer&gt; 剑指offer 19</title>
    <url>/2020/05/28/%E5%89%91%E6%8C%87offer%5B19%5D/</url>
    <content><![CDATA[<p>摘要：<br>19 正则表达式匹配</p>
<a id="more"></a>
<h1 id="面试题19-正则表达式匹配"><a href="#面试题19-正则表达式匹配" class="headerlink" title="面试题19 正则表达式匹配"></a>面试题19 正则表达式匹配</h1><h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p>请实现一个函数用来匹配包含’. ‘和’<em>‘的正则表达式。模式中的字符’.’表示任意一个字符，而’</em>‘表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”ab<em>ac</em>a”匹配，但与”aa.a”和”ab*a”均不匹配。</p>
<h2 id="解法："><a href="#解法：" class="headerlink" title="解法："></a><a href="https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/solution/zhu-xing-xiang-xi-jiang-jie-you-qian-ru-shen-by-je/" target="_blank" rel="noopener">解法：</a></h2><p><img src="https://img-blog.csdnimg.cn/20200515172247173.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQzMzk2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String A, String B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a=A.length();</span><br><span class="line">        <span class="keyword">int</span> b=B.length();</span><br><span class="line">        <span class="keyword">boolean</span>[][] f=<span class="keyword">new</span> <span class="keyword">boolean</span>[a+<span class="number">1</span>][b+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=a;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=b;j++)&#123;</span><br><span class="line">                <span class="comment">// 此判断可以直接得出空正则的所有情况</span></span><br><span class="line">                <span class="keyword">if</span>(j==<span class="number">0</span>)&#123;</span><br><span class="line">                    f[i][j]=i==<span class="number">0</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">// 针对非空正则进行计算</span></span><br><span class="line">                    <span class="keyword">if</span>(B.charAt(j-<span class="number">1</span>)!=<span class="string">'*'</span>)&#123;</span><br><span class="line">                            <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;(A.charAt(i-<span class="number">1</span>)==B.charAt(j-<span class="number">1</span>)||B.charAt(j-<span class="number">1</span>)==<span class="string">'.'</span>))</span><br><span class="line">                                f[i][j]=f[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                     <span class="comment">// 对于B中元素为‘*’，又可以分为两种情况：即为B中'*'前的一个元素可以与A中元素匹配与否</span></span><br><span class="line">                     <span class="comment">//f[i][j-2]是指直接获取B中此时的 ‘a*’忽视，赋值‘a*’之前的f值</span></span><br><span class="line">                        <span class="keyword">if</span>(j&gt;=<span class="number">2</span>)&#123;</span><br><span class="line">                            f[i][j] |=f[i][j-<span class="number">2</span>];</span><br><span class="line">                        &#125;</span><br><span class="line">                      <span class="comment">//接着回来判断一下是否需要看这个‘*’之前的一个模板元素，如果需要看就将A中的元素前移一位，</span></span><br><span class="line">                      <span class="comment">//有可能f[i-1][j]为false，但前一步中的f[i][j-2]将这个f[i][j]值善后。</span></span><br><span class="line">                     <span class="comment">//比如A=‘aaa’；B=‘aa*a’ i=2，j=3时，f[i][j]就是通过|=符号获取的f[i][j-2]的值。</span></span><br><span class="line">                        <span class="keyword">if</span>(i&gt;=<span class="number">1</span>&amp;&amp;j&gt;=<span class="number">2</span>&amp;&amp;(A.charAt(i-<span class="number">1</span>)==B.charAt(j-<span class="number">2</span>)||B.charAt(j-<span class="number">2</span>)==<span class="string">'.'</span>))</span><br><span class="line">                       	 	f[i][j] |=f[i-<span class="number">1</span>][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[a][b];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isMatch</span><span class="params">(self, s: str, p: str)</span> -&gt; bool:</span></span><br><span class="line">        s, p = <span class="string">'#'</span>+s, <span class="string">'#'</span>+p</span><br><span class="line">        m, n = len(s), len(p)</span><br><span class="line">        dp = [[<span class="literal">False</span>]*n <span class="keyword">for</span> _ <span class="keyword">in</span> range(m)]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">                <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">                    dp[i][j] = j &gt; <span class="number">1</span> <span class="keyword">and</span> p[j] == <span class="string">'*'</span> <span class="keyword">and</span> dp[i][j<span class="number">-2</span>]</span><br><span class="line">                <span class="keyword">elif</span> p[j] <span class="keyword">in</span> [s[i], <span class="string">'.'</span>]:</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>]</span><br><span class="line">                <span class="keyword">elif</span> p[j] == <span class="string">'*'</span>:</span><br><span class="line">                    dp[i][j] = j &gt; <span class="number">1</span> <span class="keyword">and</span> dp[i][j<span class="number">-2</span>] <span class="keyword">or</span> p[j<span class="number">-1</span>] <span class="keyword">in</span> [s[i], <span class="string">'.'</span>] <span class="keyword">and</span> dp[i<span class="number">-1</span>][j]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title>&lt;论文&gt;A Systematic Evaluation of StaticAPI-Misuse Detectors</title>
    <url>/2020/05/28/A%20Systematic%20Evaluation%20of%20StaticAPI-Misuse%20Detectors/</url>
    <content><![CDATA[<p>摘要：<br>论文题目：A Systematic Evaluation of StaticAPI-Misuse Detectors<br>论文作者：Sven Amann, Hoan Anh Nguyen, Sarah Nadi, Tien N. Nguyen,and Mira Mezini<br>论文发表：IEEE TRANSACTIONS ON SOFTWARE ENGINEERING, VOL. 45, NO. 12, DECEMBER 2019<br>论文地址：<a href="https://arxiv.org/pdf/1712.00242.pdf" target="_blank" rel="noopener">https://arxiv.org/pdf/1712.00242.pdf</a></p>
<a id="more"></a>
<p>注意：<br>仅作本人参考笔记，机器翻译质量较低。<br>本翻译中的API滥用是指API误用，比较麻烦就没改。</p>
<h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h1><p>应用程序编程接口（API）通常具有使用规范，例如对调用顺序或调用条件的限制。API的滥用（即违反这些限制）可能导致软件崩溃，错误和漏洞。 尽管研究人员在过去的二十年中开发了许多API滥用检测器，但最近的研究表明API滥用仍很普遍。因此，<strong>我们需要了解现有检测器的功能和局限性，以提高技术水平</strong>。 在本文中，我们<strong>提出了首次定性和定量评估</strong>，该评估将静态API滥用检测器沿相同尺寸与原始作者进行了比较。 为了实现这一目标，我们在误用数据集MUBENCH的基础上，<strong>开发了API滥用分类器MUC和用于检测器比较的自动化基准MUBENCHPIPE</strong>。 我们的<strong>结果表明，现有检测器的功能差异很大，并且现有检测器尽管能够检测到误用，但精度和召回率极低</strong>。 系统的根本原因分析表明，最重要的是，<strong>检测器需要超越天真的假设，即与最常用用法的偏离即为API误用，并且需要获取其他用法示例来训练其模型</strong>。 我们<strong>提出了更强大的API误用检测器的可能方向</strong>。</p>
<p><strong>Index Terms—API-misuse detection, survey, misuse classification, benchmark, MUBench</strong></p>
<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>应用程序编程接口（API）的不正确使用或API的不当使用均违反了API的（隐式）使用约束。 一个使用约束的示例，它希望在调用Iterator上的next（）之前检查hasNext（）是否返回真，以避免在运行时发生NoSuchElementException。 错误使用API​​是导致软件错误，崩溃和漏洞[1]，[2]，[3]，[4]，[5]，[6]，[7]的普遍原因。 尽管API使用限制的高质量文档可能会有所帮助，但至少以当前形式，通常不足以解决问题[8]。 例如，<strong>最近的一项实证研究表明，Android开发人员更喜欢非正式引用，例如Stack-Overflow，而不是正式的API文档，尽管前者提倡了许多不安全的API用法[9]</strong>。 我们也确认了这种非安全性API的趋势：修改基础集合后，不得使用Iterator的Iterator实例，否则会引发ConcurrentModificationException。 此约束及其违反的后果已得到详细记录。尽管如此，对有关ConcurrentModificationException的2,854个Stack-Overflow回答中前5％的回顾显示，其中有57％的人询问如何修复包含上述误用现象的某些代码[10]。</p>
<p>理想情况下，开发环境应帮助开发人员实现正确的用法以及发现和解决现有的滥用问题。 <strong>在本文中，我们将重点放在识别给定代码库中的误用的工具上，特别是那些自动推断API使用规范并通过静态代码分析来识别违规的工具。 我们将这些工具称为静态API滥用检测器</strong>。</p>
<p>现阶段已经进行了许多尝试来解决API滥用的问题。 现有的静态滥用检测器通常会滥用模式，即频繁发生的等效API使用，并将与这些模式有关的任何异常报告为潜在的滥用[1]，[11]，[12]，[13]，[ 14]，[15]，[16]，[17]，[18]，[19]，[20]。 <strong>这些方法的不同之处在于它们如何定义用法和频率，以及它们应用于识别模式和违规的技术</strong>。 <strong>尽管在API滥用检测方面进行了大量工作，但API滥用在实践中仍然存在，如最近的研究显示[9]，[21]。 为了提高API滥用检测的最新水平，我们需要了解现有方法之间的比较方式，以及它们当前的局限性。</strong> 这将使研究人员可以通过增强其优势并克服其弱点来改进API滥用检测器。</p>
<p>在这项工作中，我们提出了API滥用分类（MUC）作为API滥用的分类法，并提出了评估静态API滥用检测器功能的框架。 为了创建这样的分类法，我们需要各种不同的API滥用示例。 在我们之前的工作中，我们描述了<strong>MUBENCH，这是一个90个API滥用的数据集，它是通过检查来自现有错误数据集的1200多个报告并进行开发人员调查而收集的</strong>[3]。 MUBENCH向我们提供了创建分类法所需的滥用示例。 为了涵盖API滥用的整个问题空间，在本文中，我们将通过研究API使用指南[8]，[22]中的示例，为该数据集添加更多误用。 <strong>使用MUC，我们在质量上比较了12个现有的探测器，并确定了它们的缺点</strong>。 例如，我们发现只有很少的检测器能够检测到与条件或异常处理相关的误用。 我们与检测器的原始作者确认了这一评估。</p>
<p>上一步为我们提供了现有检测器的概念比较。 <strong>我们还希望通过经验来比较这些API滥用检测器的精度和调用率</strong>。 由于检测器使用的底层机制和表示形式不同，因此这是一项艰巨的任务。 为了进行这种经验比较，我们<strong>建立了MUBENCHPIPE</strong>，这是<strong>第一个对API滥用检测器进行基准测试的自动化管道</strong>。我们的自动基准测试利用了MUBENCH和我们在这项工作中收集到的误用，并在其上创建了一个基础结构来运行检测器并比较其结果。 <strong>我们基于29个实际项目和25个手工制作的示例执行了三个实验，以经验评估和比较四个最新探测器</strong>。 我们排除了其他八个检测器，因为两个检测器依赖于已终止的Google代码搜索[23]，五个目标C / C ++代码和一个目标Dalvik Bytecode，<strong>而我们的基准测试包含Java滥用行为</strong>。 在实验P中，我们在每个项目的设置中测量检测器的精度，在检测器中，他们挖掘模式并检测来自MUBENCH的单个项目中的违规行为。 在实验RUB中，我们针对MUBENCH中已知的误用情况确定了探测器召回的上限。 通过为检测器提供精心设计的正确用法示例，使他们适应所需的模式，我们可以排除训练公式中数据不足的可能性。 最后，在实验R中，我们根据每个项目的设置，对MUBENCH数据集和检测器自己从ExperimentP确认的发现进行了测量。</p>
<p>我们的概念分析显示了API滥用的许多先前被忽略的方面，例如错误的异常处理和冗余调用。 <strong>我们的定量结果表明，如果为模式挖掘提供了正确的用法，则误用检测器能够检测到误用</strong>。 但是，它们的精度极低，并且在现实环境中会被召回。我们确定了误报的四个根本原因和误报的七个根本原因。 最重要的是，为了提高精度，检测器需要超越天真的假设，即偏离最频繁使用情况对应于误用，例如，通过建立概率模型来推理其各自上下文中的使用可能性。 为了提高召回率，检测人员需要获取可能来自不同来源的更多正确的用法示例，并考虑程序语义，例如API用法之间的类型层次结构和隐含依赖关系。 这些新颖的见解可以通过我们的自动基准测试来实现。 我们的经验结果代表了一个警钟，揭示了该领域工具和评估策略的严重实际限制。 最重要的是，检测器的召回率极低，通常无法评估。 此外，我们发现检测器在单个项目中的应用似乎没有给他们足够的数据来学习正确使用API​​的良好模型。</p>
<p>总而言之，本文对API滥用检测领域做出了以下贡献：</p>
<ul>
<li>API滥用的分类法MUC，提供了一个概念框架来比较API滥用检测器的功能。</li>
<li>对基于MUC的12个最新的误用检测器进行了调查和定性评估。</li>
<li>一个针对API滥用检测器的公开自动化基准测试管道MUBENCHPIPE，它有助于对滥用检测器进行系统且可重现的评估。</li>
<li>使用MUBENCHPIPE的对四个现有误用检测器的召回率和精度进行的经验比较。我们的工作是首次在概念和实际水平上比较不同的检测器，更重要的是，这是第一个测量检测器的召回率的方法，揭示了它们的不良性能。</li>
<li>对检测器精度低和召回率低的根本原因进行系统分析，以使研究人员采取行动。</li>
</ul>
<p>我们的基准测试基础结构是公开可用的[24]，我们的Web页面[10]提供了有关结果的完整详细信息。</p>
<h1 id="2-BACKGROUND-AND-TERMINOLOGY"><a href="#2-BACKGROUND-AND-TERMINOLOGY" class="headerlink" title="2.BACKGROUND AND TERMINOLOGY"></a>2.BACKGROUND AND TERMINOLOGY</h1><p>API的用法（简称用法）是使用给定的API完成某些任务的一段代码。 它是基本程序元素的组合，例如方法调用，异常处理或算术运算。 API使用中此类元素的组合受到约束，具体取决于API的性质。 我们称这种约束为使用约束。 例如，可能需要以特定的顺序调用两种方法，除法不能与零的除数一起使用，并且文件资源需要沿着所有执行路径释放。 当一种用法违反一个或多个此类约束时，我们称其为滥用，否则称为不正确的用法。</p>
<p>可以通过对源代码或二进制文件的静态分析以及通过动态分析（即运行时监视或运行时数据（例如跟踪或日志）的分析）来进行API滥用的检测。 在这两种情况下，检测都需要指定正确的API使用规范以发现违规情况，或者需要指定滥用以查找实例。 可以由专家手动制作这些规格，或者由算法自动推断。 自动规范推断（排序）可以再次例如基于代码样本或文档而静态地，以及例如基于跟踪或日志而动态地接近。</p>
<p>由于手动制定和维护规范的成本很高，因此在这项工作中，我们专注于自动检测器，我们称此类工具为API滥用检测器。 <strong>在文献中，我们找到了静态滥用检测器，它可以静态挖掘规范并通过静态分析检测滥用，例如[1]，[13]，[15]；动态滥用检测器，它可以动态挖掘规格并通过动态分析来检测滥用，例如， [25]，[26]； 混合滥用检测器，例如，将动态规范挖掘与静态检测结合在一起的方法[27]。 在这项工作中，我们专注于静态API滥用检测器。</strong></p>
<p><strong>静态API滥用检测通常是通过检测异常代码[1]，[11]，[12]，[13]，[14]，[15]，[16]，[17]，[18]，[19]， [20]，[28]</strong>。 <strong>关键思想是错误违反了代码应遵守的约束，并且在足够多正确使用示例的情况下，此类违反会出现异常</strong>。 我们称这种在程序中经常出现的用法为pattern。 通过检测异常代码来识别错误的假设是，模式与正确的用法（规范）相对应，因此，与这些模式有关的异常是滥用。 这样的方法可以发现流行的库 [1]，[11]，[13]，[15]，[19]，[28]在使用中的错误。</p>
<p>在我们以前的工作[3]中，我们通过查看21个现实项目的错误报告并就API滥用对开发人员进行了调查，收集了JavaAPI滥用的数据集。 我们称此数据集为MUBENCH。 它包含90个滥用，实际项目中的73个滥用和调查中的17个滥用（请参见表1，第1行）。 对于每个现实世界中的滥用，数据集都会标识该滥用在哪里的项目，包含该滥用的项目版本以及修复该滥用的提交。 对于其他滥用，MUBENCH提供了手工制作的滥用示例及其修复程序。<br><img src="https://img-blog.csdnimg.cn/20200517181832991.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQzMzk2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>在我们以前的工作[3]中，我们通过查看21个现实项目的错误报告并就API滥用对开发人员进行了调查，收集了JavaAPI滥用的数据集。 我们称此数据集为MUBENCH。 它包含90个滥用，实际项目中的73个滥用和调查中的17个滥用（请参见表1，第1行）。 对于每个现实世界中的滥用，数据集都会标识该滥用在哪里的项目，包含该滥用的项目版本以及修复该滥用的提交。 对于其他滥用，MUBENCH提供了手工制作的滥用示例及其修复程序。</p>
<h1 id="3-THE-API-MISUSE-CLASSIFICATION-MUC"><a href="#3-THE-API-MISUSE-CLASSIFICATION-MUC" class="headerlink" title="3.THE API-MISUSE CLASSIFICATION(MUC)"></a>3.THE API-MISUSE CLASSIFICATION(MUC)</h1><p>在本节中，我们介绍API滥用分类，这是我们针对API滥用的分类。 我们从MUBENCH数据集中的滥用示例中得出MUC。 在<strong>第4节中，我们使用MUC定性比较现有的API滥用检测器的功能</strong>。 在<strong>第7节中，我们使用MUC定义我们对探测器性能</strong>的期望。 在介绍分类本身之前，我们简要讨论现有的分类，以激发对MUC的需求。</p>
<h2 id="3-1-Motivation-for-MUC"><a href="#3-1-Motivation-for-MUC" class="headerlink" title="3.1 Motivation for MUC"></a>3.1 Motivation for MUC</h2><p>（<strong>1.</strong>）IEEE有一个用于对软件缺陷进行分类的标准[29]，它是IBM ORTHOGONALDEFECTCLASSIFICATION（ODC）[30]的基础。 ODC使用缺陷类型作为对缺陷进行分类的方面之一。 缺陷类型由概念上的程序元素（例如函数，检查，赋值，文档或算法）和违规类型（即丢失或不正确）组成。 （<strong>2.</strong>）最近，贝勒等。 [31]提出了GENERAL DEFECT CLASSIFICATION（GCD），这是一种远程ODC后裔，专为比较自动化静态分析工具的功能而设计。这两种分类都涵盖了所有类型的软件缺陷的整个领域。 为了比较API滥用检测器的功能，我们需要对两者中的一个类别子集进行更细粒度的区分。</p>
<p>过去的工作介绍了API使用指令的实证研究和分类法[8]，[22]。 这些指令中的许多指令可以被视为我们术语中的使用限制，因此，它们的违规行为被视为滥用。 但是，其他指令没有制定约束条件。 示例是明确允许将null作为参数传递的指令和指示实现行为的替代方法（可能具有不同的权衡）的指令。 因此，我们不能将使用指令的分类法直接转换为滥用的分类法。 相反，为了考虑可以被视为使用限制的方向，我们通过手工制作的违反它们的滥用示例来扩展MUBENCH [3]，这是我们从研究中的示例中得出的。这给我们带来了10种额外的滥用，从而导致总计 用于MUC和实验的100种滥用（请参阅表1，第2行）。 为简单起见，我们随后将此扩展数据集称为MUBENCH。</p>
<h2 id="3-2The-Classification"><a href="#3-2The-Classification" class="headerlink" title="3.2The Classification"></a>3.2The Classification</h2><p>我们使用扎根理论[32]的变体开发了MUC：遵循我们的API滥用概念，即一个或多个违反API使用规范，这项工作的第一作者研究了MUBENC中的所有滥用，提出了特征标签 直到每次滥用都被标记了至少一个标签。 随后，所有作者迭代地重新审视了标记的滥用，以统一语义上等效的标记和与组相关的标记，直到我们有了一致的分类法为止。 最后，我们有两个维度，它们的交集描述了MUBENCH中的所有违规：所涉及的API-使用元素的类型和违规的类型。因此，我们<strong>将违例定义为一对violation type和API-usage element</strong>。</p>
<p><strong>API-usage element</strong>是出现在API用途中的程序元素。 MUBENCH中的误用涉及以下元素：method calls,conditions,iterations, 和exception handling.。 请注意，我们将基本运算符（例如算术运算符）视为方法。 对于条件，由于其独特的属性，我们进一步区分了空校验，值或状态条件，同步条件和上下文条件。</p>
<p><strong>violation type</strong>描述了用法如何违反关于给定用法元素的给定用法约束。 在MUBENCH中，我们发现两种违规类型：missing和redunddant。 缺少类型的违例来自强制使用元素存在的约束。 它们通常会导致程序错误。 此类违规的一个示例是“缺少方法调用”。 违反冗余类型的约束来自强制使用元素不存在或声明使用元素不必要的约束。 请注意，在任何一种情况下，元素的重复都可能具有不良影响，例如错误或性能下降。 这种冗余违规的示​​例是“冗余方法调用”。</p>
<p>表2列出了MUC的总结。 <strong>单元格中的数字显示MUBENCH中有多少次滥用有相应的违法行为</strong>。 <strong>请注意，由于一次滥用可能会导致多次违规，因此表格中的各个单元格总计超过我们收集的100次滥用</strong>。 该表显示，最常见的冲突是缺少方法调用，空检查以及值或状态条件。 冗余调用和missing exception处理的频率较低，但仍然很普遍，尽管我们只有很少的其他违规示例。<br><img src="https://img-blog.csdnimg.cn/20200517182159753.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQzMzk2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>现在，我们讨论表2中所示的不同违规类别，其中按涉及的API使用元素分组。</p>
<h3 id="3-2-1-Method-Calls"><a href="#3-2-1-Method-Calls" class="headerlink" title="3.2.1 Method Calls"></a>3.2.1 Method Calls</h3><p>方法调用是API使用的最重要元素，因为它们是客户端代码和API之间进行通信的主要方式。</p>
<p>一种违规类别是缺少方法调用，如果使用未调用API使用约束所强制的特定方法，则会发生这种情况。 例如，如果用法在向JFrame添加元素后未在JFrame上调用validate（），则更改变为可见是必需的。</p>
<p>另一种情况是冗余方法调用，如果usage调用受API usage约束限制的某个方法，则会发生这种情况。 例如，如果用法在当前正在迭代的列表上调用remove（），则在后续迭代中导致异常。</p>
<h3 id="3-2-2-Conditions"><a href="#3-2-2-Conditions" class="headerlink" title="3.2.2 Conditions"></a>3.2.2 Conditions</h3><p>客户代码通常需要确保与API进行有效通信的条件，以便遵守API的使用限制。 通常有其他方法可以确保此类条件。 例如，要确保一个集合不为空，可以检查isEmpty（），检查其size（）或向其中添加一个元素。 请注意，特别是检查也是客户端代码根据程序输入改变用法的一种手段。</p>
<p>一种违规类别是缺少条件，如果使用不能确保API使用约束所规定的某些条件，则会发生这种情况。 一种情况是缺少空值检查，例如，一种用法是否无法确保接收者或​​呼叫的参数不为空。另一种情况是缺少值或状态条件，例如，一种用法是否无法确保使用一个键来访问Map之前，Map包含某个键 。 在多线程环境中，可能会发生缺少同步的情况，例如，如果使用情况在更新从多个线程访问的哈希映射之前未获得锁[22]。 最后，例如，如果用法未能确保在事件调度线程（EDT）上更新SWING中的GUI组件，则可能会发生缺少上下文条件的情况[8]。</p>
<p>另一种情况是冗余条件，其中条件阻止用法的必要部分（例如方法调用）沿某些执行路径执行，或者仅是冗余的。一种情况是冗余空检查，例如，如果用法仅在对相应对象调用了方法之后才检查空性。 另一种情况是冗余值或状态条件，例如，如果用法在保证包含元素的集合的情况下上加入isEmpty（）。 在多线程环境中，可能会发生冗余同步条件，例如，如果使用情况请求它已经持有的锁，则可能导致死锁。 最后，冗余的上下文条件也可能发生，例如，如果在另一个线程上执行了JUNIT断言，则JUNIT框架无法捕获其断言。</p>
<h3 id="3-2-3-Ieration"><a href="#3-2-3-Ieration" class="headerlink" title="3.2.3 Ieration"></a>3.2.3 Ieration</h3><p>迭代是与API交互的另一种方法，特别是与集合和IO流一起使用。 它采用循环和递归方法的形式。 请注意，各个用法约束是关于（不是）重复使用（一部分），而不是控制执行的条件。</p>
<p>一个违规类别是缺少迭代，如果不对usage重复检查一部分使用情况后必须再次检查APIusage约束要求的情况，则会发生这种情况。 例如，Java文档规定，调用Object.wait（）必须始终在循环中发生。 用法调用wait（）暂停当前线程，直到接收到中断为止。 它这样做是为了等待直到某种条件成立，例如直到资源变得可用为止。 由于中断随时可能发生，因此恢复使用必须检查条件，如果不成立，则再次检查call wait（）。 请注意，在条件变为真之前，这可能会发生任意次数。 因此，对条件仍然进行检查的用法违反了用法约束。</p>
<p>另一种情况是冗余迭代，如果重复使用的一部分，则可能会重复执行API使用约束任务一次或仅是冗余的，就会发生这种情况。 例如，可以在循环中重用aCipherinstance来加密值的集合，但是通过调用init（）进行初始化必须恰好发生在一次，即循环之前。 请注意，如果在循环内调用了init（），则只对方法进行了一次调用（使用限制所要求的），但是将其包含在迭代中会引起冲突。</p>
<h3 id="3-2-4-Exception-Handling"><a href="#3-2-4-Exception-Handling" class="headerlink" title="3.2.4 Exception Handling"></a>3.2.4 Exception Handling</h3><p>异常是API将错误传达给客户端代码的一种方式。 不同错误的处理通常取决于特定的API。</p>
<p>一种违规类别是缺少异常处理，如果使用未按照API使用约束的规定采取措施从可能的错误中恢复，则会发生异常处理。 例如，在使用外部提供的加密密钥初始化aCipher时，应处理han-dleInvalidKeyException。 另一个例子是使用后也需要关闭的资源，如果有异常情况也是如此。 通常通过finallyblock来实现这种保证，但是也可以使用try-with-resources构造甚至在多个catchblock中进行相应的处理。</p>
<p>另一种情况是冗余异常处理，如果用法截获了不应明确捕获或处理的异常，则会发生这种情况。 例如，在应用程序中执行命令时，catchingThrowable可能会抑制cancellationException，从而阻止用户取消该命令。</p>
<h1 id="4-CONCEPTUAL-CLASSIFICATION-OF-EXISTING-MISUSE-DETECTORS"><a href="#4-CONCEPTUAL-CLASSIFICATION-OF-EXISTING-MISUSE-DETECTORS" class="headerlink" title="4.CONCEPTUAL CLASSIFICATION OF EXISTING MISUSE DETECTORS"></a>4.CONCEPTUAL CLASSIFICATION OF EXISTING MISUSE DETECTORS</h1><p>为了提高API滥用检测的技术水平，我们需要了解现有滥用检测器的功能和缺点。 为了识别检测器，我们从Robillard等人在自动API属性推断技术调查中列出的有关API滥用检测的出版物开始。 [33]。 <strong>根据ACM数字图书馆或IEEE Xplore数字图书馆，对于每个出版物，我们都将其视为相关作品的所有出版物以及引用它们的所有出版物进行了研究。 我们递归地重复此过程，直到没有发现新的检测器为止。</strong></p>
<p>我们<strong>将MUC用于检测器的定性比较</strong>，即我们评估每个检测器相对于MUC的概念能力，以获得现有检测器的概念分类。 我们使用已发布的描述和每个检测器的结果来从概念上确定它们可以检测到哪些MUC类别。 为了降低主观性，我们与各自的作者确认了我们的能力评估和探测器的描述，但PR-MINER和COLIBRI / ML的作者没有对此做出回应。 表3总结了结果。 我们还描述了用于评估每个检测器的策略，并总结了表4中的策略。</p>
<p><img src="https://img-blog.csdnimg.cn/20200517182907626.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQzMzk2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">)<img src="https://img-blog.csdnimg.cn/20200517182922680.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQzMzk2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>PR-MINER是C的滥用检测器[11]。 它将sussus编码为在同一函数内调用的所有函数名的集合，然后使用频繁项集挖掘来查找最少支持15种用法的模式。这里的违规行为是模式的严格子集，发生频率至少是该模式的十倍。 为了修剪误报，PR-MINER应用过程间分析，即，对于每次发生的违规，它都会检查丢失的调用是否在被调用方法中发生。 此分析最多跟踪3个级别的呼叫路径。 所报告的违规行为由相应模式的支持进行排序。PR-MINER检测到缺少的方法调用。 PR-MINER作者的评估将检测器分别应用于三个目标项目，从而发现了违反项目特定模式的情况。 作者回顾了所有项目中报告的前60名违规行为，发现了18.1％的真实阳性（单个项目中分别为26.7％，10.0和14.3％）。</p>
<p>CHRONICLER是C的滥用检测器[34]。 它从过程间控制流图中挖掘频繁的呼叫优先关系。 如果关系在所有执行路径中至少占80％，则认为该关系是频繁的。 这种关系不成立的路径被报告为冲突。CHRONICLER检测到缺少的方法调用。 由于循环只展开一次，因此无法检测到缺少的迭代。 CHRONICLER的作者进行的评估将检测器应用于五个项目，从而发现了违反项目特定模式的行为。 作者将已识别的协议与一个API的已记录协议进行了比较，并讨论了一些通过其工具发现的实际错误的示例。</p>
<p>COLIBRI / ML是C的另一种滥用检测器[12]。 它使用形式概念分析[35]重新实现PR-MINER，以加强该方法的理论基础。 因此，其功能与PR-MINER的功能相同。 COLIBRI / ML的作者进行的评估将检测器应用于五个目标项目，从而发现了违反项目特定模式的情况。 尽管在论文中预先提出了一些检测到的违规行为，但没有报告有关检测器发现质量的统计数据。</p>
<p>JADET是Java的滥用检测器[13]。 它使用COLIBRI / ML [12]，但它不仅编码方法名称，还编码方法调用顺序和用法中的接收者。 它建立一个有向图，其节点表示对给定对象的方法调用，其边缘表示控制流。 从该图可以得出每个呼叫顺序关系的一对呼叫。 这些对的集合构成了Min-ing的输入，Min-min的最小支持为20，标识了模式（即，对的集合）。违反可能会丢失所侵犯模式的最多2个属性，并且至少需要发生一次 次数比模式少。 检测到的违规将按u s = v进行排序，从而说明违规模式的支持情况，针对该模式违规的次数以及该模式的唯一性因素。 JADET检测到丢失的方法调用。 JADET的作者将检测器应用于五个目标项目，从而发现了违反项目特定模式的情况，它可能会将缺失的循环检测为从循环头中的方法调用到其自身的缺失的调用顺序关系。作者审查了每个项目报告的前十大违规情况，发现真正的正面肯定率为6.5％（单个项目的正确率分别为0、0、7.7、10.5和13.3％）。 其他调查结果分为代码气味（6.5）或提示1（35.0％）。</p>
<p>后来的研究[37]使用最小模式支持200，一次将JADET应用于6,097个项目（多项目设置）。 作者回顾了来自20个项目的随机样本中前25％的发现，共50个发现，发现8％的真实阳性。 其他发现被归类为代码气味（14.0％）。</p>
<p>RGJ07是C的滥用检测器[14]。 它将用法编码为每个变量的属性集。 属性是与文字，函数调用中的参数位置以及赋值的比较。 对于每个调用，它都会为调用的参数创建一组属性集。 它针对特定功能的所有组，应用序列挖掘来学习控制流属性的公共序列，并使用频繁项挖掘来识别所有其他属性类型的所有公共集，随后识别出违反公共属性序列和集的情况。 RGJ07旨在检测丢失的情况。 从它编码的属性中，它可以检测缺少的空检查和缺少的值或状态条件。 由于模式包含对参数的先前调用，因此如果各个调用与模式中的另一个调用共享参数，它也可能检测到未调用。 RGJ07作者的评估将检测器应用于单个项目，从而发现了违反项目特定模式的行为。 作者讨论了使用其方法检测到的实际错误的几个示例，但没有报告检测性能的统计信息。</p>
<p>ALATTIN是Java [18]的滥用检测器，它是用于条件检查的专用替代模式。 对于每个目标方法，它都会查询代码搜索引擎GOOGLECODESEARCH以查找示例用法。 从每个示例中，提取出一组关于接收器的条件检查和条件检查的规则，参数以及m的返回值，例如“ booleancheck onreturnofIterator.hasNextbeforeIterator.next”。 然后，对这些规则应用频繁项目集挖掘，以最少40％的支持率获得模式。 对于每个这样的模式，它都提取不遵守该模式的所有组的子集，并对该子集重复挖掘以获得频率不低于20％的不频繁模式。 最终，它通过析取结合了同一方法的所有频繁和不频繁模式。 如果拥有init的规则集不是任何替代模式的超集，则分析的方法将产生冲突。 违规由相应模式的支持进行排名。 因此，ALATTIN会检测到缺失的null检验以及缺失的值或状态条件，这些条件由检验确保并且不涉及文字。 它还可能检测到检查中丢失的方法调用。 ALATTIN的作者进行的评估将检测器应用于六个项目。 由于它向代码搜索引擎查询用法示例，因此它可以检测到跨项目模式的违反情况。 作者手动审查了每个项目中前十大模式的所有违规情况，总共发现了532个结果，并确认29.5％的人发现缺失情况检查（单个项目分别为12.5、26.2、28.1、32.7、52.6和100％ ）。考虑到频繁使用替代模式，平均可将误报率降低15.2％，将准确性提高到33.3％。 考虑到频繁使用和不频繁使用的替代方法，平均误报率平均降低了28.1％，导致准确率达到了37.8％，但又引入了1.5％的误报率，因为多次发生的误用被误认为是不常见的模式。</p>
<p>AX09是用于C [16]的滥用检测器，专门用于检测错误的错误处理，通过返回（并检查）错误代码来实现。 它区分正常路径，即从主要功能的开始到结束的执行路径，以及错误路径，即从主要功能的开始到错误处理块中的退货声明的路径。 AX09使用下推模型检查来生成诸如方法调用序列之类的路径，并将频繁子序列挖掘应用于发现模式，最低支持80％（但至少使用5次）。 然后，它使用下推模型检查来验证对这些模式的遵守情况并识别出各自的违规行为。 最后，它通过跟踪变量值并排除不可能发生的错误情况来过滤误报。 它可以检测错误处理函数中缺少的错误处理以及方法调用。 由于它可以通过一组预定义的检查来识别错误处理块，因此在缺少错误处理块的情况下，它还可以检测到缺少空检查和值或状态条件的缺失.AX09作者的评估将检测器分别应用于三个项目，从而发现了违规情况 项目特定模式。 作者手动审查了所有292个发现，并确认90.4％的真实阳性（单个项目分别为50.0、90.3和93.5％）。</p>
<p>CAR-MINER是C ++和Java的滥用检测器[17]，也专门用于检测错误的错误处理。 对于给定代码语料库中的每个分析方法，它都会查询代码搜索引擎GOOGLECODESEARCH以查找示例用法。 从示例中，它构建了一个异常流图（EFG），即带有额外边缘的控制流图，以实现出色的流程。 它从EFG生成正常的呼叫序列，这些序列导致当前分析的呼叫和例外呼叫序列，这些序列沿着异常边缘从呼叫中引出。 随后，它挖掘正常序列和异常序列之间的关联规则，最小支持为40％。 为了检测违规，CAR-MINER提取目标方法调用的常规调用序列和异常调用序列。 然后，它使用学习的关联规则来确定预期的例外处理，如果实际序列不包括违规，则报告违规。 CAR-MINER检测错误处理函数之间缺少的异常处理以及方法调用。 CAR-MINER的作者进行的评估将检测器应用于五个项目。 由于它向代码搜索引擎查询用法示例，因此它可以检测到跨项目模式的违反情况。 作者手动检查了每个项目违反前十名关联规则的所有行为，总共264项违规行为，并确认60.1％的人识别错误处理错误（单个项目中为41.1％，54.5％，68.2％，68.4％和82.3％）。 其他发现被归类为提示（3.0％）。</p>
<p>GROUMINER是Java的滥用检测器[15]。 它为每个目标方法创建基于图形的对象使用表示（GROUM）。GROUM是有向无环图，其节点表示方法调用，分支和循环，并且其边缘编码控制和数据流。 GROUMINER在此类图的集合上进行频繁子图挖掘，以检测最小支持为6的重复使用模式。当子模式的所有出现中至少有90％可以扩展到更大的模式时，但是有些不能，则有瑟拉瑞纳可伸长的出现 被视为违法行为。 请注意，此类违规始终恰好是一个无节点而不是一个模式。 模式和违规的检测同时发生。 违规行为按其稀有程度排序，即模式的支持程度高于违规的支持程度。 GROUMINER检测丢失的方法调用。 它还可以检测丢失的条件并以缺少分支或循环节点的粒度进行循环。 但是，它不能考虑实际情况。 GROU-MINER作者的评估将检测器分别应用于9个项目，从而发现了违反项目特定模式的情况。 作者审查了每个项目中排名前10位的违规行为，共得出184个发现，并发现了5.4％的真实肯定（单个项目的3倍0％，5倍6.7％和一次7.8％）。 其他发现被分类为code smells（7.6％）或提示（6.0％）。</p>
<p>DMMC是Java [36]的滥用检测器，专门用于调用方法。 该检测基于类型用法，即在给定方法中在给定接收器类型上调用的方法集。 如果两种用法的预期集完全匹配，则两种用法完全相似；如果其中一种包含正好一种附加方法，则它们几乎相似。 该检测基于这样的假设：违规应仅具有很少的完全相似的用法，但有许多几乎相似的用法。用法x被违规的可能性以范围分数¼1jEðxÞj=ðjEðxÞjþjAðXÞjÞ表示，其中EðxÞ是一组与x和Aðxexactly完全相似的用法。 几乎相似的 如果用法的陌生度得分高于0.97，则认为该用法为违规。 DMMC仅通过一个缺失的方法调用来检测滥用情况.DMMC的作者进行评估，将检测器应用于单个项目，从而发现了特定于项目的违规行为。作者手动审查了所有奇怪度得分均高于97％的发现，总计 19个发现，并确认73.7％为真实肯定。 后来的研究[1]将DMMC分别应用于三个项目，从而发现了针对一组预定义API的特定于项目的违规行为。 作者报告说，他们手动检查了大约30个发现，并确认了17个（56：7％）是肯定的。其他被归类为使用过的API中的错误的变通办法。</p>
<p>TIKANGA是在JADET上构建的Java [19]滥用检测器。 它将简单的调用顺序属性扩展到有关对象用法的generalComputation树逻辑公式。 具体来说，它使用需要进行特定调用的公式，需要顺序进行两次调用的for-mulae以及需要特定调用才能发生的公式。 它使用模型检查来确定所有这些公式，并且在代码库中的最小支持为20。 在违规用法中，对当前公式集与缺失公式集之间的关联的置信度[38]，对违规进行排序。 然后，它应用形式概念分析[35]来同时获取模式和违规。 TIKANGA的功能与JADET相同。 TIKANGA的作者进行的评估将检测器分别应用于六个项目，发现违反了特定于项目的模式。作者手动审查了每个项目中前25％的调查结果，总共有121个发现，并确认了9.9％的真实阳性（单个项目的0、0、8.3、20.0、21.4和33.3％）。 其他发现被归类为代码气味（29.8％）。</p>
<p>DROIDASSIST是Dalvik字节码（AndroidJava）[20]的检测器。 它从源代码生成方法调用序列，并从中学习隐马尔可夫模型，以计算特定调用序列的可能性。 如果可能性太小，则将序列视为违规。 然后，DROIDASSIST探索序列的不同修改（添加，替换和删除呼叫），以找到稍微修改的，更有可能的序列。 这使它可以检测丢失和冗余的方法调用，甚至可以为它们提出解决方案。 DROIDASSIST的作者在相应的论文中未对此机制进行评估。</p>
<p><strong><em>摘要</em></strong>：所有检测器均使用代码（摘要）作为训练和验证输入。 有些要求使用编译格式的代码，例如Java字节码，而另一些则直接使用源代码。 检测器通常将用法编码为集合，序列或图形。 对于同时编码用法元素，顺序和数据流关系，图形表示似乎很有希望。 除DROIDASSISTandDMMC以外，检测器根据其用法表示通过频繁项集/子序列/子图挖掘来挖掘模式。 为了检测违规，他们挖掘了很少见到的模式的不可扩展部分。这意味着它们无法检测到冗余元素，因为此类元素的使用绝不是任何模式的一部分。 DROIDASSIST例外，它可能不太可能找到冗余呼叫。</p>
<p><strong>表3总结了检测器针对MUC的功能</strong>。 <strong>总体而言，我们发现检测器仅涵盖所有API滥用类别的一小部分</strong>。 <strong>尽管所有检测器都可以在某种程度上识别丢失的方法调用，但只有四个检测器可以识别丢失的空检查和丢失的值或状态条件，只有三个可以识别丢失的迭代，只有两个可以识别丢失的异常处理。 没有一个探测器针对所有这些类别</strong>。</p>
<p>现有的检测器同时使用绝对最小支持阈值和相对最小支持阈值来识别模式。 再次例外的是DROIDASSIST和DMMC，它们使用概率方法。 由于许多检测器会产生大量的误报，因此它们使用各种排名策略。 其中大多数主要依靠模式支持，但也使用了一些不同的概念，例如稀疏性，陌生性或信念。在任何出版物中都未报告对不同排名策略的比较。</p>
<p><strong>表4总结了调查报告的实证评估，如其原始论文所报道。 多数评估将检测器分别应用于项目。</strong> 在这种情况下，检测人员将学习特定于项目的模式并识别相应的违规行为。 项目数量从1到20不等（平均5.3；中位数5）。 具体的项目样本都是截然不同的，甚至大部分都是不相交的。</p>
<p>为了评估检测性能，大多数作者回顾了他们的检测器的前X个发现，其中X是固定数字或百分比。 然后，他们要么呈现真实阳性的正相关性，要么测量检测器的精度。许多评估还提出了其他发现类别，例如代码气味，以将误报与其他对开发人员仍然有价值的非滥用发现区分开。 一个发现何时属于哪个类别（如果提供）的定义，即使出版物使用相同的标签（例如“bug”或“code smells”），也会有所不同。没有评估会考虑各个检测器的召回率。</p>
<p>总体而言，看来专注于特定违规（例如错误处理或缺少方法调用）的检测器具有更高的精度。 但是，仅基于检测器报告的经验结果对检测器进行比较是不可靠的，因为目标项目，审查样本量以及评估检测器发现的标准在研究之间存在差异。</p>
<h1 id="5-EXPERIMENTAL-SETUP"><a href="#5-EXPERIMENTAL-SETUP" class="headerlink" title="5. EXPERIMENTAL SETUP"></a>5. EXPERIMENTAL SETUP</h1><p>在<strong>第4节中</strong>，<strong>我们从概念上比较了检测器的功能</strong>。 在本节中，我们描述了经验性的比较其功能的实验设置。 <strong>我们设计了三个实验，以测量探测器的精度和召回率</strong>。 我们以MUBENCH真实数据集为基础建立这些实验。 这使我们能够比较相同目标项目上的所有检测器，并就相同的已知滥用进行比较。</p>
<p><strong>主题检测器</strong>。在本研究中，我们重点研究Java API的滥用检测器，因为MUBENCH包含Java-API滥用的示例。 我们的调查确定了七个此类检测器。 我们联系了各自的作者，并得到了所有人的答复。 但是，我们了解到我们无法运行CAR-MINER和ALATTIN，因为它们都依赖于GOOGLECODESEARCH，该服务不再可用[23]。我们排除了DROIDASSIST，因为其实现仅支持Dalvik Bytecode，2而MUBENCH中的示例是通用Java项目， 编译为Java字节码。<strong>这给我​​们留下了四个检测器JADET，GROUMINER，TIKANGA和DMMC</strong>。</p>
<p><strong>滥用数据集</strong>：我们使用第2节中所述的MUBENCH查找评估的目标。 尽管GROUMINER使用源代码，但JADET，TIKANGA和DMMC需要Java字节码作为输入。 因此，我们只能在具有源代码和字节码的项目版本上进行比较。 由于字节码不适用于数据集中的大多数项目版本，因此我们通过添加必要的构建文件并修复任何依赖关系问题来自行编译它们。 我们排除了无法修复的26个项目版本（占47％）的编译错误。 最后，我们有29个可编译的项目版本和25个手工制作的示例，总共有64个误用。 请注意，某些项目版本包含多种误用。 表1中的最后三行描述了我们在各个实验中使用的该数据集的子集。 我们发布了数据集[24]供其他人在将来的研究中使用。</p>
<h2 id="5-1-Experiment-P"><a href="#5-1-Experiment-P" class="headerlink" title="5.1 Experiment P"></a>5.1 Experiment P</h2><p><strong>我们设计实验P来评估探测器的精度</strong>。</p>
<p>动机。过去的研究表明，开发人员很少使用会产生许多误报的分析工具[39]，[40]，[41]。 因此，为了在实践中采用检测器，需要高精度。</p>
<p>设置。为了测量精度，我们遵循文献中最常见的实验设置（请参见表4）。首先，我们在各个项目版本上运行检测器。 在这种情况下，他们挖掘模式并在每个项目的基础上检测违规情况。 其次，我们根据各个探测器的排名策略来手动验证每个版本上每个探测器的前20个发现。 我们限制了发现的数量，因为开发人员似乎只会考虑固定数量的发现，而不是所有可能非常多的发现。 因此，检测器最重要发现的精确度对于采用工具至关重要。 另外，我们希望限制审查每个项目版本上多个检测器的发现的工作量。</p>
<p>数据集：由于无法手动检查所有项目版本上所有检测器的发现，因此我们对五个项目版本进行了采样。 为了确保公平选择项目，我们首先在所有项目版本上运行所有检测器。 出于实际原因，我们在两个小时后使每个探测器在单独的projectversion上超时。 表5中汇总了运行统计信息。</p>
<p><strong>JADET和TIKANG在一个项目版本上失败，而DMMC在四个项目版本上失败，因为字节码包含检测器各自的字节码工具包不支持的结构。</strong> GROUMINER在八个项目版本上超时，在另一个版本上产生错误。 我们排除使检测器发生故障的所有项目版本。</p>
<p>对于其余的15个版本，我们观察到发现的总数与各个检测器相关。 表6显示，除了JADET和GROUMINER（r¼0：49）以外，所有其他检测器对的成对相关（Pearson’sr）均为强（0:75）或中等（0：5）。 这意味着，在任何给定的项目版本中，所有检测器都报告相对较大的发现结果。 我们假设调查结果的总数可能与检测者准确识别给定项目版本中的滥用情况有关。 因此，我们根据所有检测器上发现的平均归一化数量对项目版本进行采样。 我们通过所有项目版本上该检测器的最大发现数量来归一化每个探测器在所有项目版本中的发现数量。 我们对所有检测器的平均归一化数量最高的两个项目（CLOSURE [42] v319和ITEXT [43] v5091）进行采样，对所有检测器的平均归一化数量最低的两个项目（JMRTD [44] v51和JODA-TIME[45] v1231）进行采样 。 此外，我们从其余项目中随机选择一个项目版本（APACHELUCENE [46] v1918），以涵盖中间立场。 <strong>请注意，我们从每个不同的项目中最多选择一个版本，</strong>因为同一项目的不同版本可能共享很多代码，因此检测器可能会对它们执行类似的操作。 表1的第3行汇总了该实验P的数据集。</p>
<p><strong>指标。我们计算探测器的精度，即，真实阳性数与发现数之间的比率。</strong></p>
<p>审查过程：两位作者独立审查了样本项目版本的前20个发现，并将其标记为是否滥用。 为了确定这一点，他们考虑了源代码中的逻辑和文档，API的文档及其实现（如果可公开获得）。审核后，将讨论审核者之间的任何分歧，直到达成共识为止。我们报告科恩的Kawcppa得分，以衡量审核者的同意程度。 请注意，我们遵循宽松的审核流程。 例如，假设用法在调用Iterator.next（）之前缺少检查 if（Iterator.hasNext（））。 如果检测器发现缺少hasNext（），我们将发现标记为命中，尽管这并未明确指出应通过检查hasNext（）的返回值来保护调用tonext（）。 这是根据我们的直觉，即这样的发现仍可能为开发人员提供有关该问题的宝贵提示。</p>
<p><img src="https://img-blog.csdnimg.cn/20200517184643917.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQzMzk2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="5-2-Experiment-RUB"><a href="#5-2-Experiment-RUB" class="headerlink" title="5.2 Experiment RUB"></a>5.2 Experiment RUB</h2><p><img src="https://img-blog.csdnimg.cn/20200517190145761.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQzMzk2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>我们设计了实验RUB，以评估目标探测器的探测能力，即在假设他们始终挖掘所需模式的前提下，测量其召回率的上限。</strong></p>
<p>动机。我们认为，对于开发人员来说，了解哪些滥用特定工具的可能是很重要的，以便确定该工具是否适合其使用情况，以及他们是否必须采取其他措施。 此外，<strong>对于研究人员来说，了解现有探测器可能会识别出哪种类型的滥用也很重要</strong>，以便指导未来的工作。 因此，我们在提供足够多正确用法的情况下测量探测器的召回率，使他们能够挖掘所需的pattern。</p>
<p>数据集：<strong>在本实验中，我们使用MUBENCH数据集中的所有可编译项目版本以及各自已知的误用以及手工制作的误用示例。 表1的第4行汇总了该实验RUB的数据集。</strong></p>
<p><strong>设置</strong>：请记住，我们所有的主题检测器都会挖掘模式，即频繁重复出现的API使用情况，<strong>并假定它们与正确的使用情况相对应</strong>。 他们使用这些模式来识别滥用。 进一步回想一下，每个检测器对用法和模式及其自身的挖掘和检测策略都有不同的表示。 如果检测器未能识别出特定的误用，则可能是由于（1）检测器的固有局限性，例如，因为它不能代表诸如条件之类的使用要素，或者（2）缺少相应正确用法的示例 模式挖掘，即训练数据的限制。 <strong>在实验RUB中，我们将重点放在（1）上，即，将（2）排除在等式之外，并评估检测器识别误用的一般能力</strong>。 <strong>为此，我们为检测器提供了足够多的正确用法示例，这些示例与所讨论的滥用相对应</strong>。这保证了它们可以挖掘各自的模式。 如果检测器无法在此设置中识别出误用，我们知道问题出在检测器本身上。</p>
<p><strong>我们使用MUBENCH中记录的修复提交为数据集中的每个滥用手动创建正确的用法</strong>。对于每个滥用，我们在修复提交之后将方法的整个代码与滥用一起使用，并删除所有与数据无关或不依赖控件的代码 涉及滥用的物品。 我们将<strong>精心设计的正确用法的代码存储在我们的数据集中</strong>.</p>
<p>在实验中，我们针对数据集中每个已知的误用操作对每个检测器运行一次。 在每次运行中，我们为检测器提供包含已知误用的文件以及相应制作的正确用法的50份副本。 我们确保检测器将每个副本视为不同的用法。 我们将检测器配置为在最小支持50的情况下挖掘模式，从而确保仅从精心设计的使用方法中的代码中挖掘模式。 我们选择50作为阈值，因为它足够高以确保没有检测器会从文件中的代码中挖掘出带有误用的模式。</p>
<p><strong>指标。我们为每个探测器计算两个数字。 第一个是其概念召回上限</strong>，它是数据集中与其表3中的功能匹配的已知误用的一部分。请注意，概念召回上限是离线计算的，无需运行任何实验。 <strong>第二个是检测器的经验召回上限</strong>，<strong>这是检测器实际上从数据集中所有已知的滥用中发现的滥用百分比</strong>。 理想探测器的经验召回上限应等于其概念召回上限。 否则，其实际能力与概念能力不匹配。 在这种情况下，我们调查了这种不匹配的根本原因。请注意，我们使用“上限”一词，因为这两种召回率均无法反映检测器在某个环境中的召回率，而无法保证正确使用挖掘的次数。</p>
<p>审查过程：为了评估结果，我们审查了所有潜在的命中点，即每个检测器的发现，这些发现将相同的文件和方法中的违规行为标识为已知的滥用，两位作者独立审查每个此类潜在的命中点，以确定它是否确实识别了已知的滥用之一。 如果至少一个潜在的命中现象标识了误用，我们将其视为命中。 审阅后，将讨论审阅者之间的任何分歧，直到达成共识为止。 我们报告科恩的Kappa得分是对评论者同意程度的衡量。 我们遵循与实验P相同的lenientreview过程。</p>
<h2 id="5-3-Experiment-R"><a href="#5-3-Experiment-R" class="headerlink" title="5.3 Experiment R"></a>5.3 Experiment R</h2><p><strong>我们设计实验R来评估探测器的召回率</strong>。</p>
<p>动机。尽管实验RUB为我们提供了滥用检测器召回的上限，但我们也想评估我们的实际召回率，如果我们自己没有为他们提供正确的用法。 由于缺乏真实的数据集，因此在我们调查的任何滥用检测论文中都没有尝试过这种实验。</p>
<p>数据集：作为此实验的基本事实，我们使用了MUBENCH中真实项目中的所有已知滥用以及实验P中任何检测器识别出的真阳性结果。这意味着实验R不仅可以评估对MUBENCH滥用的回忆。 ，但实际上也会相互交叉验证检测器的功能。 由于没有相应的检测器从中挖掘模式的代码，因此我们从该实验中排除了手工制作的滥用示例。 表1第5行汇总了我们用于实验R的数据集。<br>设置：我们分别在所有项目版本上运行所有检测器，即我们使用与针对实验P相同的每个项目设置。</p>
<p><strong>指标：我们计算检测器的召回率，即实际命中次数超过数据集中已知问题的次数</strong>。</p>
<p>审核流程。我们以与实验RUB相同的流程审核所有潜在匹配。 这使检测人员可以回想起MUBENCH大量已知的误用。</p>
<h1 id="6-MUBENCHPIPE"><a href="#6-MUBENCHPIPE" class="headerlink" title="6.MUBENCHPIPE"></a>6.MUBENCHPIPE</h1><p>为了系统地评估和比较API滥用检测器，我们<strong>建立了MUBENCHPIPE，这是API滥用检测器的基准测试管道</strong>。 MUBENCHPIPE可自动执行第5节中介绍的大部分实验设置，并有助于进行本研究。 它还可以在将来为比较添加新的检测器，并使用不同的或扩展的数据集进行基准测试。 我们发布了管道[24]以供将来研究。</p>
<h2 id="6-1-Automation"><a href="#6-1-Automation" class="headerlink" title="6.1 Automation"></a>6.1 Automation</h2><p>遵循BUGBENCH [47]和BEGBUNCH [48]等C程序的自动错误检测基准的想法，我们使用评估管道简化了我们误用数据集上多个检测器的基准测试。 MUBENCHPIPE使我们的许多评估步骤自动化，例如目标项目的检索和编译，运行检测器以及收集其发现。 MUBENCHPIPE提供了一个命令行界面来控制这些步骤。 随后，我们描述了为便于评估而实施的管道步骤。</p>
<p>Checkout.MUBENCHPIPE使用来自MUBENCH的记录的提交ID来获取相应项目版本的源代码。 它支持SVN和Git存储库，源存档（zip），以及MUBENCH随附的手工制作示例的特殊处理.</p>
<p>编译。对于每个项目版本，MUBENCHPIPE首先将整个项目源代码，包含已知滥用的单个文件以及为实验RUB设计的正确用法分别复制到一个单独的文件夹中。 然后，它使用数据集中的相应构建配置将所有Java源代码编译为Bytecode。 编译后，它将整个项目字节码，包含已知滥用的单个文件的字节码以及各自精心制作的正确用法的字节码复制到单独的文件夹中。 这样，我们可以分别为检测器提供每个部分的源代码或字节码。</p>
<p>检测：对于每个检测器，我们还构建了runner，以为所有检测器提供统一的命令行界面。 对于每个项目版本，MUBENCHPIPE都将调用带有各自源代码和字节码的路径的检测器。</p>
<p>将使用各自出版物中报告的最佳配置来调用所有检测器。 除了添加一些访问器方法以允许我们获取检测器的输出外，所有检测器的实现均保持不变。</p>
<p>验证。为了帮助对结果进行人工审查，MUBENCHPIPE自动将实验结果发布到审查网站[10]。 对于每次发现的检测器，网站都会显示发现的源代码以及检测器提供的任何元数据，例如违反的模式，违反的属性和检测器的置信度。</p>
<p>对于实验RUB和R，MUBENCHPIPE通过根据文件名和方法名将发现结果与已知的误用进行匹配，自动过滤潜在的匹配。 在审阅网站上，viewer看到了已知滥用的描述及其修复方法，以及需要审阅的一组潜在命中内容。 对于实验P，MUBENCHPIPE显示了查看站点上检测器的所有发现。</p>
<p>评论网站允许评论者保存对每个发现的评估和评论。 在自动计算实验统计信息（例如精度，召回率和科恩的Kappa得分）之前，它还可以确保每个发现至少有两次评论。</p>
<h2 id="6-2-Reproduction-Replication-and-Extension"><a href="#6-2-Reproduction-Replication-and-Extension" class="headerlink" title="6.2 Reproduction, Replication, and Extension"></a>6.2 Reproduction, Replication, and Extension</h2><p>MUBENCHPIPE带有Docker映像，该映像允许跨平台运行可重复的实验，而无需确保正确的环境设置。 它的评论网站带有第二个Docker映像，允许独立提供它。 此外，它基于PHP和MySQL，因此可以将其托管在任何现成的Web空间中。 审查网站即使在研究人员在不同地点工作时也可促进独立审查，同时使用身份验证确保审查完整性。该网站还可以直接用作发布审查结果和实验统计数据的工具。 MUBENCHPIPE为滥用示例定义了简单的数据模式，以简化MUBENCH的扩展。 它还提供了一个方便的Java接口作为Maven依赖项，以允许插入其他检测器以进行基准评估。有关如何使用或扩展MUBENCHPIPE的更多详细信息，请参见我们的项目网站[24]。</p>
<h1 id="7-RESULTS"><a href="#7-RESULTS" class="headerlink" title="7.RESULTS"></a>7.RESULTS</h1><p>现在我们讨论在实验中比较JADET，GROU-MINER，TIKANGA和DMMC的结果。 所有审阅数据都可以在我们的页面[10]上找到。</p>
<h2 id="7-1-Experiment-P"><a href="#7-1-Experiment-P" class="headerlink" title="7.1 Experiment P"></a>7.1 Experiment P</h2><p>表7显示了我们的精密度结果，其依据是我们对五个样本项目中每个检测器的前20个发现进行了回顾。 第二列显示了检查结果的总数，所有检测器中共有230个结果。 请注意，对于某些项目，所有检测器报告的结果少于20个。 第三列显示在解决分歧后已确认的滥用情况，第四列显示相对于已审查发现的准确性。 第五列显示了人工审核的Kappa评分，其余列显示了误报的根本原因的频率，我们发现所有检测器的精度都非常低，TIKANGA的最佳精度仅为11.4％。 JADET和DMMC紧随其后，精确度分别为10.3％和9.9％。 GROUMINER仅报告前20个发现中的假阳性。<br><img src="https://img-blog.csdnimg.cn/20200517191055325.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQzMzk2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">)<img src="https://img-blog.csdnimg.cn/20200517191111843.png" alt="在这里插入图片描述"><br>Kappa得分表明审稿人的认可度很高，这表明所有检测器产生的假阳性大多是明确的。 TIKANGA的得分略低，因为它报告了一次确认的滥用两次，其中一位观众首先认为是实际点击，而另一位观众则没有。 DMMC的分数也较低，因为我们最初不同意它标识的inIteratorusages中的一些违规行为，这些行为不检查hasNext（），而是底层集合的大小。</p>
<h3 id="7-1-1-True-Positives"><a href="#7-1-1-True-Positives" class="headerlink" title="7.1.1 True Positives"></a>7.1.1 True Positives</h3><p>在我们审查的230个报告发现中，我们确认了17个真正的误用。 DMMC报告未选中hasNext()的迭代器API的8次误用。 JADET报告了4个在访问集合之前没有检查其大小的误用。同样，对于集合，TIKANGA报告了4个缺失hasNext()误用，以及1个误用的缺失大小检查。 TIKANGA和JADET都报告了一种情况，TIKANGA和DMMC都报告了另一种情况。 此外，JADET报告同一个误用两次。 这就留下了14个独特的误用，所有这些都不同于MUBENCH中已知的误用。 有趣的是，所有这些误用都是缺失值或状态条件，对于这些条件，检测器只报告对应该在各自的缺失检查中使用的方法的缺失调用。 在我们宽松的审查过程中，我们接受这些调查结果。<br><img src="https://img-blog.csdnimg.cn/2020051719123636.png" alt="在这里插入图片描述"></p>
<h3 id="7-1-2-False-Positives"><a href="#7-1-2-False-Positives" class="headerlink" title="7.1.2 False Positives"></a>7.1.2 False Positives</h3><p>为了确定提高滥用检测器准确性的机会，我们系统地调查了他们报告的误报的根本原因。 在下文中，我们将讨论按其绝对频率顺序在所有检测器中汇总的这些根本原因。</p>
<p>1.不常见但正确的用法。<strong>特殊用法可能会违反检测器从频繁使用中学习的模式，而不会违反实际的API使用限制。 检测器无法区分不经常使用和无效使用</strong>。 例如，DMMC和JADE获悉MapEntry的方法getKey（）和getValue（）通常在代码中一起出现。如果缺少对这两个方法的调用，或者如果调用JADET，则它们以不同顺序出现，它们都报告违规。 但是，API不需要始终调用两个getter方法，更不用说按特定顺序调用了。 <strong>在我们分析的所有报告违规情况中，如果getter方法中的丢失或以不同顺序调用，则检测器会错误地报告42个缺少的方法调用</strong>。 另一个例子是JADET和TIKANGA了解通常在循环中调用诸如List.add（）和Map.put（）之类的方法，并报告循环外针对预期调用的五个缺失的迭代，这完全符合API。 诸如多层模式[49]或ALATTIN的替代模式[18]之类的方法可能有助于缓解此问题。 还要注意，我们实验中的四个检测器都使用绝对频率阈值，而我们在第4节中调查的某些检测器也使用了相对阈值。 未来的工作应该研究这两种选择之间的比较。<br><img src="https://img-blog.csdnimg.cn/20200517191336482.png" alt="在这里插入图片描述"><br>2.不精确分析。检测器使用静态分析来确定属于特定用法的事实。 这些分析的不精确性会导致误报。 例如，检测器错误地报告了代码中五个缺失的元素，这些元素对同一对象使用了多个别名，而在代码中又有17个带有嵌套控制语句。 在这两种情况下，分析都无法捕获属于相同用法的所有呼叫。 GROUMINER报告了两个丢失的方法调用，因为它无法解析链式方法调用的接收器类型，例如 for m（）in o.getX（）.m()，通常仅靠源代码是不可能的。 因此，GROUMINER无法匹配模式和用法之间的调用。 另一个例子是，由于对流畅的API（例如StringBuilder）的链接调用，检测器报告了八次方法丢失的调用，在这种分析中，检测器无法确定所有调用实际上发生在同一对象上。JADET，GROUMINER和DMMC一起报告了9个丢失的调用，这些调用在相同类的辅助方法中或通过包装对象（例如aBuffer-edStream）传递地发生。 DMMC报告一个丢失的调用，该调用位于匿名类实例的封闭方法中，并且对由调用者按合同关闭的参数进行amissingclose（）调用。 此外，GROUMINER报告由断言辅助方法检查的四个缺失条件。 PR-MINER [11]提出的一种过程间检测策略可以减轻这个问题。<br><img src="https://img-blog.csdnimg.cn/20200517191420683.png" alt="在这里插入图片描述"><br>3.替代模式。检测器通常会学习一个模式，然后将替代用法的实例报告为违规。我们将替代用法定义为使用API​​的不同功能正确方式，以实现相同或不同的功能。 注意，多种选择可能足够频繁地发生以引起图案。 例如，JADET，TIKANGA和DMMC了解到，在calltonext（）之前，应该始终有一个对onanIterator的hasNext（）调用。 因此，他们报告了16种违规用法，它们在通过Iterator仅获取第一个元素之前，先检查基础集合的isEmpty（）或size（）。 DMMC报告了另一个违规，因为在访问列表之前使用了Empty（）而不是size（）。 另一个示例是JADET，TIKANGA和DMMC通过调用add（）一次得知集合被填充一个元素，并报告了10种缺少的用法（例如通过构造函数或usingaddAll（）使用）来填充集合的用法不同的情况。 GROUMINER报告使用替代控制语句的四种用法，例如，用for代替while。</p>
<p>这种根本原因的一种特殊情况是获取类型实例的替代方法。 例如，GROUMINER错误地报告了两个丢失的构造函数调用，其中实例不是通过模式中的构造函数调用创建的，而是从方法调用返回的。 JADET和DMMC每个报告对象缺少构造函数调用，在这种情况下，实例不是创建的，而是作为参数传递的。 虽然处理替代模式是一个未解决的问题，但某些工具（如ALATTIN）已经提出了可能的解决方案[18]。<br><img src="https://img-blog.csdnimg.cn/20200517191518300.png" alt="在这里插入图片描述"><br>4.跨方法用法。存储在字段中的对象经常在该字段的声明类的多种方法中使用。 然后，各个方法内的各个API使用可能会偏离使用模式，而不会造成实际的滥用。 图1显示了这种情况的示例，其中使用Iterator类型的两个字段in和out来实现NeighborIterator类。 当不产生更多元素时（第12行），第14行中对next（）的调用将在不事先检查是否有更多元素的情况下发生。尽管这似乎是对封装方法内部的Iterator API的滥用，但这是对封装类内部的正确用法，因为NeighborIterator本身实现了Iterator，并因此继承了其使用约束。 正确调用NeighborIterator的用法需要在调用其next（）方法（第11行）之前检查其hassNext（）方法（第6行），以确保在调用next（）时没有更多的元素。 DMMC和GROUMINER报告了此类字段的此类用法的十六次违规。<br><img src="https://img-blog.csdnimg.cn/20200517191929379.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQzMzk2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>这种根本原因的一种特殊情况是，当类在其实现中使用其自己的API的一部分时。 例如，当aCollection在其addAll（）方法的实现中调用其自己的add（）方法时。 DMMC和GROUMINER报告了四个此类违规行为。 这特别有趣，因为这些实际上是API的自用，而检测器则以客户端使用为目标。 由于任何代码库都可能包含此类自用，因此检测人员应考虑这一点。<br><img src="https://img-blog.csdnimg.cn/20200517191820571.png" alt="在这里插入图片描述"><br>5.从属对象状态。当两个对象的状态相互依赖时，用法有时会检查一个对象的状态，并隐式得出关于另一个对象状态的结论。 检测器不考虑这种相互依赖性。 例如，当两个集合并行维护时，即始终具有相同的大小，在访问其中一个之前检查其中一个的大小就足够了。 在这种用法中，检测器错误地报告了14个丢失的尺寸检查。 在其中的10种情况下，以相同的方法构造集合可确保大小相等。 在其余四个案例中，在同一类别的其他位置进行保险。 我们认为这是一种危险的做法，因为如果集合之间的依赖关系发生变化，则很容易错过一些依赖它的代码。 因此，警告开发人员可能是有道理的。 但是，由于当前用法是正确的，因此我们将这些情况视为误报。<br><img src="https://img-blog.csdnimg.cn/20200517191847805.png" alt="在这里插入图片描述"><br>6.调用多重性。检测器无法处理可能经常被任意调用的方法。 GROUMINER和JADE都学习了一种模式，其中StringBuilderis的append（）方法被调用了两次，并错误地报告了三个缺失的方法调用，而该方法仅被调用了一次。<br><img src="https://img-blog.csdnimg.cn/20200517192007512.png" alt="在这里插入图片描述"><br>7.错误。一些发现可能是由检测器实现中的错误引起的。 DMMC报告了四次违规，缺少一组空缺的方法。 当所有可能丢失的方法都不符合DMMC的流行标准时，将产生这些空集。 DMMC应该在报告之前过滤掉这些空置的发现。 GROUMINER报告了实际上在所有各个用法中出现的一个缺失，因为它的图形映射与一种用法中的相应ifnode与所有其他用法中的对应节点不匹配。</p>
<h2 id="7-2-Experiment-RUB"><a href="#7-2-Experiment-RUB" class="headerlink" title="7.2 Experiment RUB"></a>7.2 Experiment RUB</h2><p>我们运行所有检测器，以查看MUBENCH的64种已知滥用中的哪些能在给定各自正确的模式挖掘用法时检测到。 表8显示了每个检测器的结果。 解决分歧后，第二列和第三列显示潜在的点击数和实际的点击数。 第四列和第五列分别显示了检测器的经验召回上限和概念召回上限。 第六列显示手动审核的Kappa分数。 其余各栏显示了导致表3中探测器的概念能力与其在本实验中的实际发现之间出现分歧的根本原因的频率。</p>
<p>我们发现GROUMINER迄今为止具有最佳召回率上限，并且在实验RUB中也表现出最佳召回率，这<strong>表明GROUMINER的图形表示是捕捉正确用法和模式之间差异的不错选择。</strong> 但是，GROUMINER在概念上的召回上限与经验上的召回上限之间的差距相当明显。 实际上，表8显示了所有四个检测器在实践中均远未达到其概念召回上限。</p>
<p>通常，我们观察到实际发现和概念能力之间的两种差异：意外的假阴性，即滥用检测器应该能够检测到的错误，以及意外的点击，即滥用检测器应该无法检测到的错误，但是 点击了。 我们调查了每种差异的根本原因，以找出可改进检测器的可行方法。<br><img src="https://img-blog.csdnimg.cn/20200517192127380.png" alt="在这里插入图片描述"><br>Kappa评分表明审稿人的同意程度很高，尽管比实验P中的要低。由于我们只审阅了潜在的点击率，即与已知的误用方法相同的发现，因此许多潜在的点击率与已知的误用有关。 因此，对于特定的潜在打击实际上是否能识别出特定的误用，我们存在一些分歧。 我们总共有18个这样的分歧（JADET：4; GROUMINER：6; DMMC：5; TIKANGA：3），这导致我们对第5.2节中所述的宽大审查流程进行了模拟。 其中有八种。我们观察到，JADET的Kappa得分比其他探测器低。 由于分歧的绝对数量是可比较的，并且JADETh的潜在匹配数相对较少，即，少量决策作为Kappa分数的基础，因此我们将较低的分数归因于机会。<img src="https://img-blog.csdnimg.cn/2020051719245735.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQzMzk2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="7-2-1-Unexpected-False-Negatives-判断为正常其实是误用）"><a href="#7-2-1-Unexpected-False-Negatives-判断为正常其实是误用）" class="headerlink" title="7.2.1 Unexpected False Negatives(判断为正常其实是误用）"></a>7.2.1 Unexpected False Negatives(判断为正常其实是误用）</h3><p>1.不精确的表示形式。当前的使用形式表示形式不足以捕捉到所有区分误用和正确用法所必需的细节。 例如，DMMC和GROUMINER仅按名称编码方法，因此，当用法调用相应方法的重载版本时，它们无法检测到丢失的方法调用。 例如，假设模式需要调用getBytes（String），但目标用法则调用getBytes（）。 理想的滥用检测器仍会报告违规，因为未调用具有正确参数的预期方法。 但是，<strong>由于在这两个检测器中仅将方法名称用于比较，因此不会检测到这种冲突</strong>。 另一个示例是，要使用Cipher实例进行解密，它必须处于解密模式。 通过将Cipher.DECRYPT传递给Cipher的init（）方法，可以确保此状态条件。 检测器中没有一个捕获这种确保条件成立的方式，因为它们未在其表示中对方法调用参数进行编码。<br><img src="https://img-blog.csdnimg.cn/2020051719225017.png" alt="在这里插入图片描述"><br>2.不精确的模式匹配。<strong>检测器无法关联模式和用法</strong>。 通常，检测器通过其常见事实将模式和使用情况联系起来。 如果没有或只有很少的常见事实，检测器不会报告违规。 例如，JADET的事实是一对方法调用。在偶然地在Jpack的pack（）方法之后调用JFrame的setPreferredSize（）方法的情况下，JADET用对&lt;pack,setPreferredSize&gt;表示模式，并用反向对表示模式。 由于JADET通过相等性比较事实，因此在模式和用法之间未发现任何关系。 在用法和模式之间没有常见事实的情况下，检测程序假定这是两个完全不相关的代码段，并且不报告冲突。 另一个示例是模式的事实与类型有关，例如ListinList.size（），而用法的事实与上级或子类型有关，例如ArrayList.size（）或Collection.size（）。 检测器无法关联这些事实，因为它们不知道类型层次结构。 此外，TIKANGA错失了四个误用，因为目标错过了两个以上的图案形式（TIKANGA的最大距离格式化）。 例如，图2显示了一个误用并没有关闭aWriterand的相应正确用法。在TIKANGA的表示中，误用和正确用法之间的区别由三个公式组成：（1）在以下情况下，close（）跟在write（）之后 正常执行，（2）如果close（）抛出异常，则close（）跟随，并且（3）在close（）之前进行空检查。<img src="https://img-blog.csdnimg.cn/20200517192419261.png" alt="在这里插入图片描述"><br>3.不精确的分析。检测器依靠静态分析来提取其使用表示。 这些分析中的不精确性可能会混淆模式和用法之间的关系，例如GROUMINER无法检测到一个丢失的空校验，因为它无法确定链式调用的接收方类型，例如form（）in o .getX（）.m（），而这通常是不可能的 仅源代码。 而且，由于它忽略了数据流依赖性，因此它无法检测到另外四个缺失的空检查。 图3示出了这种情况。<br><img src="https://img-blog.csdnimg.cn/2020051719252595.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200517192544187.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQzMzk2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>除了null检查外，GROUMINER还错过了缺失中从get（）调用到remove（）调用的数据流，这使模式和用法因多个事实而有所不同。 但是，GROUMINER仅在差异是单个事实的情况下才报告违规。 TIKANG拒绝在一种情况下以正确用法进行的呼叫，而在另一种情况下无法从正确用法中捕获两个呼叫之间的呼叫顺序。 我们假设原因是其分析的局限性，但最终无法验证这一点，因为该工具的开发人员无法确认实施细节。<br><img src="https://img-blog.csdnimg.cn/20200517192635471.png" alt="在这里插入图片描述"><br>4. Bug.DMMC如果模式包含的调用少于用法，则跳过用法和模式的比较，以提高性能。 例如，来自Apache HTTPCLIENT的AuthState模式需要三个调用，其中误用场景会丢失一个调用。但是，如果这种滥用有一个不在模式中的附加可选调用，则DMMC会跳过此模式和目标之间的比较 包含3个调用。 这在我们的实验中导致了两个意外的假阴性。</p>
<h3 id="7-2-2-Unexpected-Hits"><a href="#7-2-2-Unexpected-Hits" class="headerlink" title="7.2.2 Unexpected Hits"></a>7.2.2 Unexpected Hits</h3><p>1.宽松的审查程序：除了两个案例外，所有意外命中的原因都是我们对实验使用的宽松的审查程序(参见第5.2节)。 在大多数情况下，检测器报告指示缺少条件检查的缺少调用。 唯一的另一种情况是，在需要在事件分派线程上运行某些SWING代码的情况下，GROUMINER检测到丢失的上下文条件。通过将代码包装到Runnable的匿名实例中来实现对EDT的委托，如图4所示。GROUMINER认为run（）中的代码是封闭方法代码的一部分。 因此，它通过在JFrame实例化之前报告Runnable的丢失实例来建议滥用。<br><img src="https://img-blog.csdnimg.cn/20200517192931927.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQzMzk2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">)<img src="https://img-blog.csdnimg.cn/20200517192942793.png" alt="在这里插入图片描述"><br>2.捕获异常处理。在其余两种情况下，JADET和TIKANGA正确地报告缺少的异常处理。 例如，图5（左）显示了一个滥用，其中write（）引发异常时未调用close（）。右侧显示了相应的正确用法。TIKANGA和JADET都表示正确的用法有两个事实：{（write，close）;（write：EXC; close）}，在正常执行和发生异常的情况下，对close（）进行有效编码后调用afterwrite（）。 在滥用中，他们找到了第二个事实。 在相应的出版物中没有提到这种实现的能力。</p>
<h2 id="7-3-Experiment-R"><a href="#7-3-Experiment-R" class="headerlink" title="7.3 Experiment R"></a>7.3 Experiment R</h2><p>在实验R中，我们运行所有检测器以评估其召回率，而没有明确为它们提供正确的用法。 除了MUBENCH的64种误用之外，我们还从实验P中添加了14种新的误用，并排除了25种手工制作的示例，这些示例没有可从中挖掘模式的项目代码。 这给实验R留下了53次误用（表1第5行）。</p>
<p>表9显示了结果，图6显示了召回情况。JADET仅发现了在实验P中已经发现的三种滥用情况。GROUMINER找不到任何滥用情况。 TIKANGA发现了在实验P中已经发现的五种滥用，一种是在实验P中DMMC识别出的滥用，另一种是在实验P中JADETidenti-fied的滥用。 实验P，并且滥用了实验P中报告的JADET和TIKANG。</p>
<p>DMMC在实验R中显示出最好的召回率。这表明，在关注缺少的方法调用时，其相对简单的检测策略效果很好。 但是，在实验R提供的实际设置中，所有检测器的呼出率都很低。 通过分析其不良性能的根本原因，我们确定了探测器设计和评估设置的两个普遍问题。</p>
<p>1.排名不佳。实验R显示，检测器识别出的其他滥用行为超出了我们在实验P中考虑的前20个发现。不幸的是，他们将滥用行为的排名非常低。 例如，DMMC的两个MUBENCHmisuses排名分别为309和613。这远远超出了我们可以合理预期用户进行评估的发现数量。 我们实验中的四个检测器都使用不同的排名策略，但是我们在第4节的调查中没有一个检测器在同一检测器上比较不同的策略。<br><img src="https://img-blog.csdnimg.cn/2020051719311042.png" alt="在这里插入图片描述"><br>2.缺乏使用示例。实验RUB和实验R在检测器性能上的巨大差异表明，原因是目标项目中缺少正确的使用示例。 一种可能是此类示例的数量小于检测器对模式挖掘的最小支持，在这种情况下，我们可以简单地降低这些阈值。 但是，由于开采模式通常变得不那么可靠，这也可能会增加误报的数量，这强调了有效过滤误报（O1）和改善排名（O14）的需要。 <strong>另一种可能性是项目中不存在或仅存在很少的此类示例。</strong> 对于滥用检测器的评估设置，这将是一个普遍的问题。 为了解决这个问题，我们需要使用示例的其他来源来消除其模式。 Gruska等。 [37]通过在一个有6,000个项目的多项目环境中应用JADET展示了一种可能的方法，但是没有衡量召回率。 其他软件工程推荐系统，例如代码完成引擎[50]，是跨项目工作的，也就是说，他们从大量项目中学习，以为其他项目提供建议。 滥用检测器CAR-MINER [17]和ALATTIN [18]通过代码搜索引擎专门搜索目标项目中使用的API的使用示例，从而实现了一种替代方法。 与此相关的是，其他研究领域建议代码搜索引擎在开源项目[51]，[52]或StackOverflow [53]中查找使用示例。<br><img src="https://img-blog.csdnimg.cn/20200517193138903.png" alt="在这里插入图片描述"><br>Kappa评分表明实验R中的评论者意见基本完美。这是因为检测器几乎完全发现了其中一个在实验P中也已发现的滥用行为，即我们之前已经同意的滥用行为。DMMC是个例外，我们最初不同意它在14种潜在命中问题之一中对原始MUBENCH数据集的误用。</p>
<h2 id="7-4-User-Experience"><a href="#7-4-User-Experience" class="headerlink" title="7.4 User Experience"></a>7.4 User Experience</h2><p>现在，我们报告使用主题滥用检测器的用户的经验。 我们的观察结果基于我们在检查实验中检测器的发现时获得的经验。</p>
<p>DMMC仅报告当前和缺少的方法调用，以及第一个当前调用的源行号。我们发现此输出通常易于理解。 行号特别有助于在大型方法中定位使用情况。GROUMINER报告模式和使用情况图，这更难理解。 但是，我们发现图形表示形式捕获的源代码的结构特性有助于解释。 JADETandTIKANG报告其各自表示形式的当前和缺少的事实。 我们发现通常很难将事实相互关联，尤其是在存在多个相同API的情况下。 这可能部分是由于我们查看的文本表示。 尽管没有一种检测器实现旨在将其发现提供给最终用户，但仍然值得关注的是，解释发现的挑战似乎与源代码和用法表示之间的距离相关.</p>
<p>我们还发现基于字节码的检测器可能会报告编译器引入的代码中的发现。 例如，编译器将foreach循环转换为Iteratorusages。 TIKANGA在这种用法中报告丢失的呼叫，即，它在Iterator不出现在源代码中的方法中报告onIterator的丢失的呼叫。 这个发现起初使我们感到困惑。 尽管可以采取其他步骤来帮助用户将这些发现映射回源代码，但是基于源的检测器不会遇到此问题。</p>
<p>我们宽松的审查过程显示，丢失的方法调用通常表示缺少的条件(O2和O13)。虽然这样的发现不能报告整个问题，但我们发现推断它们的含义相对容易。 相反，当GROUMINER覆盖缺失的条件时，它只报告一个丢失的节点。 虽然这些发现更明确地指出了支票遗漏的问题，但我们觉得实际上很难采取行动，因为它们没有给出应该检查什么的信息。 这表明检测器识别违规行为的能力与向用户解释该违规行为的能力之间存在差距。</p>
<p>最重要的是，我们认为探测器的精度可能是其在实践中的适用性的最大威胁。 作为约翰逊等人以前的研究。 [41]表明，大量误报是采用代码分析工具的主要障碍。 检测器的召回率低使此问题变得更糟。 即使开发人员花时间审查所有报告的警告，他们仍可能会遗漏绝大多数误用。</p>
<h2 id="7-5-Call-to-Action"><a href="#7-5-Call-to-Action" class="headerlink" title="7.5 Call to Action"></a>7.5 Call to Action</h2><p>我们发现，如果提供了正确的用法以与（实验RUB）进行比较，则误用检测器实际上能够检测出MUBENCH中相当一部分的误用。<br>但是，即使检测器也能够在现实环境中发现一些误用（实验P和实验R），它们的精度（O1）和召回率（O15）却极低。 我们确定了假阴性的四个根本原因，假阳性的七个根本原因以及检测器设计及其通常评估方式的两个一般性问题。 这使我们对如何提高API滥用检测的最新水平提出了几点看法。 因此，我们呼吁研究人员采取行动：</p>
<ul>
<li>首先，我们需要对API用法进行精确定义，并考虑用法属性，例如用法位置（O6）和调用多重性（O8）。</li>
<li>我们需要这样一种用法的表示形式，以捕获所有区分正确用法和误用所必需的代码细节（ O10）和更精确的分析以识别代码中的用法（O4和O12）。</li>
<li>我们需要使用项目外部资源（例如大型项目集或代码搜索引擎（O15））来检索足够多的用法示例的检测器。</li>
<li>我们需要的检测器必须超出天真的假设，即偏离最频繁使用对应于滥用（O3），但要考虑程序语义，例如类型层次结构（O11）和对象之间的隐式依赖关系（O7）。 我们假设概率模型可能是解决此问题的一种方法。</li>
<li>我们需要在存在违规情况下（O9和O11）正确匹配模式和用法的策略，</li>
<li>我们需要在同一API（O5）上正确处理替代模式的策略。 </li>
<li>我们需要良好的排名策略，以减少评审结果的成本（O14）。</li>
</ul>
<p>为了实现所有这些，我们需要可重复和可复制的研究，以使系统评估和分析替代方法和策略成为可能。 我们发布了MUBENCHand MUBENCHPIPE [24]，作为此类工作的基础，并呼吁研究人员使用该基础结构并对此做出贡献，以提高API滥用检测的最新水平。</p>
<h1 id="8-THREATS-TO-VALIDITY"><a href="#8-THREATS-TO-VALIDITY" class="headerlink" title="8.THREATS TO VALIDITY"></a>8.THREATS TO VALIDITY</h1><p>构建有效性。任何检测器的性能都取决于其配置。 由于审核发现的工作量很大，因此我们无法为每个检测器尝试不同的配置。 但是，为了给每个检测器一个公平的机会，我们使用了各自出版物中报告的最佳配置。</p>
<p>我们的研究集中于静态误用检测器。 基于动态分析的方法可能会表现不同，并且具有独特的优点和缺点。 为了对MUBENCH中的项目版本进行动态分析，我们必须确保相应的代码是可执行的（除了编译时依赖关系之外，还需要足够的运行时环境），并提供执行示例输入。 目前尚不清楚如何做到这一点，从而可以对静态技术和动态技术进行公平的比较，而不必诉诸于将苹果与橙子进行比较。 在这项工作中，我们仅关注静态方法。</p>
<p>我们的实验重点是检测Java代码中的滥用情况的检测器。 因此，结果可能无法推广到其他语言的检测器。 我们决定专注于检测器的这一子集，因为我们在调查中确定的大多数方法都针对Java。为了包括针对其他语言的检测器，我们将不得不将它们迁移到Java或为相应的语言建立其他数据集，这两者都不在本文的范围之内。</p>
<p>内部有效性。审查检测器的发现是由三位作者完成的，并且不是盲目的（即，不知道我们正在审查发现器的检测器）。 我们无法进行盲目审查，因为每种方法都具有无法匿名使用和使用的违规表示。 此外，该工作的两名作者是GROUMINER的原始作者。 我们尽力客观地进行了审查。 为避免产生偏见，至少有两名审阅者独立查看每个发现。 在GROUMINER的调查结果中，至少有一位审稿人没有参与原始工作。</p>
<p>虽然我们确实要求原始作者确认我们对其工具的概念能力的评估，但并未要求他们确认我们实验的经验结果。 我们估计，包括解决分歧的讨论在内，每位审稿人平均需要2分钟的时间来验证检测器是否识别出了实验RUB和R中的已知滥用之一，并需要5分钟来验证检测器的发现是否标识出了实验P中的实际滥用，其中 我们需要了解相应的代码，检查文档，有时还需要研究可传递方法。 每个审稿人的审阅时间为24.8小时，JADET为4小时，GROUMINER为7.2小时，TIKANGA为4.7小时，DMMC为8.9小时。 我们认为期望原作者花这么多时间来验证我们的评估是不合理的。 但是，我们确实发布了所有审查数据[10]，以使他们和其他人可以重新审视我们的决定。</p>
<p>外部有效性。MUC中可能存在一些遗漏的违规类别。 MUBENCH数据集可能还没有足够的所有违规示例。 这可能会影响检测器的比较。 但是，现有的MUBENCH数据集基于来自最新状态数据集的1200多个报告以及开发人员的输入[3]和有关API使用指令的两次实证研究的结果。 我们对现有探测器功能的调查还包括12个探测器。 这使得我们不太可能错过普遍流行的类别。</p>
<p>我们的数据集可能无法代表现实世界中所有可能的API滥用，特别是因为我们只能编译55个项目版本中的29个（52％），并且不得不从我们的实验中排除其他版本中的滥用。 从项目的源代码管理历史中编译项目的任意版本是一项艰巨的任务。 我们投资了一位作者的两个星期的工作，以及一个学生另外三个月的工作，以尽可能地包含许多项目版本。 仍然，失去我们无法编译相应项目版本的示例可能会使我们的实验结果产生偏差。</p>
<p>理想情况下，我们的实验应包括来自大量项目的成千上万个误用项，并且在每个单独的项目版本中都可以使用，以使我们对结果的可推广性更有信心。 但是，目前尚无此类数据集。 我们花了几个月的时间来收集和准备MUBENCH的当前状态，以迈向大型基准测试的第一步。 现在我们已经有了基础架构，可以使用来自不同来源的滥用示例来扩展MUBENCH。</p>
<p>我们发布了MUBENCHPIPE和MUBENCH [24]，并鼓励其他人扩展数据集并重复我们的实验，同时使用其他探测器和探测器配置。</p>
<h1 id="9-CONCLUSIONS"><a href="#9-CONCLUSIONS" class="headerlink" title="9. CONCLUSIONS"></a>9. CONCLUSIONS</h1><p>API滥用检测器通过警告开发人员代码中可能存在的滥用行为，帮助开发人员编写更好的软件。尽管存在许多此类检测器，但仍未尝试系统地研究API滥用的类型并相应地设计检测器。 在本文中，我们通过基于100个误用的数据集创建MUC来解决此差距。 通过评估12个现有探测器相对于MUC的概念能力，我们从质量上确定了缺点。 Wethen开发了一个自动基准测试管道MUBENCH-PIPE，以根据经验评估四个现有检测器。 我们的结果表明，误用检测器在明确提供正确的用法以从中进行挖掘时，实际上能够检测出误用。 但是，它们的精度极低，并且在实际的应用程序设置中会被召回。 我们确定了误报的四个根本原因，误报的七个根本原因以及检测器的设计和常用的评估设置两个普遍的问题。 这些使我们对如何在将来的工作中提高API滥用检测的最新水平提出了几点看法。 我们发布了所有工具和数据集[24]，以鼓励其他研究人员沿着这条道路加入我们。</p>
]]></content>
      <tags>
        <tag>论文</tag>
      </tags>
  </entry>
</search>
